---
phase: 04-make-initialize-idempotent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/modules/Module.h
  - src/modules/TrackerSequencer.h
  - src/modules/TrackerSequencer.cpp
  - src/modules/MultiSampler.cpp
autonomous: true

must_haves:
  truths:
    - "Second call to initialize() returns immediately without re-subscribing"
    - "Destructor unsubscribes from ALL PatternRuntime events"
    - "Module base class provides isInitialized_ flag for all subclasses"
    - "PatternRuntime triggerEvent subscription is tracked with patternTriggerListenerRegistered_ flag"
    - "All 4 subscription paths use consistent unsubscribe-before-subscribe pattern"
  artifacts:
    - path: "src/modules/Module.h"
      provides: "isInitialized_ flag in protected section"
      contains: "bool isInitialized_"
    - path: "src/modules/TrackerSequencer.h"
      provides: "patternTriggerListenerRegistered_ flag"
      contains: "bool patternTriggerListenerRegistered_"
    - path: "src/modules/TrackerSequencer.cpp"
      provides: "Idempotent initialize() with complete destructor cleanup and subscription tracking"
      contains: "if (isInitialized_) return"
    - path: "src/modules/MultiSampler.cpp"
      provides: "Idempotent initialize()"
      contains: "if (isInitialized_) return"
  key_links:
    - from: "src/modules/TrackerSequencer.cpp"
      to: "src/modules/Module.h"
      via: "inherits isInitialized_ from Module base class"
      pattern: "isInitialized_"
    - from: "src/modules/TrackerSequencer.cpp"
      to: "PatternRuntime events"
      via: "ofRemoveListener in destructor"
      pattern: "sequencerBindingChangedEvent"
---

<objective>
Add idempotency guards to all module `initialize()` methods AND fix all PatternRuntime subscription paths to prevent duplicate event subscriptions.

Purpose: Fix edge case where:
1. `initialize()` is called during setup AND after session restore, causing duplicate subscriptions
2. Pattern binding changes (lines 835, 2579, 2652) add NEW listeners without removing existing ones when boundPatternName_ was empty

Output: 
- All module `initialize()` methods guard against double-initialization
- TrackerSequencer destructor unsubscribes from ALL events
- All 4 triggerEvent subscription paths properly track and manage listener state
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-make-initialize-idempotent/04-RESEARCH.md

@src/modules/Module.h
@src/modules/TrackerSequencer.h
@src/modules/TrackerSequencer.cpp
@src/modules/MultiSampler.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add isInitialized_ flag to Module base class</name>
  <files>src/modules/Module.h</files>
  <action>
Add `bool isInitialized_ = false;` to the protected section of Module class.

Location: After line 901 (`std::atomic<bool> enabled_{true};`) and before line 903 (`std::string instanceName_;`).

Add this line with a comment:
```cpp
bool isInitialized_ = false;  // Prevents duplicate initialization in derived classes
```

This provides a consistent idempotency flag for all Module subclasses.
  </action>
  <verify>
`grep -n "isInitialized_" src/modules/Module.h` shows the new flag in protected section.
  </verify>
  <done>
Module.h has `bool isInitialized_ = false;` in protected section, usable by all derived classes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add patternTriggerListenerRegistered_ flag to TrackerSequencer.h</name>
  <files>src/modules/TrackerSequencer.h</files>
  <action>
Add a new flag to track PatternRuntime triggerEvent subscription state.

Location: After line 347 (`bool listenersRegistered_ = false;`), add:
```cpp
bool patternTriggerListenerRegistered_ = false;  // Flag to prevent duplicate PatternRuntime triggerEvent registration
```

This flag will be used by all 4 subscription paths to ensure we never have duplicate listeners:
- initialize() line 184
- update() sync logic line 835
- bindToPattern() line 2579
- onSequencerBindingChanged() line 2652
  </action>
  <verify>
`grep -n "patternTriggerListenerRegistered_" src/modules/TrackerSequencer.h` shows the new flag.
  </verify>
  <done>
TrackerSequencer.h has `bool patternTriggerListenerRegistered_ = false;` flag for tracking triggerEvent subscription.
  </done>
</task>

<task type="auto">
  <name>Task 3: Make TrackerSequencer::initialize() idempotent and fix destructor</name>
  <files>src/modules/TrackerSequencer.cpp</files>
  <action>
Three changes required:

**1. Add guard at top of initialize() (line 72):**
After the method signature opening brace, add:
```cpp
    // Idempotency guard - prevent duplicate subscriptions on second call
    if (isInitialized_) return;
```

**2. Update PatternRuntime subscription block (lines 182-189):**
Replace the unconditional subscription with flag-guarded version:
```cpp
    // Subscribe to PatternRuntime events for forwarding
    if (patternRuntime_ && !patternTriggerListenerRegistered_) {
        ofAddListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
        patternTriggerListenerRegistered_ = true;
        // Subscribe to pattern deletion events for cleanup
        ofAddListener(patternRuntime_->patternDeletedEvent, this, &TrackerSequencer::onPatternDeleted);
        // Subscribe to sequencer binding change events for immediate sync
        ofAddListener(patternRuntime_->sequencerBindingChangedEvent, this, &TrackerSequencer::onSequencerBindingChanged);
    }
```

**3. Add flag at end of initialize() (before closing brace):**
```cpp
    isInitialized_ = true;
```

**4. Fix destructor to unsubscribe from ALL PatternRuntime events (lines 30-36):**
Change destructor to:
```cpp
TrackerSequencer::~TrackerSequencer() {
    // Unsubscribe from ALL PatternRuntime events
    if (patternRuntime_) {
        if (patternTriggerListenerRegistered_) {
            ofRemoveListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
            patternTriggerListenerRegistered_ = false;
        }
        ofRemoveListener(patternRuntime_->patternDeletedEvent, this, &TrackerSequencer::onPatternDeleted);
        ofRemoveListener(patternRuntime_->sequencerBindingChangedEvent, this, &TrackerSequencer::onSequencerBindingChanged);
    }
}
```

WHY: 
- Line 188 subscribes to `sequencerBindingChangedEvent` but destructor doesn't unsubscribe
- triggerEvent removal should check patternTriggerListenerRegistered_ to avoid double-remove
  </action>
  <verify>
1. `grep -n "if (isInitialized_) return" src/modules/TrackerSequencer.cpp` shows guard in initialize()
2. `grep -n "isInitialized_ = true" src/modules/TrackerSequencer.cpp` shows flag being set
3. `grep -n "patternTriggerListenerRegistered_" src/modules/TrackerSequencer.cpp` shows flag usage
4. `grep -n "sequencerBindingChangedEvent" src/modules/TrackerSequencer.cpp` shows unsubscribe in destructor
  </verify>
  <done>
TrackerSequencer::initialize() is idempotent (early return if already initialized).
TrackerSequencer destructor unsubscribes from triggerEvent, patternDeletedEvent, AND sequencerBindingChangedEvent.
PatternRuntime subscriptions are guarded by patternTriggerListenerRegistered_ flag.
  </done>
</task>

<task type="auto">
  <name>Task 4: Fix update() sync logic subscription path (line 835)</name>
  <files>src/modules/TrackerSequencer.cpp</files>
  <action>
Fix the subscription path in update() that handles pattern binding sync.

**Current code (lines 829-835):**
```cpp
            // Unsubscribe from old pattern events
            if (!oldPattern.empty()) {
                ofRemoveListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
            }
            
            // Subscribe to new pattern events
            ofAddListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
```

**Change to:**
```cpp
            // Unsubscribe from old pattern events (if registered)
            if (patternTriggerListenerRegistered_) {
                ofRemoveListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
                patternTriggerListenerRegistered_ = false;
            }
            
            // Subscribe to new pattern events
            ofAddListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
            patternTriggerListenerRegistered_ = true;
```

WHY: The old code only unsubscribes if `!oldPattern.empty()`, but initialize() may have already registered a listener when boundPatternName_ was still empty. Using the flag ensures we always unsubscribe if registered.
  </action>
  <verify>
`grep -n "patternTriggerListenerRegistered_" src/modules/TrackerSequencer.cpp | grep -E "8[23][0-9]"` shows flag usage around line 830.
  </verify>
  <done>
update() sync logic uses patternTriggerListenerRegistered_ flag for proper unsubscribe-before-subscribe.
  </done>
</task>

<task type="auto">
  <name>Task 5: Fix bindToPattern() subscription path (line 2579)</name>
  <files>src/modules/TrackerSequencer.cpp</files>
  <action>
Fix the subscription path in bindToPattern().

**Current code (lines 2566-2579):**
```cpp
    if (!boundPatternName_.empty()) {
        ofRemoveListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
    }
    
    boundPatternName_ = patternName;
    
    // ... patternRuntime_->bindSequencerPattern() call ...
    
    // Subscribe to PatternRuntime events for forwarding
    ofAddListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
```

**Change to:**
```cpp
    // Unsubscribe from old pattern events (if registered)
    if (patternTriggerListenerRegistered_) {
        ofRemoveListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
        patternTriggerListenerRegistered_ = false;
    }
    
    boundPatternName_ = patternName;
    
    // ... patternRuntime_->bindSequencerPattern() call ...
    
    // Subscribe to PatternRuntime events for forwarding
    ofAddListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
    patternTriggerListenerRegistered_ = true;
```

WHY: Same issue - the old code only unsubscribes if `!boundPatternName_.empty()`, missing listeners added when boundPatternName_ was empty.
  </action>
  <verify>
`grep -n "patternTriggerListenerRegistered_" src/modules/TrackerSequencer.cpp | grep -E "25[67][0-9]"` shows flag usage around line 2570.
  </verify>
  <done>
bindToPattern() uses patternTriggerListenerRegistered_ flag for proper unsubscribe-before-subscribe.
  </done>
</task>

<task type="auto">
  <name>Task 6: Fix onSequencerBindingChanged() subscription path (line 2652)</name>
  <files>src/modules/TrackerSequencer.cpp</files>
  <action>
Fix the subscription path in onSequencerBindingChanged().

**Current code (lines 2646-2652):**
```cpp
        // Unsubscribe from old pattern events
        if (!oldPattern.empty()) {
            ofRemoveListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
        }
        
        // Subscribe to new pattern events
        ofAddListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
```

**Change to:**
```cpp
        // Unsubscribe from old pattern events (if registered)
        if (patternTriggerListenerRegistered_) {
            ofRemoveListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
            patternTriggerListenerRegistered_ = false;
        }
        
        // Subscribe to new pattern events
        ofAddListener(patternRuntime_->triggerEvent, this, &TrackerSequencer::onPatternRuntimeTrigger);
        patternTriggerListenerRegistered_ = true;
```

WHY: Same pattern as Tasks 4 and 5 - consistent unsubscribe-before-subscribe using flag.
  </action>
  <verify>
`grep -n "patternTriggerListenerRegistered_" src/modules/TrackerSequencer.cpp | grep -E "26[45][0-9]"` shows flag usage around line 2650.
  </verify>
  <done>
onSequencerBindingChanged() uses patternTriggerListenerRegistered_ flag for proper unsubscribe-before-subscribe.
  </done>
</task>

<task type="auto">
  <name>Task 7: Make MultiSampler::initialize() idempotent</name>
  <files>src/modules/MultiSampler.cpp</files>
  <action>
Add idempotency guard to MultiSampler::initialize() for consistency.

**1. Add guard at top of initialize() (line 579, after the opening brace):**
```cpp
    // Idempotency guard - prevent duplicate initialization
    if (isInitialized_) return;
```

**2. Add flag at end of initialize() (before closing brace):**
```cpp
    isInitialized_ = true;
```

NOTE: MultiSampler::initialize() doesn't have event subscriptions, but adding the guard:
- Prevents redundant preloadAllSamples() calls
- Ensures consistency across all modules
- Future-proofs against subscription additions
  </action>
  <verify>
1. `grep -n "if (isInitialized_) return" src/modules/MultiSampler.cpp` shows guard in initialize()
2. `grep -n "isInitialized_ = true" src/modules/MultiSampler.cpp` shows flag being set
  </verify>
  <done>
MultiSampler::initialize() is idempotent (early return if already initialized).
  </done>
</task>

</tasks>

<verification>
1. Build verification: `make -j8` (or project build command) completes without errors
2. All modules compile with the isInitialized_ flag from base class
3. TrackerSequencer compiles with patternTriggerListenerRegistered_ flag
4. No duplicate subscription warnings in logs during session restore
5. Pattern binding changes don't cause duplicate event handlers
</verification>

<success_criteria>
- Module.h has `isInitialized_` flag in protected section
- TrackerSequencer.h has `patternTriggerListenerRegistered_` flag
- TrackerSequencer::initialize() guards with `if (isInitialized_) return;` at top
- TrackerSequencer destructor unsubscribes from ALL 3 PatternRuntime events
- All 4 triggerEvent subscription paths (lines 184, 835, 2579, 2652) use patternTriggerListenerRegistered_ flag
- MultiSampler::initialize() guards with `if (isInitialized_) return;` at top
- Project builds successfully with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-make-initialize-idempotent/04-01-SUMMARY.md`
</output>
