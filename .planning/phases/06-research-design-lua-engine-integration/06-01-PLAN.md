---
phase: 06-research-design-lua-engine-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/phases/06-research-design-lua-engine-integration/06-DESIGN.md
  - .planning/ROADMAP.md
autonomous: true

must_haves:
  truths:
    - "Target Lua-Engine architecture is documented with clear contracts"
    - "Execution models are defined (fire-and-forget vs reactive)"
    - "State sync mechanism is designed for live coding workflow"
    - "Implementation path is clear with prioritized sub-phases"
    - "Critical blocker (engine global) is first implementation priority"
  artifacts:
    - path: ".planning/phases/06-research-design-lua-engine-integration/06-DESIGN.md"
      provides: "Target architecture design document"
      min_lines: 150
      contains: "## Execution Model Contracts"
    - path: ".planning/ROADMAP.md"
      provides: "Updated roadmap with implementation sub-phases"
      contains: "Phase 6.1"
  key_links:
    - from: "06-DESIGN.md"
      to: "06-RESEARCH.md"
      via: "Design derived from research findings"
      pattern: "Based on.*RESEARCH"
    - from: "ROADMAP.md"
      to: "06-DESIGN.md"
      via: "Implementation phases reference design"
      pattern: "Phase 6\\.[1-4]"
---

<objective>
Create the target architecture design document and implementation roadmap for Lua-Engine integration.

Purpose: Transform research findings into actionable design and prioritized implementation plan. This is the final deliverable of Phase 6 - documentation that enables implementation in sub-phases 6.1, 6.2, etc.

Output: DESIGN.md with target architecture, updated ROADMAP.md with implementation sub-phases
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-research-design-lua-engine-integration/06-CONTEXT.md
@.planning/phases/06-research-design-lua-engine-integration/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DESIGN.md with Target Architecture</name>
  <files>.planning/phases/06-research-design-lua-engine-integration/06-DESIGN.md</files>
  <action>
Create DESIGN.md documenting the target Lua-Engine integration architecture. Structure:

## Overview
Brief summary: SWIG bindings + command queue + state observer pattern

## Current Architecture Problems
Summarize from RESEARCH.md:
1. `engine` global NEVER created (CRITICAL BLOCKER)
2. LuaHelpers use string commands instead of command objects
3. setBPM fallback bypasses Engine notifications
4. No reactive callback mechanism for live coding

## Target Architecture

### Lua State Initialization
- Engine::setupLua() must register `engine` global
- SWIG bindings accessible via engine:* syntax
- LuaGlobals provides C++ access via getGlobalEngine()

### Execution Model Contracts

**Fire-and-Forget (Initial Execution):**
- Script runs once via Engine::eval()
- Commands enqueued to command queue
- State updates asynchronously via notification queue
- Callback returns immediately with success/failure

**Reactive Sync (Live Coding):**
- Script registers callback via engine:onStateChange(fn)
- Callback invoked when Engine state changes
- Callback receives immutable EngineState snapshot
- Used for scripts that need to stay synced with external changes

### State Sync Architecture
```
User Edit ‚Üí Engine::eval() ‚Üí Command Queue ‚Üí Audio Thread
                                                 ‚Üì
                                          State Changed
                                                 ‚Üì
Observers ‚Üê Notification Queue ‚Üê updateStateSnapshot()
    ‚Üì
ScriptManager regenerates script
    ‚Üì
Lua callbacks invoked (if registered)
```

### Command Routing
- ALL state mutations via command queue
- SetParameterCommand for parameters
- AddModuleCommand for module creation (NEW)
- ConnectCommand for connections
- Fallback uses executeCommandImmediate(), never direct calls

## API Contracts

### engine:onStateChange(callback) ‚Üí callbackId
- Registers Lua function for state change notifications
- Returns integer ID for unregistration
- Callback signature: function(state) where state is EngineState

### engine:removeStateChangeCallback(callbackId) ‚Üí boolean
- Removes previously registered callback
- Returns true if found and removed

## Implementation Priority
(Reference to roadmap sub-phases)
1. Phase 6.1: Register engine global (CRITICAL - unblocks everything)
2. Phase 6.2: Fix command routing (HIGH - consistency)
3. Phase 6.3: Add reactive callbacks (MEDIUM - live coding support)

## Decisions from CONTEXT.md
- Fire-and-forget for initial execution ‚úì
- Reactive callbacks for live coding ‚úì
- Full state sync - scripts access complete EngineState ‚úì
- All shells display same Engine state ‚úì
  </action>
  <verify>File exists and contains sections: Overview, Target Architecture, Execution Model Contracts, API Contracts, Implementation Priority</verify>
  <done>DESIGN.md documents target architecture with clear contracts for fire-and-forget and reactive execution models</done>
</task>

<task type="auto">
  <name>Task 2: Update ROADMAP.md with Implementation Sub-Phases</name>
  <files>.planning/ROADMAP.md</files>
  <action>
Add implementation sub-phases after Phase 6 section in ROADMAP.md. Insert BEFORE "## Deferred to Future Work" section.

Add these sub-phases based on RESEARCH.md priority matrix:

---

## Phase 6.1: Register Engine Global (CRITICAL)

**Goal:** Fix the critical blocker preventing ANY scripts from working - register `engine` global in Lua state.

**Status**: üîµ Not Started

**Depends on:** Phase 6

**Context:**
ScriptManager generates scripts that reference `engine:getClock()`, `engine:getModuleRegistry()`, etc., but `engine` global is NEVER created. The `registerEngineGlobal()` function exists in videoTracker.i but is never called from Engine::setupLua().

**Work:**
- Add engine global registration to Engine::setupLua() after line 295
- Use SWIG_NewPointerObj() to create userdata
- Verify scripts can access engine:* methods

**Files:**
- `src/core/Engine.cpp` - Add engine global registration

**Estimated Effort:** 30 minutes

Plans:
- [ ] TBD (run /gsd-plan-phase 6.1 to break down)

---

## Phase 6.2: Standardize Command Routing (HIGH)

**Goal:** Ensure all Lua operations route through command queue for consistent behavior.

**Status**: üîµ Not Started

**Depends on:** Phase 6.1

**Work:**
1. Fix setBPM fallback to use executeCommandImmediate() instead of direct call
2. Add AddModuleCommand to Command.h
3. Refactor createSampler/createSequencer to use AddModuleCommand instead of string commands

**Files:**
- `src/core/lua/videoTracker.i` - Fix Clock::setBPM fallback
- `src/core/Command.h` - Add AddModuleCommand class
- `src/core/lua/LuaHelpers.cpp` - Use AddModuleCommand

**Estimated Effort:** 2 hours

Plans:
- [ ] TBD (run /gsd-plan-phase 6.2 to break down)

---

## Phase 6.3: Add Reactive Callback API (MEDIUM)

**Goal:** Enable scripts to receive state change notifications for live coding workflow.

**Status**: üîµ Not Started

**Depends on:** Phase 6.2

**Context:**
Current architecture is one-way (Engine ‚Üí ScriptManager ‚Üí CodeShell). Scripts cannot receive reactive updates when state changes externally (UI, other shells). This breaks live coding workflow where scripts need to stay synced.

**Work:**
1. Add registerStateChangeCallback() and unregisterStateChangeCallback() to Engine
2. Extend notifyObservers() to invoke Lua callbacks
3. Expose engine:onStateChange(fn) via SWIG in videoTracker.i

**Files:**
- `src/core/Engine.h` - Add callback registration methods
- `src/core/Engine.cpp` - Implement callback infrastructure
- `src/core/lua/videoTracker.i` - Expose onStateChange to Lua

**Estimated Effort:** 3 hours

Plans:
- [ ] TBD (run /gsd-plan-phase 6.3 to break down)

---

Also update the Critical Path section to include:
```
‚Üí Phase 6 (design) ‚Üí Phase 6.1 (engine global) ‚Üí Phase 6.2 (command routing) ‚Üí Phase 6.3 (callbacks)
```
  </action>
  <verify>ROADMAP.md contains Phase 6.1, 6.2, 6.3 sections with goals, dependencies, work items, and file lists</verify>
  <done>ROADMAP.md updated with prioritized implementation sub-phases derived from research</done>
</task>

<task type="auto">
  <name>Task 3: Verify Design Completeness</name>
  <files>.planning/phases/06-research-design-lua-engine-integration/06-DESIGN.md</files>
  <action>
Review DESIGN.md against CONTEXT.md decisions to ensure all are addressed:

1. **Fire-and-forget for initial execution** - Documented in Execution Model Contracts section
2. **Reactive callbacks required for live coding** - Documented with onStateChange API
3. **Full state sync** - Scripts access complete EngineState via callback parameter
4. **All shells display same Engine state** - State observer pattern ensures consistency

Add a "## Decision Verification" section at the end of DESIGN.md:

```markdown
## Decision Verification

| Decision from CONTEXT.md | Addressed In | Notes |
|--------------------------|--------------|-------|
| Fire-and-forget for initial execution | Execution Model Contracts | Engine::eval() pattern |
| Reactive callbacks for live coding | API Contracts | engine:onStateChange(fn) |
| Full state sync | State Sync Architecture | EngineState passed to callbacks |
| All shells display same Engine state | State Sync Architecture | Single source of truth via observer pattern |
```

If any decision is NOT addressed, add the missing design element.
  </action>
  <verify>DESIGN.md contains Decision Verification section mapping all CONTEXT.md decisions to design elements</verify>
  <done>Design document verified complete against all user decisions from Phase 6 discussion</done>
</task>

</tasks>

<verification>
1. `cat .planning/phases/06-research-design-lua-engine-integration/06-DESIGN.md | head -50` - Verify structure
2. `grep -c "Phase 6\." .planning/ROADMAP.md` - Should return 3 (sub-phases 6.1, 6.2, 6.3)
3. `grep "Decision Verification" .planning/phases/06-research-design-lua-engine-integration/06-DESIGN.md` - Verify completeness check
</verification>

<success_criteria>
- 06-DESIGN.md exists with target architecture (150+ lines)
- Execution model contracts defined (fire-and-forget + reactive)
- API contracts documented (onStateChange, removeStateChangeCallback)
- ROADMAP.md contains Phases 6.1, 6.2, 6.3 with dependencies
- All CONTEXT.md decisions verified as addressed in design
</success_criteria>

<output>
After completion, create `.planning/phases/06-research-design-lua-engine-integration/06-01-SUMMARY.md`
</output>
