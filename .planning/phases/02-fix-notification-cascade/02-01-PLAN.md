---
phase: 02-fix-notification-cascade
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/Engine.h
  - src/core/Engine.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Single state notification per parameter cascade (not N notifications)"
    - "UI receives one state update when routing changes multiple parameters"
    - "No redundant snapshot building during parameter cascades"
  artifacts:
    - path: "src/core/Engine.h"
      provides: "Atomic flag for notification suppression"
      min_lines: 10
    - path: "src/core/Engine.cpp"
      provides: "Suppressed notification logic in enqueueStateNotification()"
      min_lines: 30
  key_links:
    - from: "src/core/Engine.cpp"
      to: "ParameterRouter.cpp"
      via: "parameterChangeNotificationCallback triggers enqueueStateNotification"
      pattern: "setParameterChangeNotificationCallback"
---

<objective>
Add notification suppression to eliminate redundant state updates during parameter cascades.

**Purpose**: During parameter routing cascades (one parameter change triggers multiple setParameterValue calls), the current code enqueues N separate notifications. Only one notification is needed. This fix adds a simple atomic flag to suppress duplicates.

**Output**: Atomic flag + suppression logic that ensures single notification per parameter change event.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

# Problem analysis
@src/core/Engine.cpp
  - enqueueStateNotification() at line 1067
  - processNotificationQueue() at line 1088
  - parameterChangeNotificationCallback at line 276

@src/core/ParameterRouter.cpp
  - processRoutingImmediate() at line 469 (triggers cascade)
  - setParameterValue() at line 308 (triggers notification)

# Root cause
During processRoutingImmediate(), each setParameterValue() call triggers the
parameterChangeNotificationCallback, which calls enqueueStateNotification().
This queues N callbacks that all execute when processNotificationQueue() runs.
Only ONE snapshot update + notification is needed.
</context>

<tasks>

<task type="auto">
  <name>Add atomic notificationEnqueued_ flag to Engine.h</name>
  <files>src/core/Engine.h</files>
  <action>
    Add a std::atomic<bool> member variable to the Engine class near the notificationQueue_ declaration.

    Find the notificationQueue_ declaration around line 617:
    ```cpp
    moodycamel::BlockingConcurrentQueue<std::function<void()>> notificationQueue_;
    ```

    Add AFTER it:
    ```cpp
    // Phase 2: Suppress duplicate notifications during parameter cascades
    // Set when enqueueStateNotification() is called, cleared after processing
    std::atomic<bool> notificationEnqueued_{false};
    ```

    Also add the include for <atomic> if not present:
    ```cpp
    #include <atomic>
    ```
  </action>
  <verify>
    grep -n "std::atomic<bool> notificationEnqueued_" src/core/Engine.h
    # Should return: 1 match

    grep -n "#include <atomic>" src/core/Engine.h
    # Should return: 1 match
  </verify>
  <done>
    Atomic flag declaration added to Engine.h, ready for suppression logic
  </done>
</task>

<task type="auto">
  <name>Implement notification suppression in enqueueStateNotification()</name>
  <files>src/core/Engine.cpp</files>
  <action>
    Modify enqueueStateNotification() at line 1067 to check the flag before enqueueing.

    CURRENT code (lines 1067-1086):
    ```cpp
    void Engine::enqueueStateNotification() {
        // Enqueue state notification to be processed on main thread
        // This replaces the stateNeedsNotification_ flag pattern - queue is single source of truth
        
        // Update monitoring: track enqueued notifications (Phase 7.9 Plan 8.2)
        queueMonitorStats_.notificationQueueTotalEnqueued++;
        
        notificationQueue_.enqueue([this]() {
            // Update snapshot before notifying
            // This ensures state snapshot reflects processed commands before observers are notified
            // State version increments in updateStateSnapshot(), ensuring observers see fresh state
            updateStateSnapshot();
            
            // Add memory barrier to ensure snapshot update is visible to observers
            std::atomic_thread_fence(std::memory_order_release);
            
            // Notify observers with current state (state version verified in notifyObserversWithState())
            notifyObserversWithState();
        });
    }
    ```

    NEW code:
    ```cpp
    void Engine::enqueueStateNotification() {
        // Phase 2: Suppress duplicate notifications during parameter cascades
        // Only one notification needed even if multiple parameters change in cascade
        bool expected = false;
        if (!notificationEnqueued_.compare_exchange_strong(expected, true)) {
            // Already enqueued - skip to prevent notification storm
            return;
        }

        // Enqueue state notification to be processed on main thread
        // This replaces the stateNeedsNotification_ flag pattern - queue is single source of truth

        // Update monitoring: track enqueued notifications (Phase 7.9 Plan 8.2)
        queueMonitorStats_.notificationQueueTotalEnqueued++;

        notificationQueue_.enqueue([this]() {
            // Phase 2: Clear flag AFTER processing, before next notification batch
            notificationEnqueued_.store(false);

            // Update snapshot before notifying
            // This ensures state snapshot reflects processed commands before observers are notified
            // State version increments in updateStateSnapshot(), ensuring observers see fresh state
            updateStateSnapshot();

            // Add memory barrier to ensure snapshot update is visible to observers
            std::atomic_thread_fence(std::memory_order_release);

            // Notify observers with current state (state version verified in notifyObserversWithState())
            notifyObserversWithState();
        });
    }
    ```

    The compare_exchange_strong pattern ensures only the first caller sets the flag
    and subsequent callers return early. The flag is cleared after the notification
    callback executes, ready for the next batch.
  </action>
  <verify>
    grep -n "compare_exchange_strong.*notificationEnqueued" src/core/Engine.cpp
    # Should return: 1 match (suppression check)

    grep -n "notificationEnqueued_.store(false)" src/core/Engine.cpp
    # Should return: 1 match (clear after processing)

    grep -n "if (!notificationEnqueued" src/core/Engine.cpp
    # Should return: 1 match (early return)
  </verify>
  <done>
    Notification suppression implemented - cascade produces single notification
  </done>
</task>

</tasks>

<verification>
1. **Compilation check:**
   ```bash
   cd /Users/jaufre/works/of_v0.12.1_osx_release/apps/myApps/videoTracker && make -j4 2>&1 | head -50
   ```
   Should compile without errors.

2. **Flag declaration verified:**
   ```bash
   grep -n "std::atomic<bool> notificationEnqueued_" src/core/Engine.h
   ```
   Should show the atomic flag declaration.

3. **Suppression logic verified:**
   ```bash
   grep -B2 "compare_exchange_strong" src/core/Engine.cpp | head -10
   ```
   Should show the flag check before enqueueing.

4. **Clear logic verified:**
   ```bash
   grep -A2 "notificationQueue_.enqueue" src/core/Engine.cpp | grep -A2 "notificationEnqueued"
   ```
   Should show flag being cleared inside the enqueued lambda.
</verification>

<success_criteria>
- [ ] Atomic flag declared in Engine.h
- [ ] Compare-exchange check in enqueueStateNotification() prevents duplicate enqueues
- [ ] Flag cleared after notification callback executes
- [ ] Compilation succeeds
- [ ] Parameter cascades produce single notification instead of N notifications
</success_criteria>

<output>
After completion, create `.planning/phases/02-fix-notification-cascade/01-01-SUMMARY.md`
</output>
