---
phase: "03"
plan: "01"
type: "execute"
wave: "1"
depends_on: []
files_modified: ["src/core/Engine.h", "src/core/Engine.cpp"]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "buildStateSnapshot() uses lock-free module snapshots"
    - "unsafeStateFlags_ atomic removed from Engine"
    - "UnsafeState enum removed from Engine"
    - "All callers updated to use new guard pattern"
  artifacts:
    - path: "src/core/Engine.h"
      provides: "Engine header without unsafeStateFlags_"
      min_lines: 750
    - path: "src/core/Engine.cpp"
      provides: "Engine implementation with simplified snapshot building"
      min_lines: 1100
  key_links:
    - from: "Engine.h::isExecutingScript()"
      to: "Engine.cpp::eval()"
      via: "notification queue guard pattern"
      pattern: "notificationQueue_"
    - from: "Engine.h::hasUnsafeState()"
      to: "Engine.cpp::buildStateSnapshot()"
      via: "removed - no longer needed"
      pattern: "unsafeStateFlags_"
---

<objective>
Remove unsafeStateFlags_ atomic and simplify lock-free snapshot building.

**Purpose:** The `unsafeStateFlags_` atomic creates timing windows rather than preventing them. The cleaner approach is to defer all state updates to the notification queue on the main thread.

**Output:** 
- Engine.h without unsafeStateFlags_
- Engine.cpp with simplified buildStateSnapshot()
- Updated callers using notification queue guard pattern
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

# Phase context
Phase 1 (DELETE string Lua) → ✅ COMPLETE
Phase 2 (fix cascade) → ✅ COMPLETE
Phase 3 (complete lockfree) ← **THIS PHASE**
Phase 4-5 (cleanup) → pending

# Current state from code analysis
- unsafeStateFlags_ exists at Engine.h:593
- Used by: isExecutingScript(), hasUnsafeState(), isInUnsafeState()
- buildStateSnapshot() uses snapshotMutex_ (line 686)
- notificationQueue_ is the single source of truth for state updates
</context>

<tasks>

<task type="auto">
  <name>Remove unsafeStateFlags_ from Engine.h</name>
  <files>src/core/Engine.h</files>
  <action>
    Delete from Engine.h (line 593):
    ```cpp
    // Unsafe state flags (implementation detail - enum is public for inline method access)
    std::atomic<uint8_t> unsafeStateFlags_{0};
    
    // Helper methods for unsafe state management
    void setUnsafeState(UnsafeState state, bool active);
    bool hasUnsafeState(UnsafeState state) const;
    ```

    Delete from Engine.h (lines 452-462):
    ```cpp
    // Unsafe state detection (consolidated from multiple flags)
    // Purpose: Single source of truth for unsafe state detection
    // Uses bitmask to track multiple unsafe conditions simultaneously
    // Bit 0: Script executing
    // Bit 1: Commands being processed
    // Bit 2+: Reserved for future use
    enum class UnsafeState : uint8_t {
        NONE = 0,
        SCRIPT_EXECUTING = 1 << 0,
        COMMANDS_PROCESSING = 1 << 1
    };
    ```

    Delete from Engine.h (line 465):
    ```cpp
    bool isExecutingScript() const { return hasUnsafeState(UnsafeState::SCRIPT_EXECUTING); }
    ```

    Delete from Engine.h (line 524):
    ```cpp
    return unsafeStateFlags_.load(std::memory_order_acquire) != 0; 
    ```

    Keep: isBuildingSnapshot_ (still used), snapshotMutex_ (still needed for buildStateSnapshot)
  </action>
  <verify>
    grep -n "unsafeStateFlags" src/core/Engine.h && echo "FAIL: unsafeStateFlags still present" || echo "PASS: unsafeStateFlags removed from Engine.h"
    grep -n "UnsafeState" src/core/Engine.h && echo "FAIL: UnsafeState enum still present" || echo "PASS: UnsafeState enum removed from Engine.h"
  </verify>
  <done>
    Engine.h has no unsafeStateFlags_ or UnsafeState enum
  </done>
</task>

<task type="auto">
  <name>Update Engine.cpp to remove unsafeStateFlags_ usage</name>
  <files>src/core/Engine.cpp</files>
  <action>
    1. Delete Engine.cpp lines 25-68 (setUnsafeState/hasUnsafeState implementations)

    2. Replace isInUnsafeState() body at line 519-525:
       OLD:
       ```cpp
       bool isInUnsafeState() const { 
           std::atomic_thread_fence(std::memory_order_acquire);
           return unsafeStateFlags_.load(std::memory_order_acquire) != 0; 
       }
       ```
       NEW:
       ```cpp
       bool isInUnsafeState() const { 
           // Phase 3: Simplified - check notification queue guard instead of atomic flags
           // The notification queue is the single source of truth for state updates
           return notifyingObservers_.load(std::memory_order_acquire);
       }
       ```

    3. Update all setUnsafeState() calls to use notification queue pattern:
       - eval() line 483: `setUnsafeState(UnsafeState::SCRIPT_EXECUTING, true);` → set notifyingObservers_ directly
       - eval() line 516: `setUnsafeState(UnsafeState::SCRIPT_EXECUTING, false);` → set notifyingObservers_ directly
       - All other occurrences

    4. Update hasUnsafeState() checks in onBPMChanged():
       OLD: `hasUnsafeState(UnsafeState::SCRIPT_EXECUTING)`
       NEW: `notifyingObservers_.load()`
  </action>
  <verify>
    grep -n "setUnsafeState\|hasUnsafeState\|unsafeStateFlags\|UnsafeState" src/core/Engine.cpp && echo "FAIL: Still references old API" || echo "PASS: All unsafeStateFlags references removed from Engine.cpp"
  </verify>
  <done>
    Engine.cpp has no references to setUnsafeState, hasUnsafeState, or unsafeStateFlags_
  </done>
</task>

<task type="auto">
  <name>Simplify buildStateSnapshot() mutex usage</name>
  <files>src/core/Engine.cpp</files>
  <action>
    buildStateSnapshot() currently uses snapshotMutex_ to prevent concurrent calls.
    Since all calls now go through notificationQueue_, simplify this:

    1. Keep snapshotMutex_ (still needed for preventing concurrent snapshot building)
    2. But update comments to explain why it's still needed:
       - Multiple threads could theoretically call getStateSnapshot() concurrently
       - snapshotMutex_ prevents the expensive buildStateSnapshot() from running multiple times
       - This is different from the old unsafeStateFlags_ pattern

    3. Update buildStateSnapshot() comments (around line 1152) to reflect Phase 3 simplification:
       - Remove references to unsafe state detection
       - Document that notificationQueue_ is the single source of truth
  </action>
  <verify>
    grep -n "buildStateSnapshot" src/core/Engine.cpp | head -5
    grep -n "snapshotMutex_" src/core/Engine.cpp | head -3
  </verify>
  <done>
    buildStateSnapshot() simplified, snapshotMutex_ kept with updated comments
  </done>
</task>

</tasks>

<verification>
1. grep confirms no unsafeStateFlags_ in Engine.h or Engine.cpp
2. grep confirms no UnsafeState enum in Engine.h
3. grep confirms no setUnsafeState/hasUnsafeState calls in Engine.cpp
4. Code compiles (if build system available)
5. isInUnsafeState() now uses notifyingObservers_ pattern
</verification>

<success_criteria>
- [ ] Engine.h has no unsafeStateFlags_ atomic
- [ ] Engine.h has no UnsafeState enum
- [ ] Engine.cpp has no setUnsafeState/hasUnsafeState implementations
- [ ] Engine.cpp has no setUnsafeState/hasUnsafeState calls
- [ ] isInUnsafeState() uses notifyingObservers_ pattern
- [ ] buildStateSnapshot() simplified with updated comments
</success_criteria>

<output>
After completion, create `.planning/phases/03-complete-lock-free-migration/03-01-SUMMARY.md`
</output>
