#include "InputRouter.h"
#include "Clock.h"
#include "TrackerSequencer.h"
#include "TrackerSequencerGUI.h"
#include "gui/ViewManager.h"
#include "MediaPool.h"
#include "MediaPoolGUI.h"
#include "ofxImGui.h"
#include "ofLog.h"

InputRouter::InputRouter() {
}

void InputRouter::setup(
    Clock* clock_,
    TrackerSequencer* tracker_,
    TrackerSequencerGUI* trackerGUI_,
    ViewManager* viewManager_,
    MediaPool* mediaPool_,
    MediaPoolGUI* mediaPoolGUI_
) {
    clock = clock_;
    tracker = tracker_;
    trackerGUI = trackerGUI_;
    viewManager = viewManager_;
    mediaPool = mediaPool_;
    mediaPoolGUI = mediaPoolGUI_;

    ofLogNotice("InputRouter") << "Setup complete";
}

void InputRouter::setPlayState(bool* isPlaying_) {
    isPlaying = isPlaying_;
}

void InputRouter::setCurrentStep(int* currentStep_) {
    currentStep = currentStep_;
}

void InputRouter::setLastTriggeredStep(int* lastTriggeredStep_) {
    lastTriggeredStep = lastTriggeredStep_;
}

void InputRouter::setShowGUI(bool* showGUI_) {
    showGUI = showGUI_;
}

bool InputRouter::handleKeyPress(ofKeyEventArgs& keyEvent) {
    int key = keyEvent.key;
    
    // LOG: Entry point for all key presses
    ofLogNotice("InputRouter") << "=== KEY PRESS: key=" << key 
        << " ('" << (char)key << "')";
    
    // Priority 1: Panel navigation (Ctrl+Tab / Ctrl+Shift+Tab) - check BEFORE ImGui processes
    // IMPORTANT: Use OF_KEY_CONTROL (not COMMAND) for Ctrl key
    // On Mac: OF_KEY_CONTROL = Control key, OF_KEY_COMMAND = Command key (âŒ˜)
    if (key == OF_KEY_TAB) {
        bool ctrlPressed = keyEvent.hasModifier(OF_KEY_CONTROL);
        if (ctrlPressed) {
            if (handlePanelNavigation(keyEvent)) {
                return true;
            }
        }
        // Regular Tab (without Ctrl) - let ImGui handle it for native navigation
        // Don't return false here, let it fall through to ImGui processing
    }
    
    updateImGuiCaptureState();
    
    // Priority 2: Spacebar - ALWAYS works (global transport control)
    // Handle spacebar BEFORE other checks to ensure it always works
    if (key == ' ') {
        // Alt+Spacebar: Trigger current edit step
        if (keyEvent.hasModifier(OF_KEY_ALT)) {
            if (tracker) {
                int editStep = tracker->getEditStep();
                if (editStep >= 0) {
                    tracker->triggerStep(editStep);
                    logKeyPress(key, "Alt+Spacebar: Trigger step");
                    return true;
                }
            }
        }
        // Regular Spacebar: Play/Stop (always works, even when ImGui has focus)
        if (handleGlobalShortcuts(key)) {
            return true;
        }
    }
    
    // Priority 3: Other global shortcuts - only when ImGui isn't busy
    if (!ImGui::IsAnyItemActive() && !ImGui::GetIO().WantCaptureMouse) {
        if (handleGlobalShortcuts(key)) {
            return true;
        }
    }
    
    // Priority 4: Tracker input - only when in tracker panel
    // CRITICAL: Route tracker input BEFORE ImGui can consume it, even if ImGui wants keyboard
    // This ensures Enter and numeric keys work when cells are focused
    // 
    // IMPORTANT: We check multiple conditions to determine if we're in the tracker panel:
    // 1. Panel index == 2 (official tracker panel)
    // 2. OR a tracker cell is focused (editStep/editColumn are valid)
    // This handles both docked windows and regular panel navigation
    int currentPanelIndex = viewManager ? viewManager->getCurrentPanelIndex() : -1;
    bool trackerCellFocused = false;
    bool onHeaderRow = false;
    bool isParentWidgetFocused = false;
    
    // Check if we're actually in tracker panel first
    bool inTrackerPanelByIndex = (tracker && viewManager && currentPanelIndex == 2);
    
    if (tracker && inTrackerPanelByIndex) {
        int editStep = tracker->getEditStep();
        int editColumn = tracker->getEditColumn();
        // Check if a valid cell is focused (indicates user is interacting with tracker)
        trackerCellFocused = (editStep >= 0 && editStep < tracker->getNumSteps() && editColumn >= 0);
        // Check if on header row (editStep == -1 means focus is on header row, not a data cell)
        // But only if we're actually in tracker panel
        onHeaderRow = (editStep == -1 && !tracker->getIsEditingCell());
        
        // Check if parent widget is focused (from GUI)
        if (trackerGUI) {
            isParentWidgetFocused = trackerGUI->getIsParentWidgetFocused();
        }
    }
    
    ofLogNotice("InputRouter") << "  Panel check: tracker=" << (tracker ? "YES" : "NO")
        << ", viewManager=" << (viewManager ? "YES" : "NO")
        << ", currentPanelIndex=" << currentPanelIndex
        << ", trackerCellFocused=" << (trackerCellFocused ? "YES" : "NO")
        << ", onHeaderRow=" << (onHeaderRow ? "YES" : "NO")
        << ", isParentWidgetFocused=" << (isParentWidgetFocused ? "YES" : "NO");
    
    // Use either panel index check OR tracker cell focused check
    // Only include onHeaderRow if we're actually in tracker panel
    bool inTrackerPanel = inTrackerPanelByIndex || trackerCellFocused;
    
    if (tracker && inTrackerPanel) {
        // Check for modifier keys properly
        bool ctrlPressed = keyEvent.hasModifier(OF_KEY_CONTROL);
        bool shiftPressed = keyEvent.hasModifier(OF_KEY_SHIFT);
        bool cmdPressed = keyEvent.hasModifier(OF_KEY_COMMAND);
        
        // CRITICAL: In edit mode, block arrow keys from ImGui navigation
        // This prevents ImGui from moving focus when arrow keys adjust values
        bool inEditMode = tracker->getIsEditingCell();
        
        // CRITICAL: Route Enter and numeric keys even when ImGui wants keyboard
        // This ensures these keys work when cells are focused
        // CRITICAL: In edit mode, ALWAYS route arrow keys to tracker BEFORE ImGui can process them
        // This prevents ImGui from using arrow keys for navigation and changing focus
        if (inEditMode && (key == OF_KEY_UP || key == OF_KEY_DOWN || 
                           key == OF_KEY_LEFT || key == OF_KEY_RIGHT)) {
            // Arrow keys in edit mode: always route to tracker (adjust values)
            // Don't let ImGui use them for navigation - this locks focus to the editing cell
            // Sync state first to ensure tracker knows current cell
            syncEditStateFromImGuiFocus();
            if (tracker->handleKeyPress(key, ctrlPressed, shiftPressed)) {
                ofLogNotice("InputRouter") << "  Arrow key in edit mode: HANDLED by tracker (blocked from ImGui)";
                logKeyPress(key, "Tracker: Arrow key in edit mode (blocked from ImGui)");
                return true; // Consume the key to prevent ImGui from processing
            }
        }
        
        // Don't route UP key when on parent widget - let ImGui handle normal navigation
        if (isParentWidgetFocused && key == OF_KEY_UP && !inEditMode) {
            ofLogNotice("InputRouter") << "  UP key on parent widget: letting ImGui handle (not routing to tracker)";
            return false; // Let ImGui process the key normally
        }
        
        // When on header row, set flag to move focus to parent widget using ImGui's navigation API
        // We don't consume the key - let it fall through to ImGui, but also explicitly move focus
        if (onHeaderRow && key == OF_KEY_UP && !inEditMode) {
            ofLogNotice("InputRouter") << "  UP key on header row: requesting focus move to parent widget";
            // Set flag for GUI to move focus to parent widget in next frame
            tracker->requestFocusMoveToParentWidget();
            // Clear cell focus so ImGui sees correct state
            tracker->clearCellFocus();
            // Don't consume the key - let ImGui handle it, but we've set the flag for explicit focus move
            return false; // Let ImGui process the key
        }
        
        // Enter key: Check for Ctrl+Enter (go up a level) vs Shift+Enter (exit grid)
        if (key == OF_KEY_RETURN) {
            // Ctrl+Enter: Go up a level (focus parent container)
            if (ctrlPressed && !shiftPressed) {
                // Check if we're inside a container (cell focused or on header row)
                if (trackerCellFocused || onHeaderRow) {
                    ofLogNotice("InputRouter") << "  Ctrl+Enter: requesting focus move to parent container";
                    tracker->requestFocusMoveToParentWidget();
                    tracker->clearCellFocus();
                    return true; // Consume the key
                }
            }
            
            // When on header row, don't route Enter to tracker - let ImGui handle it
            if (onHeaderRow && !ctrlPressed && !shiftPressed) {
                ofLogNotice("InputRouter") << "  Enter key on header row: letting ImGui handle (not routing to tracker)";
                return false; // Let ImGui process the key
            }
            
            ofLogNotice("InputRouter") << "  Enter key detected in tracker panel";
            // Ctrl+Enter is already handled above, so this is for other Enter cases
            if (ctrlPressed) {
                // This shouldn't happen (already handled above), but keep for safety
                ofLogNotice("InputRouter") << "  Ctrl+Enter: Going up a level (fallback)";
                if (tracker->handleKeyPress(key, true, false)) {
                    logKeyPress(key, "Tracker: Ctrl+Enter (go up level)");
                    return true;
                }
            } else if (shiftPressed) {
                // Shift+Enter: Exit grid navigation (clear cell selection)
                ofLogNotice("InputRouter") << "  Shift+Enter: Exiting grid";
                if (tracker->handleKeyPress(key, false, true)) {
                    logKeyPress(key, "Tracker: Shift+Enter (exit grid)");
                    return true;
                }
            } else {
                // Regular Enter: Always try to handle it if we're in tracker panel
                // CRITICAL: Sync editStep/editColumn from ImGui focus BEFORE calling handleKeyPress
                // This ensures the tracker knows which cell is focused even if GUI sync hasn't happened yet
                ofLogNotice("InputRouter") << "  Regular Enter: Syncing edit state from ImGui focus";
                syncEditStateFromImGuiFocus();
                
                // DEBUG: Log frame count and state before handling
                int currentFrame = ImGui::GetFrameCount();
                int editStep = tracker->getEditStep();
                int editColumn = tracker->getEditColumn();
                bool isEditing = tracker->getIsEditingCell();
                ofLogNotice("InputRouter") << "  Enter key at frame=" << currentFrame
                    << ", editStep=" << editStep << ", editColumn=" << editColumn
                    << ", isEditingCell=" << (isEditing ? "YES" : "NO");
                
                bool handled = tracker->handleKeyPress(key, false, false);
                if (handled) {
                    if (currentStep) {
                        *currentStep = tracker->getCurrentStep();
                    }
                    ofLogNotice("InputRouter") << "  Enter key HANDLED by tracker";
                    logKeyPress(key, "Tracker: Enter (handled)");
                    return true;
                } else {
                    // Enter was pressed but tracker didn't handle it
                    // This might mean editStep/editColumn aren't set yet
                    ofLogWarning("InputRouter") << "  Enter key NOT handled by tracker. editStep=" << editStep 
                        << ", editColumn=" << editColumn << ", isEditingCell=" << (isEditing ? "YES" : "NO");
                    
                    // Still consume it to prevent ImGui from activating buttons
                    // The tracker should handle it next frame once GUI sync happens
                    return true; // Consume to prevent ImGui from processing
                }
            }
        }
        
        // Route numeric keys and edit mode keys to tracker
        // This allows typing numbers to auto-enter edit mode, and handles edit mode input
        ofLogNotice("InputRouter") << "  Checking numeric keys: inEditMode=" << (inEditMode ? "YES" : "NO");
        if (inEditMode) {
            // In edit mode: Arrow keys already handled above, now handle numeric input
            // Numeric keys (including numpad - openFrameworks converts numpad to regular '0'-'9')
            // Also handle decimal point, minus, backspace, delete for numeric input
            if ((key >= '0' && key <= '9') ||
                key == '.' || key == '-' || key == OF_KEY_BACKSPACE || key == OF_KEY_DEL) {
                ofLogNotice("InputRouter") << "  Numeric key '" << (char)key << "' in edit mode - routing to tracker";
                if (tracker->handleKeyPress(key, ctrlPressed, shiftPressed)) {
                    ofLogNotice("InputRouter") << "  Numeric key HANDLED by tracker (in edit mode)";
                    logKeyPress(key, "Tracker: Numeric key in edit mode");
                    return true;
                } else {
                    ofLogWarning("InputRouter") << "  Numeric key NOT handled by tracker (in edit mode)";
                }
            }
        } else {
            // Not in edit mode: Route numeric keys to tracker for direct typing
            // This allows typing numbers to auto-enter edit mode
            // CRITICAL: Route these even if ImGui wants keyboard, because we need to enter edit mode
            if ((key >= '0' && key <= '9') || key == '.' || key == '-') {
                ofLogNotice("InputRouter") << "  Numeric key '" << (char)key << "' detected (not in edit mode)";
                // CRITICAL: Sync editStep/editColumn from ImGui focus BEFORE calling handleKeyPress
                // This ensures the tracker knows which cell is focused even if GUI sync hasn't happened yet
                ofLogNotice("InputRouter") << "  Syncing edit state from ImGui focus";
                syncEditStateFromImGuiFocus();
                
                // DEBUG: Log frame count and state before handling
                int currentFrame = ImGui::GetFrameCount();
                int editStep = tracker->getEditStep();
                int editColumn = tracker->getEditColumn();
                ofLogNotice("InputRouter") << "  Numeric key '" << (char)key << "' at frame=" 
                    << currentFrame << ", editStep=" << editStep << ", editColumn=" << editColumn;
                
                bool handled = tracker->handleKeyPress(key, ctrlPressed, shiftPressed);
                
                if (handled) {
                    ofLogNotice("InputRouter") << "  Numeric key HANDLED by tracker (entered edit mode)";
                    logKeyPress(key, "Tracker: Numeric key (auto-enter edit mode)");
                    return true;
                } else {
                    // Numeric key not handled - might be because no cell is focused
                    // The tracker should have defaulted to first cell if editStep/editColumn weren't set
                    ofLogWarning("InputRouter") << "  Numeric key '" << (char)key << "' NOT handled by tracker. "
                        << "editStep=" << editStep << ", editColumn=" << editColumn;
                    
                    // Still consume it to prevent ImGui from processing
                    // The tracker should handle it next frame once GUI sync happens
                    return true; // Consume to prevent ImGui from processing
                }
            }
        }
        
        ofLogNotice("InputRouter") << "  Key not matched for tracker input, checking other handlers...";
        
        // Handle other tracker input with proper modifiers
        if (handleTrackerInput(keyEvent)) {
            ofLogNotice("InputRouter") << "  Key handled by handleTrackerInput";
            return true;
        }
        
        ofLogNotice("InputRouter") << "  Key not handled in tracker panel section";
    }
    
    // Handle MediaPool container navigation (Ctrl+Enter to go up a level)
    // Check if we're in MediaPool panel
    bool inMediaPoolPanel = (mediaPool && viewManager && currentPanelIndex == 3);
    if (inMediaPoolPanel && key == OF_KEY_RETURN) {
        bool ctrlPressed = keyEvent.hasModifier(OF_KEY_CONTROL);
        bool shiftPressed = keyEvent.hasModifier(OF_KEY_SHIFT);
        
        // Ctrl+Enter: Go up a level (focus parent container)
        if (ctrlPressed && !shiftPressed) {
            // Check if we're inside the media list (a Selectable is focused)
            // We can detect this by checking if parent widget is NOT focused
            // (if parent widget is focused, we're already at parent level)
            if (mediaPoolGUI && !mediaPoolGUI->getIsParentWidgetFocused()) {
                ofLogNotice("InputRouter") << "  Ctrl+Enter in MediaPool: requesting focus move to parent container";
                mediaPoolGUI->requestFocusMoveToParent();
                return true; // Consume the key
            }
        }
    }
    
    if (!inTrackerPanel) {
        ofLogNotice("InputRouter") << "  NOT in tracker panel (currentPanelIndex=" << currentPanelIndex 
            << ", trackerCellFocused=" << (trackerCellFocused ? "YES" : "NO") << ")";
    }
    
    return false;
}

bool InputRouter::handleGlobalShortcuts(int key) {
    // Global shortcuts work even when ImGui has focus

    switch (key) {
        case ' ':  // SPACE - Play/Stop (always works, even when ImGui has focus)
            if (clock) {
                bool currentlyPlaying = (isPlaying && *isPlaying);
                if (currentlyPlaying) {
                    clock->stop();
                    if (isPlaying) *isPlaying = false;
                    logKeyPress(key, "Global: Stop");
                } else {
                    clock->start();
                    if (isPlaying) *isPlaying = true;
                    logKeyPress(key, "Global: Start");
                }
                return true;  // Always return true to prevent ImGui from processing spacebar
            }
            break;

        case 'r':
        case 'R':  // R - Reset
            if (clock) {
                clock->reset();
                if (tracker) tracker->reset();
                if (currentStep) *currentStep = 0;
                if (lastTriggeredStep) *lastTriggeredStep = 0;
                logKeyPress(key, "Global: Reset");
                return true;
            }
            break;

        case 'g':
        case 'G':  // G - Toggle GUI
            if (showGUI) {
                *showGUI = !*showGUI;
                logKeyPress(key, "Global: Toggle GUI");
                return true;
            }
            break;

        case 'n':
        case 'N':  // N - Next media
            if (mediaPool) {
                mediaPool->nextPlayer();
                logKeyPress(key, "Global: Next media");
                return true;
            }
            break;

        case 'm':
        case 'M':  // M - Previous media
            if (mediaPool) {
                mediaPool->previousPlayer();
                logKeyPress(key, "Global: Previous media");
                return true;
            }
            break;

        case 'S':  // S - Save pattern (capital S to distinguish from speed)
            if (tracker) {
                tracker->saveState("pattern.json");
                logKeyPress(key, "Global: Save pattern");
                return true;
            }
            break;
    }

    return false;
}

bool InputRouter::handlePanelNavigation(ofKeyEventArgs& keyEvent) {
    if (!viewManager) return false;
    
    int key = keyEvent.key;
    if (key == OF_KEY_TAB) {
        bool shiftPressed = keyEvent.hasModifier(OF_KEY_SHIFT);
        if (shiftPressed) {
            viewManager->previousPanel();
        } else {
            viewManager->nextPanel();
        }
        logKeyPress(key, "Navigation: Ctrl+Tab");
        return true;
    }
    return false;
}

bool InputRouter::handleTrackerInput(ofKeyEventArgs& keyEvent) {
    if (!tracker) return false;
    
    int key = keyEvent.key;
    bool ctrlPressed = keyEvent.hasModifier(OF_KEY_CONTROL);
    bool shiftPressed = keyEvent.hasModifier(OF_KEY_SHIFT);
    
    // Delegate to TrackerSequencer with proper modifier flags
    if (tracker->handleKeyPress(key, ctrlPressed, shiftPressed)) {
        if (currentStep) {
            *currentStep = tracker->getCurrentStep();
        }
        logKeyPress(key, "Tracker input");
        return true;
    }
    return false;
}

void InputRouter::updateImGuiCaptureState() {
    ImGuiIO& io = ImGui::GetIO();
    imGuiCapturingKeyboard = io.WantCaptureKeyboard;
}

bool InputRouter::isImGuiCapturingKeyboard() const {
    return imGuiCapturingKeyboard;
}

bool InputRouter::isSequencerInEditMode() const {
    return tracker ? tracker->getIsEditingCell() : false;
}

void InputRouter::syncEditStateFromImGuiFocus() {
    // Sync edit state from ImGui focus before processing keys
    // This ensures editStep/editColumn are set even if GUI draw sync hasn't happened yet
    if (tracker) {
        TrackerSequencerGUI::syncEditStateFromImGuiFocus(*tracker);
    }
}

void InputRouter::logKeyPress(int key, const char* context) {
    ofLogVerbose("InputRouter") << context << " - Key: " << key;
}

#pragma once
#include "ofMain.h"

class Clock;
class TrackerSequencer;
class TrackerSequencerGUI;
class ViewManager;
class MediaPool;
class MediaPoolGUI;

class InputRouter {
public:
    InputRouter();
    ~InputRouter() = default;

    // Setup with references to controllable systems
    void setup(
        Clock* clock,
        TrackerSequencer* tracker,
        TrackerSequencerGUI* trackerGUI,
        ViewManager* viewManager,
        MediaPool* mediaPool,
        MediaPoolGUI* mediaPoolGUI
    );

    // Callbacks for state that needs to be updated
    void setPlayState(bool* isPlaying);
    void setCurrentStep(int* currentStep);
    void setLastTriggeredStep(int* lastTriggeredStep);
    void setShowGUI(bool* showGUI);

    // Main keyboard handler - called from ofApp::keyPressed()
    // Returns true if the input was consumed (don't pass to others)
    bool handleKeyPress(ofKeyEventArgs& keyEvent);

    // System state flags
    bool isImGuiCapturingKeyboard() const;
    bool isSequencerInEditMode() const;

private:
    // System references
    Clock* clock = nullptr;
    TrackerSequencer* tracker = nullptr;
    TrackerSequencerGUI* trackerGUI = nullptr;
    ViewManager* viewManager = nullptr;
    MediaPool* mediaPool = nullptr;
    MediaPoolGUI* mediaPoolGUI = nullptr;

    // State references (optional - can be nullptr)
    bool* isPlaying = nullptr;
    int* currentStep = nullptr;
    int* lastTriggeredStep = nullptr;
    bool* showGUI = nullptr;

    // Keyboard capture state
    bool imGuiCapturingKeyboard = false;

    // Handler methods for different input categories
    bool handleGlobalShortcuts(int key);
    bool handlePanelNavigation(ofKeyEventArgs& keyEvent);
    bool handleTrackerInput(ofKeyEventArgs& keyEvent);

    // Helper to check ImGui capture state
    void updateImGuiCaptureState();
    
    // Helper to sync edit state from ImGui focus (if a cell is focused)
    void syncEditStateFromImGuiFocus();

    // Logging helper
    void logKeyPress(int key, const char* context);
};

