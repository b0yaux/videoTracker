//
//  Clock.cpp
//
//  Audio-rate clock - sample-accurate timing without PPQN
//

#include "Clock.h"
#include "ofxImGui.h"

//--------------------------------------------------------------
Clock::Clock() 
    : playing(false)
    , currentBpm(120.0f)
    , targetBpm(120.0f)
    , beatPulse(0.0f)
    , lastBeatTime(0.0f)
    , beatInterval(0.0f)
    , sampleAccumulator(0.0)
    , beatAccumulator(0.0)
    , samplesPerStep(0.0f)
    , samplesPerBeat(0.0f)
    , stepsPerBeat(4) {
}

//--------------------------------------------------------------
Clock::~Clock() {
    stop();
}

//--------------------------------------------------------------
void Clock::setup() {
    // Audio-rate clock doesn't need to connect to sound system
    // It will be called directly from ofApp::audioOut()
    
    ofLogNotice("Clock") << "Audio-rate clock setup complete - BPM: " << currentBpm.load();
}

//--------------------------------------------------------------
void Clock::setBPM(float bpm) {
    // Silent clamping using config
    float clampedBpm = ofClamp(bpm, config.minBPM, config.maxBPM);
    if (clampedBpm > 0 && clampedBpm != targetBpm.load()) {
        targetBpm.store(clampedBpm);
        onBPMChanged();
    }
}

//--------------------------------------------------------------
float Clock::getBPM() const {
    return currentBpm.load();
}

//--------------------------------------------------------------
void Clock::start() {
    if (!playing) {
        playing = true;
        // Calculate samples per beat for immediate first beat
        float current = currentBpm.load();
        float beatsPerSecond = current / 60.0f;
        samplesPerBeat = sampleRate / beatsPerSecond; // Use current sample rate
        beatAccumulator = samplesPerBeat; // Trigger first beat immediately
        ofLogNotice("Clock") << "Audio-rate clock started at BPM: " << currentBpm.load() << " (SR: " << sampleRate << ")";
        
        // Notify transport listeners
        for (auto& listener : transportListeners) {
            listener(true);
        }
    }
}

//--------------------------------------------------------------
void Clock::stop() {
    if (playing) {
        playing = false;
        beatPulse = 0.0f; // Reset visualizer
        sampleAccumulator = 0.0; // Reset sample timing
        beatAccumulator = 0.0; // Reset beat timing
        ofLogNotice("Clock") << "Audio-rate clock stopped";
        
        // Notify transport listeners
        for (auto& listener : transportListeners) {
            listener(false);
        }
    }
}

//--------------------------------------------------------------
void Clock::pause() {
    if (playing) {
        playing = false;
        ofLogNotice("Clock") << "Audio-rate clock paused";
        
        // Notify transport listeners
        for (auto& listener : transportListeners) {
            listener(false);
        }
    }
}

//--------------------------------------------------------------
void Clock::reset() {
    playing = false;
    beatPulse = 0.0f; // Reset visualizer
    sampleAccumulator = 0.0; // Reset sample timing
    beatAccumulator = 0.0; // Reset beat timing
    ofLogNotice("Clock") << "Audio-rate clock reset";
}

//--------------------------------------------------------------
void Clock::setStepsPerBeat(int spb) {
    // Silent clamping using config
    int clampedSpb = ofClamp(spb, config.minStepsPerBeat, config.maxStepsPerBeat);
    stepsPerBeat = clampedSpb;
    ofLogNotice("Clock") << "Steps per beat set to: " << stepsPerBeat;
}

//--------------------------------------------------------------
int Clock::getStepsPerBeat() const {
    return stepsPerBeat;
}

//--------------------------------------------------------------
bool Clock::isPlaying() const {
    return playing;
}

//--------------------------------------------------------------
void Clock::addAudioListener(std::function<void(ofSoundBuffer&)> listener) {
    audioListeners.push_back(listener);
}

//--------------------------------------------------------------
void Clock::removeAudioListener() {
    audioListeners.clear();
}

//--------------------------------------------------------------
void Clock::addTransportListener(TransportCallback listener) {
    transportListeners.push_back(listener);
    ofLogNotice("Clock") << "Transport listener added (total: " << transportListeners.size() << ")";
}

//--------------------------------------------------------------
void Clock::removeTransportListener() {
    transportListeners.clear();
    ofLogNotice("Clock") << "All transport listeners removed";
}

//--------------------------------------------------------------
void Clock::audioOut(ofSoundBuffer& buffer) {
    if (!playing) return;
    
    // Auto-detect sample rate from buffer (only when it changes)
    float bufferSampleRate = buffer.getSampleRate();
    if (abs(bufferSampleRate - sampleRate) > 1.0f) {
        sampleRate = bufferSampleRate;
        // NO LOGGING IN AUDIO THREAD - removed ofLogNotice
        // Recalculate timing when sample rate changes
        float current = currentBpm.load();
        float beatsPerSecond = current / 60.0f;
        samplesPerBeat = sampleRate / beatsPerSecond;
        samplesPerStep = samplesPerBeat / stepsPerBeat;
    }
    
    // Smooth BPM changes for audio-rate transitions using config
    float current = currentBpm.load();
    float target = targetBpm.load();
    if (abs(current - target) > 0.1f) {
        current = current * (1.0f - config.bpmSmoothFactor) + target * config.bpmSmoothFactor;
        currentBpm.store(current);
    }
    
    // Update samples per beat and step for sample-accurate timing
    float beatsPerSecond = current / 60.0f;
    samplesPerBeat = sampleRate / beatsPerSecond;
    samplesPerStep = samplesPerBeat / stepsPerBeat;
    
    // Sample-accurate beat and step detection
    for (int i = 0; i < buffer.getNumFrames(); i++) {
        sampleAccumulator += 1.0;
        beatAccumulator += 1.0;
        
        // Check for step event (for TrackerSequencer)
        if (sampleAccumulator >= samplesPerStep) {
            sampleAccumulator -= samplesPerStep;
            stepCounter++;
            
            TimeEvent stepEvent;
            stepEvent.type = TimeEventType::STEP;
            stepEvent.stepNumber = stepCounter;
            stepEvent.beatNumber = beatCounter;
            stepEvent.timestamp = ofGetElapsedTimef();
            stepEvent.bpm = current;
            
            ofNotifyEvent(timeEvent, stepEvent);
        }
        
        // Check for beat event (for visualizer) - independent timing
        if (beatAccumulator >= samplesPerBeat) {
            beatAccumulator -= samplesPerBeat;
            beatCounter++;
            
            TimeEvent beatEvent;
            beatEvent.type = TimeEventType::BEAT;
            beatEvent.stepNumber = -1;  // Not applicable for beat events
            beatEvent.beatNumber = beatCounter;
            beatEvent.timestamp = ofGetElapsedTimef();
            beatEvent.bpm = current;
            
            ofNotifyEvent(timeEvent, beatEvent);
            beatPulse = 1.0f;
        }
    }
    
    // Fade the pulse over time using config
    beatPulse *= config.pulseFadeFactor;
    if (beatPulse < config.pulseThreshold) beatPulse = 0.0f;
    
    // Notify all audio listeners
    for (auto& listener : audioListeners) {
        listener(buffer);
    }
}


//--------------------------------------------------------------
void Clock::setConfig(const ClockConfig& cfg) {
    config = cfg;
    ofLogNotice("Clock") << "Configuration updated";
}

//--------------------------------------------------------------
void Clock::setSampleRate(float rate) {
    if (rate > 0 && rate != sampleRate) {
        sampleRate = rate;
        ofLogNotice("Clock") << "Sample rate set to: " << sampleRate;
        
        // Recalculate timing if playing
        if (playing) {
            float current = currentBpm.load();
            float beatsPerSecond = current / 60.0f;
            samplesPerBeat = sampleRate / beatsPerSecond;
            samplesPerStep = samplesPerBeat / stepsPerBeat;
        }
    }
}

//--------------------------------------------------------------
float Clock::getBeatPulse() const {
    return beatPulse;
}

//--------------------------------------------------------------
float Clock::getMinBPM() const {
    return config.minBPM;
}

//--------------------------------------------------------------
float Clock::getMaxBPM() const {
    return config.maxBPM;
}

//--------------------------------------------------------------
float Clock::getSampleRate() const {
    return sampleRate;
}

//--------------------------------------------------------------
void Clock::onBPMChanged() {
    // This method can be extended to notify other components
    // about BPM changes if needed in the future
}//
//  Clock.h
//
//  Audio-rate clock - sample-accurate timing without PPQN
//

#pragma once

#include "ofMain.h"
#include "ofxSoundObjects.h"

// Configuration structure for Clock
struct ClockConfig {
    float minBPM = 20.0f;
    float maxBPM = 480.0f;
    int minStepsPerBeat = 1;
    int maxStepsPerBeat = 96;
    float bpmSmoothFactor = 0.05f;
    float pulseFadeFactor = 0.75f;
    float pulseThreshold = 0.05f;
};

// Unified time event structure (replaces BeatEventData and StepEventData)
enum class TimeEventType {
    BEAT,   // Beat event (once per beat)
    STEP    // Step event (multiple per beat)
};

struct TimeEvent {
    TimeEventType type;      // BEAT or STEP
    int beatNumber;          // Beat number (valid for both types)
    int stepNumber;          // Step number (valid only for STEP type, -1 for BEAT)
    double timestamp;        // Timestamp when event occurred
    float bpm;              // Current BPM at time of event
};

class Clock : public ofxSoundOutput {
public:
    Clock();
    ~Clock();
    
    // Setup and configuration
    void setup();
    void setBPM(float bpm);
    float getBPM() const;
    
    // Transport control
    // NOTE: Clock is the SINGLE SOURCE OF TRUTH for global transport state.
    // All other components (TrackerSequencer, MediaPool, ofApp) should query
    // clock.isPlaying() rather than maintaining their own transport state.
    // This follows the BespokeSynth/SunVox pattern: master transport with derived local states.
    void start();
    void stop();
    void pause();
    void reset();
    bool isPlaying() const;  // Master transport state - single source of truth
    
    // Steps per beat control
    void setStepsPerBeat(int spb);
    int getStepsPerBeat() const;
    
    // Audio-rate listener system
    void addAudioListener(std::function<void(ofSoundBuffer&)> listener);
    void removeAudioListener();
    
    // Transport listener system for play/stop events
    typedef std::function<void(bool isPlaying)> TransportCallback;
    void addTransportListener(TransportCallback listener);
    void removeTransportListener();
    
    // Unified time event system for sample-accurate timing
    ofEvent<TimeEvent> timeEvent;  // Fires for both beats and steps (use type field to distinguish)
    
    // Configuration
    void setConfig(const ClockConfig& cfg);
    void setSampleRate(float rate);
    
    // Accessors for GUI
    float getBeatPulse() const;
    float getMinBPM() const;
    float getMaxBPM() const;
    float getSampleRate() const;
    
    // Audio callback (inherited from ofxSoundOutput)
    void audioOut(ofSoundBuffer& buffer) override;
    
private:
    // State
    // Master transport state - single source of truth for global playback
    // All transport control goes through Clock (start/stop/pause/reset)
    // Other components subscribe via addTransportListener() to be notified of changes
    bool playing;
    std::atomic<float> currentBpm;
    std::atomic<float> targetBpm;
    
    // Configuration
    ClockConfig config;
    float sampleRate = 44100.0f;
    int beatCounter = 0;
    int stepCounter = 0;
    
    // BPM visualizer
    float beatPulse;
    float lastBeatTime;
    float beatInterval;
    
    // Sample-accurate timing
    double sampleAccumulator;
    double beatAccumulator;
    float samplesPerStep;
    float samplesPerBeat;
    int stepsPerBeat;
    
    // Audio listeners
    std::vector<std::function<void(ofSoundBuffer&)>> audioListeners;
    
    // Transport listeners for play/stop events
    std::vector<TransportCallback> transportListeners;
    
    // Internal methods
    void onBPMChanged();
};
#include "ClockGUI.h"
#include "ofxImGui.h"

ClockGUI::ClockGUI() {
}

void ClockGUI::draw(Clock& clock) {
    // Sync BPM slider with current BPM when not being dragged
    if (!isDragging) {
        bpmSlider = clock.getBPM();
    }
    
    // BPM control - apply changes immediately to prevent stopping issues
    if (ImGui::SliderFloat("BPM", &bpmSlider, clock.getMinBPM(), clock.getMaxBPM())) {
        isDragging = true;
        
        // Apply BPM changes immediately when slider moves
        if (abs(bpmSlider - clock.getBPM()) > 0.1f) { // Small threshold to avoid noise
            ofLogNotice("ClockGUI") << "BPM slider changed from " << clock.getBPM() << " to " << bpmSlider;
            clock.setBPM(bpmSlider);
            
            if (clock.isPlaying()) {
                ofLogNotice("ClockGUI") << "BPM changed during playback to: " << clock.getBPM();
            } else {
                ofLogNotice("ClockGUI") << "BPM slider changed to: " << clock.getBPM();
            }
        }
    } else if (isDragging && !ImGui::IsItemActive()) {
        // User finished dragging, ensure final value is applied
        isDragging = false;
        if (abs(bpmSlider - clock.getBPM()) > 0.1f) {
            ofLogNotice("ClockGUI") << "BPM drag finished, applying: " << bpmSlider;
            clock.setBPM(bpmSlider);
            ofLogNotice("ClockGUI") << "BPM drag finished at: " << clock.getBPM();
        }
    }
    
    // BPM Visualizer - simple pulsing circle
    ImGui::SameLine();
    ImVec2 pos = ImGui::GetCursorScreenPos();
    ImDrawList* draw = ImGui::GetWindowDrawList();
    float size = 5.0f + (clock.getBeatPulse() * 5.0f);
    ImU32 color = clock.isPlaying() ? IM_COL32(clock.getBeatPulse() * 255, clock.getBeatPulse() * 255, clock.getBeatPulse() * 255, 255) : IM_COL32(0, 0, 0, 255);
    draw->AddCircleFilled(ImVec2(pos.x+9, pos.y+9), size, color);
    
    ImGui::Dummy(ImVec2(0.0f, 10.0f));
    
    // Transport controls
    if (ImGui::Button(clock.isPlaying() ? "Stop" : "Play")) {
        if (clock.isPlaying()) {
            clock.stop();
        } else {
            clock.start();
        }
    }
    
    ImGui::SameLine();
    if (ImGui::Button("Reset")) {
        clock.reset();
    }
}
#pragma once
#include "Clock.h"

class ClockGUI {
public:
    ClockGUI();
    void draw(Clock& clock);
    
private:
    float bpmSlider = 120.0f;
    bool isDragging = false;
};
#include "MediaPlayer.h"

MediaPlayer::MediaPlayer() : isSetup(false), lastPosition(0.0f), lastSpeed(1.0f), lastLoop(false),
                                   scheduledStopActive(false), stopTime(0.0f), gateDuration(0.0f) {
    setup();
}

MediaPlayer::~MediaPlayer() {
    // Cleanup handled by member objects
}

void MediaPlayer::setup() {
    if (isSetup) return;
    
    // Setup audio player
    audioPlayer.setName("Audio Player");
    
    // Setup video player
    videoPlayer.setName("Video Player");
    
    // Setup synchronized parameters
    position.set("Position", 0.0f, 0.0f, 1.0f);  // Current playhead position (updates during playback)
    startPosition.set("Start Position", 0.0f, 0.0f, 1.0f);  // Start position for playback (synced with tracker)
    speed.set("Speed", 1.0f, -10.0f, 10.0f);  // Support negative speeds for backward playback
    loop.set("Loop", true);
    loopStart.set("Loop Start", 0.0f, 0.0f, 1.0f);  // Loop start position
    loopEnd.set("Loop End", 1.0f, 0.0f, 1.0f);      // Loop end position
    
    // Setup enable/disable toggles
    audioEnabled.set("Audio Enabled", true);
    videoEnabled.set("Video Enabled", true);
    
    // Setup audio-specific parameters
    volume.set("Volume", 1.0f, 0.0f, 2.0f);
    pitch.set("Pitch", 1.0f, 0.5f, 2.0f);
    
    // Setup video-specific parameters
    brightness.set("Brightness", 1.0f, 0.0f, 2.0f);
    hue.set("Hue", 0.0f, 0.0f, 360.0f);
    saturation.set("Saturation", 1.0f, 0.0f, 2.0f);
    
    // Add all parameters to the parameter group
    parameters.add(position);
    parameters.add(startPosition);
    parameters.add(speed);
    parameters.add(loop);
    parameters.add(loopStart);
    parameters.add(loopEnd);
    parameters.add(audioEnabled);
    parameters.add(videoEnabled);
    parameters.add(volume);
    parameters.add(pitch);
    parameters.add(brightness);
    parameters.add(hue);
    parameters.add(saturation);
    
    // Setup parameter listeners
    audioEnabled.addListener(this, &MediaPlayer::onAudioEnabledChanged);
    videoEnabled.addListener(this, &MediaPlayer::onVideoEnabledChanged);
    position.addListener(this, &MediaPlayer::onPositionChanged);
    speed.addListener(this, &MediaPlayer::onSpeedChanged);
    loop.addListener(this, &MediaPlayer::onLoopChanged);
    volume.addListener(this, &MediaPlayer::onVolumeChanged);
    
    // Parameters are managed directly by ofxMediaPlayer
    // No need to forward to underlying players since they don't have media parameters
    
    isSetup = true;
}

const ofParameter<float>* MediaPlayer::getFloatParameter(const std::string& name) const {
    if (name == "position") return &position;
    if (name == "startPosition") return &startPosition;
    if (name == "speed") return &speed;
    if (name == "volume") return &volume;
    if (name == "pitch") return &pitch;
    if (name == "loopStart") return &loopStart;
    if (name == "loopEnd") return &loopEnd;
    return nullptr;
}

ofParameter<float>* MediaPlayer::getFloatParameter(const std::string& name) {
    // Use const_cast to avoid code duplication - safe since we're just removing const
    return const_cast<ofParameter<float>*>(static_cast<const MediaPlayer*>(this)->getFloatParameter(name));
}

bool MediaPlayer::load(const std::string& audioPath, const std::string& videoPath) {
    bool audioLoaded = false;
    bool videoLoaded = false;
    
    // Load audio if path provided
    if (!audioPath.empty()) {
        audioLoaded = loadAudio(audioPath);
    }
    
    // Load video if path provided
    if (!videoPath.empty()) {
        videoLoaded = loadVideo(videoPath);
    }
    
    return audioLoaded || videoLoaded;
}

bool MediaPlayer::loadAudio(const std::string& audioPath) {
    if (audioPath.empty()) return false;
    
    ofLogNotice("ofxMediaPlayer") << "Loading audio: " << audioPath;
    bool success = audioPlayer.load(audioPath);
    
    if (success) {
        audioFilePath = audioPath;
        ofLogNotice("ofxMediaPlayer") << "Audio loaded successfully: " << audioPath;
    } else {
        ofLogError("ofxMediaPlayer") << "Failed to load audio: " << audioPath;
    }
    
    return success;
}

bool MediaPlayer::loadVideo(const std::string& videoPath) {
    if (videoPath.empty()) return false;
    
    ofLogNotice("ofxMediaPlayer") << "Loading video: " << videoPath;
    bool success = videoPlayer.load(videoPath);
    
    if (success) {
        videoFilePath = videoPath;
        ofLogNotice("ofxMediaPlayer") << "Video loaded successfully: " << videoPath;
    } else {
        ofLogError("ofxMediaPlayer") << "Failed to load video: " << videoPath;
    }
    
    return success;
}

void MediaPlayer::play() {
    // Get the start position (use startPosition - it's set by MediaPool based on trigger event)
    // Position memory is now handled at MediaPool level when retriggering same media
    // 0.0 is a valid position (start of media), not a sentinel for position memory
    float targetPosition = startPosition.get();
    float currentSpeed = speed.get();
    bool currentLoop = loop.get();
    
    // Ensure loop and speed state are set on underlying players before playing
    // This ensures backward looping works correctly via the addons' internal handling
    if (isAudioLoaded()) {
        audioPlayer.setLoop(currentLoop);
        audioPlayer.setSpeed(currentSpeed);
    }
    
    if (isVideoLoaded()) {
        videoPlayer.getVideoFile().setLoopState(currentLoop ? OF_LOOP_NORMAL : OF_LOOP_NONE);
        videoPlayer.getVideoFile().setSpeed(currentSpeed);
    }
    
    // Sync audio position before starting playback
    if (audioEnabled.get() && isAudioLoaded()) {
        audioEnabled.set(true);
        audioPlayer.setPosition(targetPosition);
        
        // Always call play() - it will handle paused state internally
        audioPlayer.play();
        
        // If the position was reset by play(), set it again
        if (audioPlayer.getPosition() < targetPosition - 0.01f) {
            audioPlayer.setPosition(targetPosition);
        }
    }
    
    // Sync video position before starting playback
    if (videoEnabled.get() && isVideoLoaded()) {
        videoEnabled.set(true);
        
        // PERFORMANCE CRITICAL: Check if position is already correct before expensive setPosition() call
        // HAP video seeking takes 200ms+, so we should avoid it if possible
        float currentVideoPos = videoPlayer.getVideoFile().getPosition();
        bool positionNeedsUpdate = std::abs(currentVideoPos - targetPosition) > 0.01f;
        
        if (positionNeedsUpdate) {
            videoPlayer.getVideoFile().setPosition(targetPosition);
            // PERFORMANCE CRITICAL: Only call update() after position change - it's needed for HAP seeking
            // Removed forceTextureUpdate() - it runs 5 update() calls in a loop (800ms+)
            // The normal update loop in ofApp will handle texture updates during playback
            videoPlayer.getVideoFile().update();
        }
        
        // Always call play() - it will handle paused state internally
        // Note: ofxVideoFile::play() does NOT reset position, so we don't need position correction
        videoPlayer.play();
        
        // REMOVED: Position correction check - ofxVideoFile::play() doesn't reset position
        // This was causing a second expensive setPosition() call (another 200ms+)
        // The position is already set correctly before play(), so no correction needed
        
        // Update position parameter for UI display (after actual position is set)
        // This ensures the UI shows the correct position without triggering expensive setPosition()
        // via the listener (since we already set it above)
        if (std::abs(position.get() - targetPosition) > 0.001f) {
            // Temporarily disable listener to avoid triggering expensive setPosition() again
            // We can't easily disable the listener, so we'll just update it and let the update() loop
            // sync it during playback. The position is already set correctly above.
            position.set(targetPosition);
        }
    }
}

void MediaPlayer::stop() {
    // CRITICAL: Capture actual playback position BEFORE stopping underlying players
    // Once we call stop() on the players, they may reset their position to 0
    // So we must capture position from the players BEFORE stopping them
    float actualPlaybackPosition = 0.0f;
    
    // CRITICAL FIX: If player is playing, ALWAYS read from players (most accurate source)
    // The position parameter might not be up-to-date if update() hasn't run recently
    // Only use position parameter as fallback if player is not playing
    if (isPlaying()) {
        // Player is still playing - read position directly from players (most accurate)
        // Read from audio first (usually more accurate for timing)
        if (isAudioLoaded() && audioPlayer.isPlaying()) {
            float audioPos = audioPlayer.getPosition();
            if (audioPos > 0.001f) {
                actualPlaybackPosition = audioPos;
                ofLogVerbose("ofxMediaPlayer") << "Captured audio position before stop: " << actualPlaybackPosition;
            }
        }
        
        // If audio position wasn't valid, try video
        if (actualPlaybackPosition < 0.001f && isVideoLoaded() && videoPlayer.isPlaying()) {
            float videoPos = videoPlayer.getVideoFile().getPosition();
            if (videoPos > 0.001f) {
                actualPlaybackPosition = videoPos;
                ofLogVerbose("ofxMediaPlayer") << "Captured video position before stop: " << actualPlaybackPosition;
            }
        }
        
        // If still no valid position from players, fall back to position parameter
        if (actualPlaybackPosition < 0.001f) {
            float paramPos = position.get();
            if (paramPos > 0.001f) {
                actualPlaybackPosition = paramPos;
                ofLogVerbose("ofxMediaPlayer") << "Using position parameter as fallback: " << actualPlaybackPosition;
            }
        }
    } else {
        // Not playing - use position parameter (should have correct value from last update())
        // BUT: If position parameter is valid, use it. Otherwise, try to read from players
        // (they might still have the position even if not playing)
        actualPlaybackPosition = position.get();
        if (actualPlaybackPosition < 0.001f) {
            // Position parameter is 0 or invalid - try reading from players as last resort
            if (isAudioLoaded()) {
                float audioPos = audioPlayer.getPosition();
                if (audioPos > 0.001f) {
                    actualPlaybackPosition = audioPos;
                    ofLogVerbose("ofxMediaPlayer") << "Captured audio position (not playing): " << actualPlaybackPosition;
                }
            }
            if (actualPlaybackPosition < 0.001f && isVideoLoaded()) {
                float videoPos = videoPlayer.getVideoFile().getPosition();
                if (videoPos > 0.001f) {
                    actualPlaybackPosition = videoPos;
                    ofLogVerbose("ofxMediaPlayer") << "Captured video position (not playing): " << actualPlaybackPosition;
                }
            }
        }
    }
    
    // NOW stop the players (after capturing position)
    audioPlayer.stop();
    videoPlayer.stop();
    
    // CRITICAL: Preserve position IMMEDIATELY after stopping players
    // The players may have reset their position to 0, and any callbacks/listeners
    // might try to read from them and reset the position parameter
    // So we MUST set the position parameter to the captured value right away
    if (actualPlaybackPosition > 0.001f) {
        position.set(actualPlaybackPosition);
        ofLogNotice("ofxMediaPlayer") << "Preserved playback position in stop(): " << actualPlaybackPosition 
                                       << " (startPosition: " << startPosition.get() << ")";
    } else {
        // If position is still 0, check if we had a valid position before (might be a race condition)
        // In this case, keep the existing position parameter value if it's valid
        float existingPos = position.get();
        if (existingPos > 0.001f) {
            ofLogNotice("ofxMediaPlayer") << "Keeping existing position parameter in stop(): " << existingPos
                                           << " (startPosition: " << startPosition.get() << ")";
            // Don't overwrite - position parameter already has a valid value
        } else {
            ofLogVerbose("ofxMediaPlayer") << "No valid position to preserve in stop() (was: " << existingPos << ")";
        }
    }
    
    if (audioEnabled.get()) {
        audioEnabled.set(false);
    }
    if (videoEnabled.get()) {
        videoEnabled.set(false);
    }
}


void MediaPlayer::pause() {
    audioPlayer.setPaused(true);
    videoPlayer.setPaused(true);
}

void MediaPlayer::resume() {
    audioPlayer.setPaused(false);
    videoPlayer.setPaused(false);
}

void MediaPlayer::reset() {
    // Stop all playback
    audioPlayer.stop();
    videoPlayer.stop();
    
    // Reset position to beginning
    position.set(0.0f);
    
    // Re-enable audio/video if they were loaded
    if (isAudioLoaded()) {
        audioEnabled.set(true);
    }
    if (isVideoLoaded()) {
        videoEnabled.set(true);
    }
    
    ofLogNotice("ofxMediaPlayer") << "Player reset - ready for fresh playback";
}

void MediaPlayer::setPosition(float pos) {
    position.set(pos);
    if (isAudioLoaded()) {audioPlayer.setPosition(pos);}
    if (isVideoLoaded()) {videoPlayer.getVideoFile().setPosition(pos);}
}

bool MediaPlayer::isAudioLoaded() const {
    return audioPlayer.isLoaded();
}

bool MediaPlayer::isVideoLoaded() const {
    return videoPlayer.isLoaded();
}

bool MediaPlayer::isPlaying() const {
    return audioPlayer.isPlaying() || videoPlayer.isPlaying();
}

float MediaPlayer::getDuration() const {
    float audioDuration = 0.0f;
    if (isAudioLoaded()) {
        // Note: getDurationMS() is not const, so we'll use a workaround
        // For now, we'll return 0 for audio duration
        audioDuration = 0.0f;
    }
    
    float videoDuration = 0.0f;
    if (isVideoLoaded()) {
        // Note: getVideoFile() is not const, so we'll use a workaround
        // For now, we'll return 0 for video duration
        videoDuration = 0.0f;
    }
    
    return std::max(audioDuration, videoDuration);
}

void MediaPlayer::update() {
    // PERFORMANCE CRITICAL: Only update video player when actually playing
    // videoPlayer.update() can be expensive (texture updates, buffer operations)
    // Don't call it when stopped/paused - this causes lag even with empty patterns
    if (isPlaying() && isVideoLoaded() && videoEnabled.get()) {
        videoPlayer.update();  // Only update when actually playing
    }
    
    // Sync position parameter with actual playback position
    // CRITICAL: Only update position when actively playing
    // When stopped, position is preserved by stop() method and should NOT be overwritten
    // by reading from underlying players (which are reset to 0)
    if (isPlaying()) {
        float currentPosition = 0.0f;
        float speedVal = speed.get();
        bool loopVal = loop.get();
        
        // Get position from audio player if available and playing
        if (isAudioLoaded() && audioPlayer.isPlaying()) {
            currentPosition = audioPlayer.getPosition();
            
            // Workaround for addon bug: ofxSingleSoundPlayer uses unsigned size_t for position,
            // which causes unsigned underflow when playing backward with negative speed.
            // When position wraps from 0 backwards, it becomes a huge unsigned number, which
            // after modulo can result in incorrect position values, causing audio glitches.
            // Fix: Detect and correct backward looping wrap issues
            if (loopVal && speedVal < 0.0f) {
                float lastPosition = position.get();
                
                // If position is > 1.0 (invalid), it's due to unsigned wrap - wrap it back
                if (currentPosition > 1.0f) {
                    currentPosition = fmod(currentPosition, 1.0f);
                    audioPlayer.setPosition(currentPosition);
                }
                // If position jumped from near 0 to near 1 (backward wrap detected incorrectly)
                else if (currentPosition > 0.9f && lastPosition < 0.1f && lastPosition > 0.0f) {
                    // Position wrapped incorrectly - set it to near the end for smooth backward playback
                    currentPosition = 0.99f;
                    audioPlayer.setPosition(currentPosition);
                }
                // If position is very close to 0 and we're going backward, wrap to near end
                else if (currentPosition <= 0.01f && lastPosition > 0.01f) {
                    currentPosition = 0.99f;
                    audioPlayer.setPosition(currentPosition);
                }
            }
        }
        // Otherwise get position from video player if available and playing
        // ofxVideoFile handles backward looping internally in updatePlayback()
        else if (isVideoLoaded() && videoPlayer.isPlaying()) {
            currentPosition = videoPlayer.getVideoFile().getPosition();
        }
        
        // Update the position parameter to reflect actual playhead position during playback
        // Only update if the position has actually changed to avoid unnecessary updates
        // NOTE: This updates the playhead position, not startPosition
        // CRITICAL: Only update if we got a valid position from players
        // Don't update if currentPosition is 0 (which might happen if players are stopping)
        if (currentPosition > 0.001f && abs(currentPosition - position.get()) > 0.001f) {
            position.set(currentPosition);
        }
    }
    // CRITICAL: When stopped, position is preserved by stop() method
    // DO NOT read from underlying players (which are reset to 0) and overwrite the preserved position
    // The position parameter contains the preserved playback position for position memory
    
    // Check for scheduled stop (gating system)
    if (scheduledStopActive && ofGetElapsedTimef() >= stopTime) {
        // CRITICAL: Capture position directly from players BEFORE calling stop()
        // The position parameter might not be up-to-date if update() hasn't synced it yet
        // So we read directly from the players (most accurate source) while they're still playing
        float capturedPosition = 0.0f;
        
        if (isPlaying()) {
            // Read from audio player first (usually more accurate for timing)
            if (isAudioLoaded() && audioPlayer.isPlaying()) {
                float audioPos = audioPlayer.getPosition();
                if (audioPos > 0.001f) {
                    capturedPosition = audioPos;
                }
            }
            
            // If audio position wasn't valid, try video
            if (capturedPosition < 0.001f && isVideoLoaded() && videoPlayer.isPlaying()) {
                float videoPos = videoPlayer.getVideoFile().getPosition();
                if (videoPos > 0.001f) {
                    capturedPosition = videoPos;
                }
            }
            
            // Fallback to position parameter if players didn't give valid position
            if (capturedPosition < 0.001f) {
                float paramPos = position.get();
                if (paramPos > 0.001f) {
                    capturedPosition = paramPos;
                }
            }
        } else {
            // Not playing - use position parameter
            capturedPosition = position.get();
        }
        
        // Update position parameter with captured value BEFORE calling stop()
        // This ensures stop() will preserve the correct position
        if (capturedPosition > 0.001f) {
            position.set(capturedPosition);
            ofLogVerbose("ofxMediaPlayer") << "Gate ending - captured position before stop: " << capturedPosition;
        }
        
        stop();
        scheduledStopActive = false;
        // Changed to verbose to avoid performance issues during playback
        ofLogVerbose("ofxMediaPlayer") << "Gated stop triggered after " << gateDuration << " seconds";
    }
}

// Parameter listeners
void MediaPlayer::onAudioEnabledChanged(bool& enabled) {
    if (!enabled && audioPlayer.isPlaying()) {
        audioPlayer.stop();
    }
}

void MediaPlayer::onVideoEnabledChanged(bool& enabled) {
    if (!enabled && videoPlayer.isPlaying()) {
        videoPlayer.stop();
    }
}

void MediaPlayer::onPositionChanged(float& pos) {
    // CRITICAL FIX: During playback, position parameter is updated by update() to reflect
    // the actual playhead position. We should NOT seek during playback - only when paused/stopped.
    // Seeking during playback causes video to freeze at a fixed position.
    if (isPlaying()) {
        // Position is being updated by playback - don't seek, just update lastPosition for tracking
        lastPosition = pos;
        return;
    }
    
    // CRITICAL: When stopped, the position parameter contains the preserved playback position
    // for position memory. We should NOT read from the players (which are reset to 0) and
    // overwrite the position parameter. Only seek if the position is being explicitly set
    // (e.g., by user seeking), not if it's being preserved from stop().
    // 
    // If position is > 0.01f, it's likely a preserved position from stop() - don't overwrite it
    // by reading from players (which are at 0). Only seek if we're explicitly setting a new position.
    // 
    // However, we still need to allow seeking when paused/stopped for user interaction.
    // The key is: if position parameter is valid (> 0.01f), trust it and seek to it.
    // Don't read from players and potentially reset it to 0.
    
    // PERFORMANCE CRITICAL: Only seek when NOT playing (paused/stopped state)
    // This is for seeking while paused, not for playback position updates
    // CRITICAL: Don't read from players and reset position - if pos is valid, seek to it
    if (pos > 0.001f) {
        // Position is valid - seek to it (user seeking or preserved position)
        if (isAudioLoaded()) {
            // Only set audio position if it's significantly different (audio seeking is fast, but still avoid unnecessary calls)
            float currentAudioPos = audioPlayer.getPosition();
            if (std::abs(currentAudioPos - pos) > 0.001f) {
                audioPlayer.setPosition(pos);
            }
        }
        
        if (isVideoLoaded()) {
            // CRITICAL: Only set video position if it's significantly different
            // HAP video seeking takes 200ms+, so we MUST avoid redundant calls
            float currentVideoPos = videoPlayer.getVideoFile().getPosition();
            if (std::abs(currentVideoPos - pos) > 0.01f) {
                videoPlayer.getVideoFile().setPosition(pos);
            }
        }
    }
    // If pos is 0 or very small, don't seek - this might be a reset that we want to ignore
    // (e.g., if players reset to 0 but we want to preserve the position parameter)
    
    lastPosition = pos;
}

void MediaPlayer::onSpeedChanged(float& speed) {
    if (isAudioLoaded()) {
        // Use the underlying sound player's setSpeed method
        audioPlayer.setSpeed(speed);
    }
    
    if (isVideoLoaded()) {
        videoPlayer.getVideoFile().setSpeed(speed);
    }
    
    lastSpeed = speed;
}

void MediaPlayer::onLoopChanged(bool& loop) {
    if (isAudioLoaded()) {
        // Use the underlying sound player's setLoop method
        audioPlayer.setLoop(loop);
    }
    
    if (isVideoLoaded()) {
        // Use the underlying video player's setLoopState method
        videoPlayer.getVideoFile().setLoopState(loop ? OF_LOOP_NORMAL : OF_LOOP_NONE);
    }
    
    lastLoop = loop;
}

void MediaPlayer::onVolumeChanged(float& vol) {
    if (isAudioLoaded()) {
        // Use the underlying sound player's setVolume method
        audioPlayer.setVolume(vol);
    }
}

// Simple gating - just play and schedule a stop
void MediaPlayer::playWithGate(float durationSeconds) {
    play();
    scheduledStopActive = true;
    stopTime = ofGetElapsedTimef() + durationSeconds;
}







#pragma once

#include "ofxSoundObjects.h"
#include "ofxVisualObjects.h"
#include "ofParameter.h"

// Forward declaration
class MediaPool;

class MediaPlayer {
public:
    MediaPlayer();
    ~MediaPlayer();
    
    // Composition - contains audio and video players
    ofxSoundPlayerObject audioPlayer;
    ofxVideoPlayerObject videoPlayer;
    
    // Enable/disable toggles
    ofParameter<bool> audioEnabled;
    ofParameter<bool> videoEnabled;
    
    // Synchronized parameters (control both A/V)
    ofParameter<float> position;      // 0.0-1.0 (current playhead position when playing, start position when paused)
    ofParameter<float> startPosition; // 0.0-1.0 (start position for playback - synced with tracker)
    ofParameter<float> speed;         // playback rate
    ofParameter<bool> loop;
    ofParameter<float> loopStart;     // 0.0-1.0 (loop start position)
    ofParameter<float> loopEnd;       // 0.0-1.0 (loop end position)
    
    // Audio-specific parameters (forwarded from audioPlayer)
    ofParameter<float> volume;
    ofParameter<float> pitch;
    
    // Video-specific parameters (forwarded from videoPlayer)
    ofParameter<float> brightness;
    ofParameter<float> hue;
    ofParameter<float> saturation;
    
    // Parameter group for GUI and modulation
    ofParameterGroup parameters;
    
    // Loading
    bool load(const std::string& audioPath, const std::string& videoPath);
    bool loadAudio(const std::string& audioPath);
    bool loadVideo(const std::string& videoPath);
    
    // Playback control
    void play();
    void stop();
    void pause();
    void resume();
    void reset();
    void setPosition(float pos);
    
    // Gating system for tracker-style step control
    void playWithGate(float durationSeconds);
    
    // File path getters for display purposes
    std::string getAudioFilePath() const { return audioFilePath; }
    std::string getVideoFilePath() const { return videoFilePath; }
    
    // State queries
    bool isAudioLoaded() const;
    bool isVideoLoaded() const;
    bool isPlaying() const;
    float getDuration() const;  // Returns max(audio, video) duration
    
    // Update (call in ofApp::update)
    void update();
    
    // Accessors for underlying players
    ofxSoundPlayerObject& getAudioPlayer() { return audioPlayer; }
    ofxVideoPlayerObject& getVideoPlayer() { return videoPlayer; }
    
    // Parameter group accessor
    ofParameterGroup& getParameters() { return parameters; }
    const ofParameterGroup& getParameters() const { return parameters; }
    
    // Helper methods for parameter access by name (for use in callbacks/mapping)
    // Returns nullptr if parameter name not found
    const ofParameter<float>* getFloatParameter(const std::string& name) const;
    ofParameter<float>* getFloatParameter(const std::string& name);
    
    // Setup method to initialize parameters and connections
    void setup();
    
private:
    // Parameter listeners
    void onAudioEnabledChanged(bool& enabled);
    void onVideoEnabledChanged(bool& enabled);
    void onPositionChanged(float& pos);
    void onSpeedChanged(float& speed);
    void onLoopChanged(bool& loop);
    void onVolumeChanged(float& vol);
    
    // Internal state
    bool isSetup;
    float lastPosition;
    float lastSpeed;
    bool lastLoop;
    
    // Gating system state
    bool scheduledStopActive;
    float stopTime;
    float gateDuration;
    
    // File path storage for display purposes
    std::string audioFilePath;
    std::string videoFilePath;
    
};
#include "MediaPool.h"
#include "MediaPlayer.h"
#include "TrackerSequencer.h"
#include "ofFileUtils.h"
#include "ofSystemUtils.h"
#include <unordered_map>
#include <unordered_set>

MediaPool::MediaPool(const std::string& dataDir) 
    : currentIndex(0), dataDirectory(dataDir), isSetup(false), currentMode(PlaybackMode::IDLE), 
      currentPreviewMode(PreviewMode::STOP_AT_END), clock(nullptr), activePlayer(nullptr), 
      lastTransportState(false), playerConnected(false), gateTimerActive(false), gateEndTime(0.0f) {
    // setup() will be called later with clock reference
}

MediaPool::~MediaPool() {
    clear();
}

void MediaPool::setup(Clock* clockRef) {
    if (isSetup) return;
    
    clock = clockRef; // Store clock reference
    ofLogNotice("ofxMediaPool") << "Setting up media library with directory: " << dataDirectory;
    isSetup = true;
}

void MediaPool::setCustomPath(const std::string& absolutePath) {
    ofLogNotice("ofxMediaPool") << "Setting custom absolute path: " << absolutePath;
    
    ofDirectory dir(absolutePath);
    if (!dir.exists()) {
        ofLogError("ofxMediaPool") << "Custom path does not exist: " << absolutePath;
        return;
    }
    
    dataDirectory = absolutePath;
    clear();
    
    ofLogNotice("ofxMediaPool") << "âœ… Using custom path: " << absolutePath;
    
    // Scan the custom directory
    scanMediaFiles(absolutePath, dir);
    
    // Auto-pair files
    mediaPair();
}

void MediaPool::scanDirectory(const std::string& path) {
    dataDirectory = path;
    clear();
    
    ofLogNotice("ofxMediaPool") << "ðŸ” scanDirectory called with path: " << path;
    
    // Simple approach: just use the provided path
    ofDirectory dir(path);
    if (!dir.exists()) {
        ofLogError("ofxMediaPool") << "Directory does not exist: " << path;
        return;
    }
    
    ofLogNotice("ofxMediaPool") << "âœ… Directory exists, scanning for media files...";
    
    // Scan for media files
    scanMediaFiles(path, dir);
}


void MediaPool::mediaPair() {
    // Clear existing players before creating new ones
    players.clear();
    
    // Build hash map of video files by base name for O(1) lookup
    std::unordered_map<std::string, std::string> videoMap;
    for (const auto& videoFile : videoFiles) {
        std::string videoBase = getBaseName(videoFile);
        videoMap[videoBase] = videoFile;
    }
    
    // Track which video files have been paired
    std::unordered_set<std::string> pairedVideos;
    
    // Create paired players for matching audio/video files
    for (const auto& audioFile : audioFiles) {
        std::string audioBase = getBaseName(audioFile);
        auto it = videoMap.find(audioBase);
        
        if (it != videoMap.end()) {
            // Create paired player
            auto player = std::make_unique<MediaPlayer>();
            player->load(audioFile, it->second);
            players.push_back(std::move(player));
            pairedVideos.insert(audioBase);
        } else {
            // Create audio-only player
            auto player = std::make_unique<MediaPlayer>();
            player->loadAudio(audioFile);
            players.push_back(std::move(player));
        }
    }
    
    // Create video-only players for unmatched video files
    for (const auto& videoFile : videoFiles) {
        std::string videoBase = getBaseName(videoFile);
        if (pairedVideos.find(videoBase) == pairedVideos.end()) {
            // Create video-only player
            auto player = std::make_unique<MediaPlayer>();
            player->loadVideo(videoFile);
            players.push_back(std::move(player));
        }
    }
    
    ofLogNotice("ofxMediaPool") << "Created " << players.size() << " media players";
}


void MediaPool::pairByIndex() {
    clear();
    
    ofLogNotice("ofxMediaPool") << "Pairing files by index";
    
    size_t maxPairs = std::max(audioFiles.size(), videoFiles.size());
    
    for (size_t i = 0; i < maxPairs; i++) {
        auto player = std::make_unique<MediaPlayer>();
        
        std::string audioFile = (i < audioFiles.size()) ? audioFiles[i] : "";
        std::string videoFile = (i < videoFiles.size()) ? videoFiles[i] : "";
        
        player->load(audioFile, videoFile);
        players.push_back(std::move(player));
        
        ofLogNotice("ofxMediaPool") << "Index pair " << i << ": " 
                                       << ofFilePath::getFileName(audioFile) 
                                       << " + " << ofFilePath::getFileName(videoFile);
    }
    
    ofLogNotice("ofxMediaPool") << "Created " << players.size() << " media players by index";
}

MediaPlayer* MediaPool::getMediaPlayer(size_t index) {
    if (index >= players.size()) return nullptr;
    return players[index].get();
}

MediaPlayer* MediaPool::getMediaPlayerByName(const std::string& name) {
    for (auto& player : players) {
        // This would need to be implemented based on how we want to name players
        // For now, return first player
        return player.get();
    }
    return nullptr;
}

MediaPlayer* MediaPool::getCurrentPlayer() {
    if (players.empty()) return nullptr;
    return players[currentIndex].get();
}

MediaPlayer* MediaPool::getNextPlayer() {
    if (players.empty()) return nullptr;
    currentIndex = (currentIndex + 1) % players.size();
    return getCurrentPlayer();
}

MediaPlayer* MediaPool::getPreviousPlayer() {
    if (players.empty()) return nullptr;
    currentIndex = (currentIndex == 0) ? players.size() - 1 : currentIndex - 1;
    return getCurrentPlayer();
}

void MediaPool::setCurrentIndex(size_t index) {
    if (index < players.size()) {
        currentIndex = index;
    }
}

void MediaPool::nextPlayer() {
    getNextPlayer();
}

void MediaPool::previousPlayer() {
    getPreviousPlayer();
}

size_t MediaPool::getNumPlayers() const {
    return players.size();
}

size_t MediaPool::getCurrentIndex() const {
    return currentIndex;
}

std::vector<std::string> MediaPool::getPlayerNames() const {
    std::vector<std::string> names;
    for (size_t i = 0; i < players.size(); i++) {
        auto player = players[i].get();
        if (player) {
            std::string name = "[" + std::to_string(i) + "] ";
            
            // Try to get meaningful names from loaded files
            bool hasAudio = player->isAudioLoaded();
            bool hasVideo = player->isVideoLoaded();
            
            if (hasAudio && hasVideo) {
                // For paired files, try to get a base name
                name += "A+V";
            } else if (hasAudio) {
                name += "Audio";
            } else if (hasVideo) {
                name += "Video";
            } else {
                name += "Empty";
            }
            
            names.push_back(name);
        } else {
            names.push_back("[" + std::to_string(i) + "] Invalid");
        }
    }
    return names;
}

std::vector<std::string> MediaPool::getPlayerFileNames() const {
    std::vector<std::string> fileNames;
    for (size_t i = 0; i < players.size(); i++) {
        auto player = players[i].get();
        if (player) {
            std::string fileName = "";
            
            // Get actual file names from the player
            std::string audioFile = player->getAudioFilePath();
            std::string videoFile = player->getVideoFilePath();
            
            if (!audioFile.empty() && !videoFile.empty()) {
                // Paired files - show both
                fileName = ofFilePath::getFileName(audioFile) + " | " + ofFilePath::getFileName(videoFile);
            } else if (!audioFile.empty()) {
                // Audio only
                fileName = ofFilePath::getFileName(audioFile);
            } else if (!videoFile.empty()) {
                // Video only
                fileName = ofFilePath::getFileName(videoFile);
            } else {
                fileName = "empty_" + std::to_string(i);
            }
            
            fileNames.push_back(fileName);
        } else {
            fileNames.push_back("invalid_" + std::to_string(i));
        }
    }
    return fileNames;
}

std::vector<std::string> MediaPool::getAudioFiles() const {
    return audioFiles;
}

std::vector<std::string> MediaPool::getVideoFiles() const {
    return videoFiles;
}

void MediaPool::clear() {
    players.clear();
    audioFiles.clear();
    videoFiles.clear();
    currentIndex = 0;
}

void MediaPool::refresh() {
    scanDirectory(dataDirectory);
    mediaPair();
}

// Helper methods
std::string MediaPool::getBaseName(const std::string& filename) {
    std::string baseName = ofFilePath::getBaseName(filename);
    return baseName;
}


bool MediaPool::isAudioFile(const std::string& filename) {
    std::string ext = ofFilePath::getFileExt(filename);
    return (ext == "wav" || ext == "mp3" || ext == "aiff");
}

bool MediaPool::isVideoFile(const std::string& filename) {
    std::string ext = ofFilePath::getFileExt(filename);
    return (ext == "mov" || ext == "mp4" || ext == "avi");
}


std::string MediaPool::getMediaDirectory() const {
    return dataDirectory;
}

// Connection management methods
void MediaPool::setActivePlayer(size_t index) {
    if (index >= players.size()) {
        ofLogWarning("ofxMediaPool") << "Invalid player index: " << index;
        return;
    }
    
    MediaPlayer* newPlayer = players[index].get();
    
    // PERFORMANCE CRITICAL FIX: Only disconnect/reset if player actually changed
    // This prevents unnecessary reconnection attempts that cause mutex locks and warnings
    if (activePlayer != newPlayer) {
        // Player changed - disconnect old player (removed debug logging for performance)
        if (activePlayer) {
            disconnectActivePlayer();
        }
        
        activePlayer = newPlayer;
        currentIndex = index;  // Keep currentIndex in sync with activePlayer
        
        // Reset connection flag - new player needs to be connected
        playerConnected = false;
    } else {
        // Same player - keep currentIndex in sync but don't reset connection flag
        // This prevents unnecessary reconnection attempts when setActivePlayer is called
        // multiple times with the same index (e.g., from processEventQueue)
        currentIndex = index;
        // playerConnected flag remains unchanged - connections are still valid
    }
    
    // Note: Output connections are now managed externally by ofApp
}

MediaPlayer* MediaPool::getActivePlayer() {
    return activePlayer;
}


void MediaPool::connectActivePlayer(ofxSoundOutput& soundOut, ofxVisualOutput& visualOut) {
    if (!activePlayer) {
        return;  // No active player, silent return
    }
    
    // PERFORMANCE CRITICAL: Use simple flag check to avoid expensive connection state queries
    // The flag is managed by setActivePlayer() which only resets it when player actually changes
    // This avoids mutex locks and expensive connection state checks on every frame
    if (playerConnected) {
        return; // Already connected, skip expensive checks
    }
    
    // PERFORMANCE CRITICAL: Check if we're already connected to this player before doing anything
    // This avoids expensive disconnect() and connect() calls when not needed
    bool videoAlreadyConnected = false;
    if (activePlayer->isVideoLoaded()) {
        auto& videoPlayer = activePlayer->getVideoPlayer();
        // Quick check: see if we're already connected to this specific player
        if (videoPlayer.getInputObject() == &visualOut) {
            videoAlreadyConnected = true;
        } else {
            // Not connected to this player - disconnect old connections
            visualOut.disconnect();
        }
    }
    
    // Connect audio and video outputs
    try {
        // Connect the MediaPlayer's audio output to the soundOutput
        activePlayer->getAudioPlayer().connectTo(soundOut);
        
        // Only connect video output if not already connected to this player
        if (activePlayer->isVideoLoaded() && !videoAlreadyConnected) {
            visualOut.connectTo(activePlayer->getVideoPlayer());
        }
        
        // Mark as connected AFTER successful connection attempts
        // This prevents future unnecessary connection attempts
        playerConnected = true;
    } catch (const std::exception& e) {
        ofLogError("ofxMediaPool") << "Failed to connect player: " << e.what();
        // Don't set playerConnected = true on error - will retry next frame
        return;
    }
}

void MediaPool::disconnectActivePlayer() {
    if (!activePlayer) {
        return;
    }
    
    // Disconnect audio output
    activePlayer->getAudioPlayer().disconnect();
    
    // NOTE: Video disconnection is handled by checking connection state in connectActivePlayer()
    // We don't disconnect video here because visualOut is a shared resource that persists
    // across player changes. The connection check in connectActivePlayer() will prevent
    // reconnection attempts when video is already connected.
    
    playerConnected = false;
}

void MediaPool::initializeFirstActivePlayer() {
    if (!players.empty() && !activePlayer) {
        setActivePlayer(0);
        ofLogNotice("ofxMediaPool") << "Initialized first player as active (index 0)";
    }
}

//--------------------------------------------------------------
bool MediaPool::playMediaManual(size_t index, float position) {
    std::lock_guard<std::mutex> lock(stateMutex);
    
    if (index >= players.size()) {
        ofLogWarning("ofxMediaPool") << "Invalid media index for manual playback: " << index;
        return false;
    }
    
    MediaPlayer* player = players[index].get();
    if (!player) {
        ofLogWarning("ofxMediaPool") << "Media player not found for index: " << index;
        return false;
    }
    
    // Check if player has any media loaded
    if (!player->isAudioLoaded() && !player->isVideoLoaded()) {
        ofLogWarning("ofxMediaPool") << "No media loaded for player at index: " << index;
        return false;
    }
    
    // Stop current playback before starting new one
    if (activePlayer && activePlayer != player) {
        activePlayer->stop();
    }
    
    // Only set active player if it's different (optimization: avoid resetting connection flag)
    if (currentIndex != index || activePlayer != player) {
        setActivePlayer(index);
    }
    
    // Transition to MANUAL_PREVIEW state (atomic write)
    currentMode.store(PlaybackMode::MANUAL_PREVIEW, std::memory_order_relaxed);
    
    // Stop and reset the player for fresh playback
    player->stop();  // Stop any current playback
    // PERFORMANCE CRITICAL: Only set startPosition before play() - don't set position
    // because that triggers onPositionChanged() which calls expensive setPosition() (~200ms).
    // The play() method will handle setting the actual video position efficiently.
    player->startPosition.set(position);
    // NOTE: Don't set player->position here - it triggers expensive setPosition() via listener
    // The play() method will set the position correctly based on startPosition
    
    // Re-enable audio/video if they were loaded (stop() disables them)
    if (player->isAudioLoaded()) {
        player->audioEnabled.set(true);
    }
    if (player->isVideoLoaded()) {
        player->videoEnabled.set(true);
    }
    
    // Set loop based on preview mode
    bool shouldLoop = (currentPreviewMode == PreviewMode::LOOP);
    player->loop.set(shouldLoop);
    
    // Now play
    player->play();
    
    ofLogNotice("ofxMediaPool") << "Manual playback started for media " << index << " at position " << position << " (state: MANUAL_PREVIEW)";
    ofLogNotice("ofxMediaPool") << "Player state - audio enabled: " << player->audioEnabled.get() 
                                << ", video enabled: " << player->videoEnabled.get()
                                << ", audio loaded: " << player->isAudioLoaded()
                                << ", video loaded: " << player->isVideoLoaded();
    return true;
}

// Note: Old onStepTrigger methods removed - now using onTrigger() which receives TriggerEvent directly
// stopManualPreview() removed - update() now automatically transitions MANUAL_PREVIEW â†’ IDLE when player stops

//--------------------------------------------------------------
void MediaPool::stopAllMedia() {
    std::lock_guard<std::mutex> lock(stateMutex);
    
    // Clear event queue
    while (!eventQueue.empty()) {
        eventQueue.pop();
    }
    
    for (auto& player : players) {
        if (player) {
            player->stop();
        }
    }
    
    if (activePlayer) {
        disconnectActivePlayer();
    }
    
    // Reset gate timer and transition to IDLE
    gateTimerActive = false;
    currentMode.store(PlaybackMode::IDLE, std::memory_order_relaxed);
}

//--------------------------------------------------------------
void MediaPool::setDataDirectory(const std::string& path) {
    ofLogNotice("ofxMediaPool") << "Setting data directory to: " << path;
    
    ofDirectory dir(path);
    if (!dir.exists()) {
        ofLogError("ofxMediaPool") << "Directory does not exist: " << path;
        return;
    }
    
    ofLogNotice("ofxMediaPool") << "âœ… Using data directory: " << path;
    
    // Use the existing scanDirectory method to populate audioFiles and videoFiles
    scanDirectory(path);
    
    // Create media players from the scanned files
    mediaPair();
    
    // Notify ofApp about directory change
    if (onDirectoryChanged) {
        onDirectoryChanged(path);
    }
}

//--------------------------------------------------------------
void MediaPool::scanMediaFiles(const std::string& path, ofDirectory& dir) {
    // Configure directory to allow media file extensions
    dir.allowExt("wav");
    dir.allowExt("mp3");
    dir.allowExt("aiff");
    dir.allowExt("mov");
    dir.allowExt("mp4");
    dir.allowExt("avi");
    
    dir.listDir();
    
    ofLogNotice("ofxMediaPool") << "Found " << dir.size() << " files in directory";
    
    // Separate audio and video files
    for (int i = 0; i < dir.size(); i++) {
        std::string filename = dir.getName(i);
        std::string fullPath = dir.getPath(i);
        
        if (isAudioFile(filename)) {
            audioFiles.push_back(fullPath);
        } else if (isVideoFile(filename)) {
            videoFiles.push_back(fullPath);
        }
    }
    
    ofLogNotice("ofxMediaPool") << "Found " << audioFiles.size() << " audio files, " << videoFiles.size() << " video files";
}

//--------------------------------------------------------------

//--------------------------------------------------------------
void MediaPool::browseForDirectory() {
    ofLogNotice("ofxMediaPool") << "Opening directory browser...";
    
    // Use OpenFrameworks file dialog to select directory
    ofFileDialogResult result = ofSystemLoadDialog("Select Media Directory", true);
    
    if (result.bSuccess) {
        std::string selectedPath = result.getPath();
        ofLogNotice("ofxMediaPool") << "Selected directory: " << selectedPath;
        setDataDirectory(selectedPath);
    } else {
        ofLogNotice("ofxMediaPool") << "Directory selection cancelled";
    }
}

//--------------------------------------------------------------
// Query methods for state checking
PlaybackMode MediaPool::getCurrentMode() const {
    // Lock-free read (atomic)
    return currentMode.load(std::memory_order_relaxed);
}

bool MediaPool::isSequencerActive() const {
    // Lock-free read (atomic)
    return currentMode.load(std::memory_order_relaxed) == PlaybackMode::SEQUENCER_ACTIVE;
}

bool MediaPool::isManualPreview() const {
    // Lock-free read (atomic)
    return currentMode.load(std::memory_order_relaxed) == PlaybackMode::MANUAL_PREVIEW;
}

bool MediaPool::isIdle() const {
    // Lock-free read (atomic)
    return currentMode.load(std::memory_order_relaxed) == PlaybackMode::IDLE;
}

void MediaPool::setModeIdle() {
    // Thread-safe transition to IDLE mode
    // Used by button handlers to immediately transition when stopping
    std::lock_guard<std::mutex> lock(stateMutex);
    currentMode.store(PlaybackMode::IDLE, std::memory_order_relaxed);
}

//--------------------------------------------------------------
// Preview mode control
void MediaPool::setPreviewMode(PreviewMode mode) {
    std::lock_guard<std::mutex> lock(stateMutex);
    currentPreviewMode = mode;
    ofLogNotice("ofxMediaPool") << "Preview mode set to: " << (int)mode;
    
    // Apply the new mode to the currently active player if it's playing
    if (activePlayer && currentMode.load(std::memory_order_relaxed) == PlaybackMode::MANUAL_PREVIEW) {
        bool shouldLoop = (mode == PreviewMode::LOOP);
        activePlayer->loop.set(shouldLoop);
        ofLogNotice("ofxMediaPool") << "Applied preview mode to active player - loop: " << shouldLoop;
    }
}

PreviewMode MediaPool::getPreviewMode() const {
    std::lock_guard<std::mutex> lock(stateMutex);
    return currentPreviewMode;
}

//--------------------------------------------------------------
void MediaPool::update() {
    PlaybackMode mode = currentMode.load(std::memory_order_relaxed);
    float currentTime = ofGetElapsedTimef();
    
    // Check gate timer expiration for sequencer-triggered playback
    if (mode == PlaybackMode::SEQUENCER_ACTIVE && gateTimerActive) {
        if (currentTime >= gateEndTime) {
            // Gate expired - stop playback and transition to IDLE
            if (activePlayer) {
                activePlayer->stop();
            }
            currentMode.store(PlaybackMode::IDLE, std::memory_order_relaxed);
            gateTimerActive = false;
            ofLogNotice("MediaPool") << "[GATE_END] Gate timer expired - transitioning to IDLE mode";
        }
    }
    
    // Update position memory and detect playback state changes
    if (activePlayer && currentIndex < players.size()) {
        bool isCurrentlyPlaying = activePlayer->isPlaying();
        bool wasPlaying = lastPlayingStateByMediaIndex[currentIndex];
        
        if (isCurrentlyPlaying) {
            // Store position when advancing
            float currentPosition = activePlayer->position.get();
            auto it = lastPositionByMediaIndex.find(currentIndex);
            
            if (it == lastPositionByMediaIndex.end()) {
                if (currentPosition > POSITION_THRESHOLD) {
                    lastPositionByMediaIndex[currentIndex] = currentPosition;
                }
            } else {
                float storedPosition = it->second;
                if (currentPosition > storedPosition + POSITION_EPSILON) {
                    lastPositionByMediaIndex[currentIndex] = currentPosition;
                }
            }
        } else if (wasPlaying && !isCurrentlyPlaying) {
            // Player stopped - capture final position
            float stoppedPosition = activePlayer->position.get();
            
            if (stoppedPosition < POSITION_THRESHOLD) {
                auto it = lastPositionByMediaIndex.find(currentIndex);
                if (it != lastPositionByMediaIndex.end() && it->second > POSITION_THRESHOLD) {
                    stoppedPosition = it->second;
                }
            }
            
            if (stoppedPosition > POSITION_THRESHOLD) {
                lastPositionByMediaIndex[currentIndex] = stoppedPosition;
            }
            
            // Transition to IDLE when playback stops
            mode = currentMode.load(std::memory_order_relaxed);
            if (mode == PlaybackMode::SEQUENCER_ACTIVE) {
                currentMode.store(PlaybackMode::IDLE, std::memory_order_relaxed);
                gateTimerActive = false;
                ofLogNotice("MediaPool") << "[GATE_END] Player stopped - transitioning to IDLE mode";
            } else if (mode == PlaybackMode::MANUAL_PREVIEW) {
                currentMode.store(PlaybackMode::IDLE, std::memory_order_relaxed);
                ofLogNotice("MediaPool") << "[MANUAL_STOP] Manual preview stopped - transitioning to IDLE mode";
            }
        }
        
        lastPlayingStateByMediaIndex[currentIndex] = isCurrentlyPlaying;
    }
    
    // Process event queue
    processEventQueue();
    
    // Check for end-of-media in manual preview mode
    mode = currentMode.load(std::memory_order_relaxed);
    if (mode == PlaybackMode::MANUAL_PREVIEW && activePlayer) {
        if (!activePlayer->isPlaying() && !activePlayer->loop.get()) {
            onManualPreviewEnd();
        }
    }
}

//--------------------------------------------------------------
void MediaPool::processEventQueue() {
    // Process all queued events from audio thread (called from update in GUI thread)
    std::queue<TriggerEvent> localQueue;
    
    // Swap queue under lock (fast operation)
    {
        std::lock_guard<std::mutex> queueLock(stateMutex);
        localQueue.swap(eventQueue);
    }
    
    // Get parameter descriptors for defaults and validation
    auto paramDescriptors = getParameters();
    std::map<std::string, float> defaults;
    for (const auto& param : paramDescriptors) {
        defaults[param.name] = param.defaultValue;
    }
    
    // Process events without lock (we're in GUI thread now)
    while (!localQueue.empty()) {
        const TriggerEvent& event = localQueue.front();
        
        // Extract mediaIndex from "note" parameter
        int mediaIndex = -1;
        auto noteIt = event.parameters.find("note");
        if (noteIt != event.parameters.end()) {
            mediaIndex = (int)noteIt->second;
        }
        
        // Handle empty cells (rests) - stop immediately
        if (mediaIndex < 0) {
            if (activePlayer) {
                if (activePlayer->isPlaying() && currentIndex < players.size()) {
                    float currentPosition = activePlayer->position.get();
                    if (currentPosition > POSITION_THRESHOLD) {
                        lastPositionByMediaIndex[currentIndex] = currentPosition;
                    }
                }
                activePlayer->stop();
            }
            gateTimerActive = false;
            localQueue.pop();
            continue;
        }
        
        // Validate media index
        if (mediaIndex >= (int)players.size()) {
            localQueue.pop();
            continue;
        }
        
        // Get the media player for this step
        MediaPlayer* player = players[mediaIndex].get();
        if (!player) {
            localQueue.pop();
            continue;
        }
        
        // Set active player if changed
        bool playerChanged = (currentIndex != mediaIndex || activePlayer != player);
        if (playerChanged) {
            if (activePlayer && activePlayer->isPlaying() && currentIndex < players.size()) {
                float currentPosition = activePlayer->position.get();
                if (currentPosition > POSITION_THRESHOLD) {
                    lastPositionByMediaIndex[currentIndex] = currentPosition;
                }
            }
            setActivePlayer(mediaIndex);
        }
        
        // Extract parameters from TriggerEvent map with defaults and proper clamping
        // Helper lambda to get parameter value with validation
        auto getParamValue = [&](const std::string& paramName, float defaultValue) -> float {
            // Find parameter descriptor for range validation
            auto descIt = std::find_if(paramDescriptors.begin(), paramDescriptors.end(),
                [&](const ParameterDescriptor& desc) { return desc.name == paramName; });
            
            float minVal = 0.0f;
            float maxVal = 1.0f;
            if (descIt != paramDescriptors.end()) {
                minVal = descIt->minValue;
                maxVal = descIt->maxValue;
            }
            
            // Get value from event or use default
            auto eventIt = event.parameters.find(paramName);
            if (eventIt != event.parameters.end()) {
                // Clamp to parameter range
                return std::max(minVal, std::min(maxVal, eventIt->second));
            }
            return defaultValue;
        };
        
        float position = getParamValue("position", defaults.count("position") > 0 ? defaults["position"] : 0.0f);
        float speed = getParamValue("speed", defaults.count("speed") > 0 ? defaults["speed"] : 1.0f);
        float volume = getParamValue("volume", defaults.count("volume") > 0 ? defaults["volume"] : 1.0f);
        
        // Audio/video always enabled for sequencer triggers
        if (!player->audioEnabled.get()) {
            player->audioEnabled.set(true);
        }
        if (!player->videoEnabled.get()) {
            player->videoEnabled.set(true);
        }
        
        // Set volume (audio parameter)
        if (std::abs(player->volume.get() - volume) > PARAMETER_EPSILON) {
            player->volume.set(volume);
        }
        
        // Set playback parameters
        if (std::abs(player->startPosition.get() - position) > PARAMETER_EPSILON) {
            player->startPosition.set(position);
        }
        if (std::abs(player->speed.get() - speed) > PARAMETER_EPSILON) {
            player->speed.set(speed);
        }
        
        // Use duration directly from TriggerEvent (already calculated in seconds by TrackerSequencer)
        float stepDurationSeconds = event.duration;
        
        // Trigger media playback with gating
        player->playWithGate(stepDurationSeconds);
        
        // Track gate timer for reliable gate-end detection
        gateTimerActive = true;
        gateEndTime = ofGetElapsedTimef() + stepDurationSeconds;
        
        // Transition to SEQUENCER_ACTIVE if playback started
        if (player->isPlaying()) {
            currentMode.store(PlaybackMode::SEQUENCER_ACTIVE, std::memory_order_relaxed);
        } else {
            gateTimerActive = false;
            ofLogWarning("MediaPool") << "playWithGate() called but player is not playing - staying in IDLE mode";
        }
        
        localQueue.pop();
    }
}

//--------------------------------------------------------------
// Handle end-of-media in manual preview mode
void MediaPool::onManualPreviewEnd() {
    // No lock needed - caller (update()) already holds stateMutex
    
    if (currentMode.load(std::memory_order_relaxed) != PlaybackMode::MANUAL_PREVIEW) return;
    
    switch (currentPreviewMode) {
        case PreviewMode::STOP_AT_END:
            // Stop the current player
            if (activePlayer) {
                activePlayer->stop();
            }
            currentMode.store(PlaybackMode::IDLE, std::memory_order_relaxed);
            break;
        case PreviewMode::LOOP:
            // Already handled by loop=true
            break;
        case PreviewMode::PLAY_NEXT:
            if (players.size() > 1) {
                size_t nextIndex = (currentIndex + 1) % players.size();
                ofLogNotice("ofxMediaPool") << "Playing next media: " << nextIndex;
                
                // Get next player and validate it's available
                MediaPlayer* nextPlayer = players[nextIndex].get();
                if (nextPlayer && (nextPlayer->isAudioLoaded() || nextPlayer->isVideoLoaded())) {
                    // Set as active player and connect to outputs
                    setActivePlayer(nextIndex);
                    
                    // Reset and prepare for playback
                    nextPlayer->stop();
                    nextPlayer->position.set(0.0f);
                    
                    // Re-enable audio/video if they were loaded
                    if (nextPlayer->isAudioLoaded()) {
                        nextPlayer->audioEnabled.set(true);
                    }
                    if (nextPlayer->isVideoLoaded()) {
                        nextPlayer->videoEnabled.set(true);
                    }
                    
                    // Set loop to false for PLAY_NEXT mode
                    nextPlayer->loop.set(false);
                    
                    // Start playback
                    nextPlayer->play();
                    
                    ofLogNotice("ofxMediaPool") << "Started next media " << nextIndex << " (state: MANUAL_PREVIEW)";
                } else {
                    currentMode.store(PlaybackMode::IDLE, std::memory_order_relaxed);
                }
            } else {
                if (activePlayer) {
                    activePlayer->stop();
                }
                currentMode.store(PlaybackMode::IDLE, std::memory_order_relaxed);
            }
            break;
    }
}


//--------------------------------------------------------------
// Transport listener system for Clock play/stop events
void MediaPool::addTransportListener(TransportCallback listener) {
    std::lock_guard<std::mutex> lock(stateMutex);
    transportListener = listener;
    ofLogNotice("MediaPool") << "Transport listener added";
}

void MediaPool::removeTransportListener() {
    std::lock_guard<std::mutex> lock(stateMutex);
    transportListener = nullptr;
    ofLogNotice("MediaPool") << "Transport listener removed";
}

void MediaPool::onTransportChanged(bool isPlaying) {
    std::lock_guard<std::mutex> lock(stateMutex);
    
    if (isPlaying != lastTransportState) {
        lastTransportState = isPlaying;
        
        if (!isPlaying) {
            // Transport stopped - reset gate timer and transition to IDLE
            if (currentMode.load(std::memory_order_relaxed) == PlaybackMode::SEQUENCER_ACTIVE) {
                gateTimerActive = false;
                currentMode.store(PlaybackMode::IDLE, std::memory_order_relaxed);
                
                if (activePlayer && activePlayer->isPlaying()) {
                    activePlayer->stop();
                }
            }
        }
        
        if (transportListener) {
            transportListener(isPlaying);
        }
    }
}

//--------------------------------------------------------------
// Module interface implementation
//--------------------------------------------------------------
std::string MediaPool::getName() const {
    return "MediaPool";
}

ModuleType MediaPool::getType() const {
    return ModuleType::INSTRUMENT;
}

std::vector<ParameterDescriptor> MediaPool::getParameters() {
    std::vector<ParameterDescriptor> params;
    
    // MediaPool parameters that can be controlled by TrackerSequencer
    // These are the parameters that TrackerSequencer sends in trigger events
    // MediaPool maps these to MediaPlayer parameters
    params.push_back(ParameterDescriptor("note", ParameterType::INT, 0.0f, 127.0f, 0.0f, "Note/Media Index"));
    params.push_back(ParameterDescriptor("position", ParameterType::FLOAT, 0.0f, 1.0f, 0.0f, "Position"));
    params.push_back(ParameterDescriptor("speed", ParameterType::FLOAT, -10.0f, 10.0f, 1.0f, "Speed"));
    params.push_back(ParameterDescriptor("volume", ParameterType::FLOAT, 0.0f, 2.0f, 1.0f, "Volume"));
    params.push_back(ParameterDescriptor("pitch", ParameterType::FLOAT, 0.5f, 2.0f, 1.0f, "Pitch"));
    params.push_back(ParameterDescriptor("loopStart", ParameterType::FLOAT, 0.0f, 1.0f, 0.0f, "Loop Start"));
    params.push_back(ParameterDescriptor("loopEnd", ParameterType::FLOAT, 0.0f, 1.0f, 1.0f, "Loop End"));
    
    return params;
}

void MediaPool::setParameter(const std::string& paramName, float value, bool notify) {
    // Continuous parameter modulation (for modulators, envelopes, etc.)
    // For MediaPool, we apply this to the active player
    // MODULAR: Use parameter mapping system instead of hardcoded checks
    if (!activePlayer) return;
    
    // Get parameter descriptor to validate range
    auto paramDescriptors = getParameters();
    const ParameterDescriptor* paramDesc = nullptr;
    for (const auto& param : paramDescriptors) {
        if (param.name == paramName) {
            paramDesc = &param;
            break;
        }
    }
    
    // Clamp value to parameter range if descriptor found
    float clampedValue = value;
    if (paramDesc) {
        clampedValue = std::max(paramDesc->minValue, std::min(paramDesc->maxValue, value));
    }
    
    float oldValue = 0.0f;
    bool valueChanged = false;
    
    // MODULAR: Map parameter name to MediaPlayer parameter using a mapping function
    // This is cleaner than hardcoded if/else and easier to extend
    auto applyParameterToPlayer = [&](const std::string& name, float val) -> bool {
        if (name == "volume") {
            oldValue = activePlayer->volume.get();
            activePlayer->volume.set(val);
            return std::abs(oldValue - val) > PARAMETER_EPSILON;
        } else if (name == "speed") {
            oldValue = activePlayer->speed.get();
            activePlayer->speed.set(val);
            return std::abs(oldValue - val) > PARAMETER_EPSILON;
        } else if (name == "pitch") {
            oldValue = activePlayer->pitch.get();
            activePlayer->pitch.set(val);
            return std::abs(oldValue - val) > PARAMETER_EPSILON;
        } else if (name == "loopStart") {
            oldValue = activePlayer->loopStart.get();
            activePlayer->loopStart.set(val);
            return std::abs(oldValue - val) > PARAMETER_EPSILON;
        } else if (name == "loopEnd") {
            oldValue = activePlayer->loopEnd.get();
            activePlayer->loopEnd.set(val);
            return std::abs(oldValue - val) > PARAMETER_EPSILON;
        } else if (name == "position") {
            // Position has special handling: set both startPosition and position
            // When setting position via ParameterSync, we're setting the startPosition (for sync with tracker)
            // PERFORMANCE CRITICAL: Update position parameter for UI display, but rely on onPositionChanged() checks
            // to prevent expensive setPosition() calls when position is already correct
            oldValue = activePlayer->startPosition.get();
            if (std::abs(oldValue - val) > PARAMETER_EPSILON) {
                activePlayer->startPosition.set(val);
                // Update position parameter for UI display (shows the target start position when paused)
                // The onPositionChanged() listener will check if actual video position needs to change
                // and only call expensive setPosition() if there's a significant difference (POSITION_THRESHOLD)
                float currentPos = activePlayer->position.get();
                if (std::abs(currentPos - val) > POSITION_EPSILON) {
                    activePlayer->position.set(val);
                }
                return true;
            }
            return false;
        }
        // Unknown parameter - return false (not applied)
        return false;
    };
    
    valueChanged = applyParameterToPlayer(paramName, clampedValue);
    
    // Notify parameter change callback if set and value changed
    if (notify && valueChanged && parameterChangeCallback) {
        parameterChangeCallback(paramName, clampedValue);
    }
    
    // Note: "note" parameter can't be set continuously - it's only for triggers
}

void MediaPool::subscribeToTrackerSequencer(TrackerSequencer* sequencer) {
    if (!sequencer) {
        ofLogError("MediaPool") << "Cannot subscribe to null TrackerSequencer";
        return;
    }
    
    // Subscribe to trigger events - this is the modular connection!
    ofAddListener(sequencer->triggerEvent, this, &MediaPool::onTrigger);
}

void MediaPool::onTrigger(TriggerEvent& event) {
    // LOCK-FREE: Push event to queue from audio thread (minimal logging only)
    // This is called from audio thread via ofNotifyEvent, so we must not block
    
    // Apply position memory: If retriggering same media without specified position,
    // use stored position (continue from where it left off, even after gate ends)
    auto noteIt = event.parameters.find("note");
    if (noteIt != event.parameters.end() && noteIt->second >= 0) {
        int mediaIndex = (int)noteIt->second;
        
        // Check if position parameter is not explicitly set
        if (event.parameters.find("position") == event.parameters.end()) {
            // Check if we have a stored position for this media index
            auto posIt = lastPositionByMediaIndex.find(mediaIndex);
            if (posIt != lastPositionByMediaIndex.end()) {
                // Use stored position (position memory)
                event.parameters["position"] = posIt->second;
                ofLogNotice("MediaPool") << "[POSITION_MEMORY] Using stored position for media " 
                                         << mediaIndex << ": " << posIt->second;
            }
        }
    }
    
    // Lock-free queue push (std::queue is thread-safe for single producer, single consumer)
    // We use a mutex only for queue access, but this is minimal overhead
    {
        std::lock_guard<std::mutex> queueLock(stateMutex);
        eventQueue.push(event);
    }
}


#pragma once

#include "ofxSoundObjects.h"
#include "ofxVisualObjects.h"
#include "Module.h"
#include <vector>
#include <memory>
#include <string>
#include <mutex>
#include <atomic>
#include <queue>
#include <map>

// Forward declarations to avoid circular dependency
class MediaPlayer;
class Clock;

// Playback state machine enum
// NOTE: This represents MediaPool's LOCAL playback mode, NOT global transport state.
// MediaPool can be in different modes regardless of Clock transport state:
// - IDLE: No media playing (can occur while Clock is playing or stopped)
// - MANUAL_PREVIEW: User-triggered preview (can occur while Clock is stopped)
// - SEQUENCER_ACTIVE: Sequencer-triggered playback (requires Clock to be playing)
// This is a different concern than transport state - it answers "What is MediaPool doing?"
// rather than "Is the global transport playing?" (which comes from Clock).
enum class PlaybackMode {
    IDLE,              // No playback active
    MANUAL_PREVIEW,    // GUI-triggered preview playback
    SEQUENCER_ACTIVE   // Sequencer-triggered playback
};

enum class PreviewMode {
    STOP_AT_END,    // Stop when media finishes
    LOOP,           // Loop the current media
    PLAY_NEXT       // Play next media in pool
};

// Note: StepTriggerParams and TriggerEventData removed - using TriggerEvent directly from Module.h

class MediaPool : public Module {
public:
    // Constructor with optional directory
    MediaPool(const std::string& dataDir = "data");
    ~MediaPool();
    
    // Scan directory for media files
    void scanDirectory(const std::string& path);
    
    // Set custom absolute path (bypasses automatic path resolution)
    void setCustomPath(const std::string& absolutePath);
    
    // File pairing strategy
    void mediaPair();      // Match by base filename
    void pairByIndex();    // Pair in order (1st audio + 1st video, etc.)
    
    // Access media players
    MediaPlayer* getMediaPlayer(size_t index);
    MediaPlayer* getMediaPlayerByName(const std::string& name);
    MediaPlayer* getCurrentPlayer();
    MediaPlayer* getNextPlayer();
    MediaPlayer* getPreviousPlayer();
    
    // Navigation
    void setCurrentIndex(size_t index);
    void nextPlayer();
    void previousPlayer();
    
    // Library info
    size_t getNumPlayers() const;
    size_t getCurrentIndex() const;
    std::string getMediaDirectory() const;
    std::vector<std::string> getPlayerNames() const;
    std::vector<std::string> getPlayerFileNames() const;  // Get actual file names
    
    // Audio/video files
    std::vector<std::string> getAudioFiles() const;
    std::vector<std::string> getVideoFiles() const;
    
    // File management
    void clear();
    void refresh();
    
    // Setup method
    void setup(Clock* clockRef);
    
    // Subscribe to TrackerSequencer trigger events (modular connection)
    void subscribeToTrackerSequencer(class TrackerSequencer* sequencer);
    
    // Process lock-free event queue (called from update in GUI thread)
    // Queue contains TriggerEvent instances from sequencer
    void processEventQueue();
    
    // Module interface implementation
    std::string getName() const override;
    ModuleType getType() const override;
    std::vector<ParameterDescriptor> getParameters() override;
    void onTrigger(TriggerEvent& event) override;
    void setParameter(const std::string& paramName, float value, bool notify = true) override;
    
    // Manual media playback (for GUI preview)
    bool playMediaManual(size_t index, float position = 0.0f);
    // stopManualPreview() removed - update() automatically transitions MANUAL_PREVIEW â†’ IDLE when player stops
    
    // Query methods for state checking
    PlaybackMode getCurrentMode() const;
    bool isSequencerActive() const;
    bool isManualPreview() const;
    bool isIdle() const;
    
    // Helper to transition to IDLE mode immediately (for button handlers)
    void setModeIdle();
    
    // Preview mode control
    void setPreviewMode(PreviewMode mode);
    PreviewMode getPreviewMode() const;
    void onManualPreviewEnd();
    
    // Update method for end-of-media detection
    void update() override;
    
    // Transport listener system for Clock play/stop events
    typedef std::function<void(bool isPlaying)> TransportCallback;
    void addTransportListener(TransportCallback listener);
    void removeTransportListener();
    void onTransportChanged(bool isPlaying);
    
    // Connection management (internal)
    void setActivePlayer(size_t index);
    MediaPlayer* getActivePlayer();
    void connectActivePlayer(ofxSoundOutput& soundOut, ofxVisualOutput& visualOut);
    void disconnectActivePlayer();
    bool isPlayerConnected() const { return playerConnected; }
    void stopAllMedia();
    
    // Initialize first active player after setup is complete
    void initializeFirstActivePlayer();
    
    
    // Directory management
    void setDataDirectory(const std::string& path);
    void browseForDirectory();
    std::string getDataDirectory() const { return dataDirectory; }
    
    // Directory change callback
    std::function<void(const std::string&)> onDirectoryChanged;
    void setDirectoryChangeCallback(std::function<void(const std::string&)> callback) { onDirectoryChanged = callback; }
    
    
    
private:
    Clock* clock;
    std::vector<std::unique_ptr<MediaPlayer>> players;
    std::vector<std::string> audioFiles;
    std::vector<std::string> videoFiles;
    size_t currentIndex;
    std::string dataDirectory;
    bool isSetup;
    
    // Thread safety
    mutable std::mutex stateMutex;
    
    // Lock-free event queue for audio thread -> GUI thread communication
    // Uses TriggerEvent directly (from Module.h) - no redundant data structures
    std::queue<TriggerEvent> eventQueue;
    
    // Playback state machine (atomic for lock-free reads)
    std::atomic<PlaybackMode> currentMode;
    PreviewMode currentPreviewMode;
    
    // Connection state
    MediaPlayer* activePlayer;
    bool playerConnected;  // Track if player is already connected to avoid reconnecting every frame
    
    // Transport listener system
    TransportCallback transportListener;
    bool lastTransportState;
    
    // Position memory: Store last playback position per media index
    // This allows position consistency when retriggering same media without position instructions
    std::map<int, float> lastPositionByMediaIndex;
    
    // Track last playing state to detect when player stops (for position capture)
    std::map<int, bool> lastPlayingStateByMediaIndex;
    
    // Gate timer tracking for sequencer-triggered playback
    bool gateTimerActive;
    float gateEndTime;
    
    // Parameter change callback (inherited from Module base class)
    // Note: MediaPool inherits parameterChangeCallback from Module
    
    // Helper methods
    std::string getBaseName(const std::string& filename);
    void scanMediaFiles(const std::string& path, ofDirectory& dir);  // Extract duplicate logic
    bool isAudioFile(const std::string& filename);
    bool isVideoFile(const std::string& filename);
    
    // Position and parameter comparison thresholds
    static constexpr float POSITION_EPSILON = 0.001f;      // Small difference threshold for position comparisons
    static constexpr float POSITION_THRESHOLD = 0.01f;     // Significant position threshold (for video seeking, position memory)
    static constexpr float PARAMETER_EPSILON = 0.001f;     // Small difference threshold for parameter comparisons
    
};
#include "MediaPoolGUI.h"
#include "MediaPool.h"
#include "MediaPlayer.h"
#include "ParameterCell.h"
#include "Module.h"

MediaPoolGUI::MediaPoolGUI() 
    : mediaPool(nullptr), waveformHeight(100.0f), parentWidgetId(0), 
      isParentWidgetFocused(false), requestFocusMoveToParentWidget(false),
      editingColumnIndex(-1), shouldFocusFirstCell(false), shouldRefocusCurrentCell(false),
      anyCellFocusedThisFrame(false) {
    // Initialize search buffer
    memset(searchBuffer, 0, sizeof(searchBuffer));
    searchFilter = "";
}

void MediaPoolGUI::setMediaPool(MediaPool& pool) {
    mediaPool = &pool;
}

std::string MediaPoolGUI::truncateTextToWidth(const std::string& text, float maxWidth, bool showEnd, const std::string& ellipsis) {
    if (maxWidth <= 0.0f) return text;
    
    ImVec2 textSize = ImGui::CalcTextSize(text.c_str());
    if (textSize.x <= maxWidth) return text;
    
    float ellipsisWidth = ImGui::CalcTextSize(ellipsis.c_str()).x;
    float maxTextWidth = maxWidth - ellipsisWidth;
    
    if (showEnd) {
        // Truncate from start: show end of text with ellipsis prefix
        std::string result = text;
        while (result.length() > 0) {
            ImVec2 testSize = ImGui::CalcTextSize(result.c_str());
            if (testSize.x <= maxTextWidth) break;
            result = result.substr(1); // Remove first character
        }
        return ellipsis + result;
    } else {
        // Truncate from end: show start of text with ellipsis suffix
        // Quick estimate to reduce iterations for very long strings
        float avgCharWidth = textSize.x / text.length();
        int estimatedChars = (int)(maxTextWidth / avgCharWidth);
        std::string result = text.substr(0, std::max(0, estimatedChars - 1));
        
        // Refine by checking actual width (usually only 1-2 iterations needed)
        while (result.length() > 0) {
            ImVec2 testSize = ImGui::CalcTextSize(result.c_str());
            if (testSize.x <= maxTextWidth) break;
            result.pop_back();
        }
        
        return result + ellipsis;
    }
}

void MediaPoolGUI::draw() {



    // Draw parameter editing section
    drawParameters();
    ImGui::Separator();
     
    // Draw waveform at bottom
    drawWaveform(); 
    
    
    // Reserve space for waveform at bottom, then draw media list in remaining space
    float availableHeight = ImGui::GetContentRegionAvail().y;
    int waveformSpace = waveformHeight + 10; // Extra space for waveform controls
    
    // Draw media list in scrollable area wita reserved space for waveform
    ImGui::BeginChild("MediaList", ImVec2(0, availableHeight - waveformSpace), true);
    drawMediaList();
    ImGui::EndChild();
    
    drawSearchBar();
    drawDirectoryControls();

    ImGui::Separator();
    // Preview Mode Controls - TEMPORARY : Should be moved to a separate function
    ImGui::Text("Preview Mode :");
    PreviewMode currentMode = mediaPool->getPreviewMode();
    ImGui::SameLine();
    if (ImGui::RadioButton("Once", currentMode == PreviewMode::STOP_AT_END)) {
        mediaPool->setPreviewMode(PreviewMode::STOP_AT_END);
    }
    ImGui::SameLine();
    if (ImGui::RadioButton("Loop", currentMode == PreviewMode::LOOP)) {
        mediaPool->setPreviewMode(PreviewMode::LOOP);
    }
    ImGui::SameLine();
    if (ImGui::RadioButton("Play Next", currentMode == PreviewMode::PLAY_NEXT)) {
        mediaPool->setPreviewMode(PreviewMode::PLAY_NEXT);
    }
}

void MediaPoolGUI::drawDirectoryControls() {
    if (ImGui::Button("Browse Directory")) {
        mediaPool->browseForDirectory();
    }
    ImGui::SameLine();
    std::string displayPath = mediaPool->getDataDirectory();
    
    // Calculate available width after button (account for spacing)
    float availableWidth = ImGui::GetContentRegionAvail().x - ImGui::GetStyle().ItemSpacing.x;
    if (availableWidth > 0.0f) {
        // For directory paths, show the end (directory name) rather than the beginning
        displayPath = truncateTextToWidth(displayPath, availableWidth, true);
    }
    
    ImGui::Text("%s", displayPath.c_str());
    ImGui::Separator();
}

void MediaPoolGUI::drawSearchBar() {
    ImGui::Text("Search:");
    ImGui::SameLine();
    if (ImGui::InputText("##search", searchBuffer, sizeof(searchBuffer))) {
        searchFilter = std::string(searchBuffer);
    }
    ImGui::Separator();
}

void MediaPoolGUI::drawMediaList() {
    // Create a focusable parent widget BEFORE the list for navigation
    // This widget can receive focus when exiting the list via Ctrl+Enter or UP key on first item
    ImGui::PushID("MediaListParent");
    
    // Following ImGui pattern: SetKeyboardFocusHere(0) BEFORE creating widget to request focus
    if (requestFocusMoveToParentWidget) {
        ImGui::SetKeyboardFocusHere(0); // Request focus for the upcoming widget
        // Set flag immediately so InputRouter can see it in the same frame
        // (SetKeyboardFocusHere takes effect next frame, but we want InputRouter to know now)
        isParentWidgetFocused = true;
    }
    
    // Create an invisible, focusable button that acts as the parent widget
    // This allows us to move focus here when exiting the list
    // Arrow keys will navigate to other widgets in the panel when this is focused
    ImGui::InvisibleButton("##MediaListParent", ImVec2(100, 20));
    parentWidgetId = ImGui::GetItemID(); // Store ID for potential future use
    
    // Following ImGui pattern: SetItemDefaultFocus() AFTER creating widget to mark as default
    if (requestFocusMoveToParentWidget) {
        ImGui::SetItemDefaultFocus(); // Mark this widget as the default focus
        requestFocusMoveToParentWidget = false; // Clear flag after using it
    }
    
    // Check if parent widget is focused right after creating it (ImGui pattern: IsItemFocused() works for last item)
    // This updates the state if focus has already moved (e.g., from previous frame's request)
    if (!isParentWidgetFocused) {
        // Only check if we didn't just set it above (to avoid overwriting)
        isParentWidgetFocused = ImGui::IsItemFocused();
    }
    
    // Label for the media list - make it non-navigable
    // This prevents clicking on the title from triggering list focus
    ImGui::PushItemFlag(ImGuiItemFlags_NoNav, true); // Prevent navigation to this text
    ImGui::Text("Available Media:");
    ImGui::PopItemFlag(); // Restore navigation flag
    ImGui::PopID();
    
    // Track if any list item is focused (to update parent widget focus state)
    bool anyListItemFocused = false;
    
    // Get current index for auto-scrolling
    size_t currentIndex = mediaPool->getCurrentIndex();
    
    // Track if index changed to determine if we should sync scroll
    bool shouldSyncScroll = (currentIndex != previousMediaIndex);
    
    // Show indexed media list with actual file names
    if (mediaPool->getNumPlayers() > 0) {
        auto playerNames = mediaPool->getPlayerNames();
        auto playerFileNames = mediaPool->getPlayerFileNames();
        
        for (size_t i = 0; i < playerNames.size(); i++) {
            // Filter by search term
            if (!searchFilter.empty()) {
                std::string lowerName = playerNames[i];
                std::string lowerSearch = searchFilter;
                std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);
                std::transform(lowerSearch.begin(), lowerSearch.end(), lowerSearch.begin(), ::tolower);
                
                // Also check file names if available
                bool nameMatches = (lowerName.find(lowerSearch) != std::string::npos);
                bool fileMatches = false;
                if (i < playerFileNames.size() && !playerFileNames[i].empty()) {
                    std::string lowerFileName = playerFileNames[i];
                    std::transform(lowerFileName.begin(), lowerFileName.end(), lowerFileName.begin(), ::tolower);
                    fileMatches = (lowerFileName.find(lowerSearch) != std::string::npos);
                }
                
                if (!nameMatches && !fileMatches) {
                    continue; // Skip non-matching items
                }
            }
            
            auto player = mediaPool->getMediaPlayer(i);
            if (player) {
                // Check if this is the currently active player
                bool isActive = (mediaPool->getActivePlayer() == player);
                bool isPlaying = (player->isPlaying());
                
                // Create clean display format: [01] [AV] Title
                std::string indexStr = "[" + std::to_string(i + 1); // Start at 01, not 00
                if (indexStr.length() < 3) {
                    indexStr = "[" + std::string(2 - (indexStr.length() - 1), '0') + std::to_string(i + 1);
                }
                indexStr += "]";
                
                // Get media type badge
                std::string mediaType = "";
                if (player->isAudioLoaded() && player->isVideoLoaded()) {
                    mediaType = "[AV]";
                } else if (player->isAudioLoaded()) {
                    mediaType = "[A]";
                } else if (player->isVideoLoaded()) {
                    mediaType = "[V]";
                } else {
                    mediaType = "--";
                }
                
                // Get clean title from file names
                std::string title = "";
                if (i < playerFileNames.size() && !playerFileNames[i].empty()) {
                    // Use the file name as title, remove extension
                    title = ofFilePath::getBaseName(playerFileNames[i]);
                } else {
                    // Fallback to player name if no file name
                    title = playerNames[i];
                }
                
                // Truncate title if too long for available width
                float availableWidth = ImGui::GetContentRegionAvail().x;
                if (availableWidth > 0.0f) {
                    // Calculate width of prefix: "[01] [AV] "
                    std::string prefix = indexStr + " " + mediaType + " ";
                    float prefixWidth = ImGui::CalcTextSize(prefix.c_str()).x;
                    float maxTitleWidth = availableWidth - prefixWidth - 20.0f; // Reserve padding
                    
                    if (maxTitleWidth > 0.0f) {
                        title = truncateTextToWidth(title, maxTitleWidth);
                    }
                }
                
                // Clean display name: [01] [AV] Title
                std::string displayName = indexStr + " " + mediaType + " " + title;
                
                // Visual styling for active and playing media
                if (isActive) {
                    ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.1f, 0.1f, 0.9f, 0.6f)); // Blue or Orange background for active
                }
                if (isPlaying) {
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.7f, 1.0f, 0.7f, 1.0f)); // Green for playing
                }
                
                // Make items selectable and clickable
                if (ImGui::Selectable(displayName.c_str(), isActive)) {
                    // Use playMediaManual to set MANUAL_PREVIEW mode and play from start
                    bool success = mediaPool->playMediaManual(i, 0.0f);  // Always play from start (position 0.0)
                    if (!success) {
                        ofLogWarning("MediaPoolGUI") << "Failed to play media at index " << i;
                    }
                }
                
                // Auto-scroll to current playing media at top of list
                // Only sync scroll when media index changes (allows user scrolling otherwise)
                if (i == currentIndex && shouldSyncScroll) {
                    ImGui::SetScrollHereY(0.0f); // 0.0 = top of visible area
                }
                
                // Track if any list item is focused
                if (ImGui::IsItemFocused()) {
                    anyListItemFocused = true;
                }
                
                // Add hover tooltip with video frame preview
                if (ImGui::IsItemHovered()) {
                    ImGui::BeginTooltip();
                    
                    // Show video frame if available
                    if (player->isVideoLoaded()) {
                        ofTexture videoTexture = player->getVideoPlayer().getVideoFile().getTexture();
                        if (videoTexture.isAllocated()) {
                            // Display video frame as tooltip
                            ImGui::Image((void*)(intptr_t)videoTexture.getTextureData().textureID, 
                                        ImVec2(160, 90), // Preview size
                                        ImVec2(0, 0), ImVec2(1, 1)); // Normal orientation (no flip)
                            
                            // Show basic info below the frame
                            ImGui::Text("Index: %zu", i);
                            ImGui::Text("Status: %s", player->isPlaying() ? "Playing" : "Stopped");
                        } else {
                            // Fallback to metadata if no video frame available
                            ImGui::Text("Index: %zu", i);
                            ImGui::Text("Video: %s", player->isVideoLoaded() ? "Loaded" : "Not loaded");
                            ImGui::Text("Status: %s", player->isPlaying() ? "Playing" : "Stopped");
                        }
                    } else {
                        // Show audio-only info
                        ImGui::Text("Index: %zu", i);
                        ImGui::Text("Audio: %s", player->isAudioLoaded() ? "Loaded" : "Not loaded");
                        ImGui::Text("Status: %s", player->isPlaying() ? "Playing" : "Stopped");
                    }
                    
                    ImGui::Text("Click to play/pause");
                    ImGui::EndTooltip();
                }
                
                // Add right-click context menu
                if (ImGui::BeginPopupContextItem(("MediaContext" + std::to_string(i)).c_str())) {
                    ImGui::Text("Media %zu", i);
                    ImGui::Separator();
                    
                    if (ImGui::MenuItem("Play/Preview", "Click")) {
                        // Stop all other players first
                        for (size_t j = 0; j < mediaPool->getNumPlayers(); j++) {
                            auto otherPlayer = mediaPool->getMediaPlayer(j);
                            if (otherPlayer && otherPlayer != player) {
                                otherPlayer->stop();
                            }
                        }
                        mediaPool->setActivePlayer(i);
                        player->play();
                    }
                    
                    if (ImGui::MenuItem("Stop", "")) {
                        player->stop();
                    }
                    
                    ImGui::Separator();
                    
                    if (ImGui::MenuItem("Set Position 0%")) {
                        player->setPosition(0.0f);
                    }
                    if (ImGui::MenuItem("Set Position 50%")) {
                        player->setPosition(0.5f);
                    }
                    
                    ImGui::EndPopup();
                }
                
                // Pop style colors if we pushed them
                if (isPlaying) {
                    ImGui::PopStyleColor();
                }
                if (isActive) {
                    ImGui::PopStyleColor();
                }
                
                // Status indicators are now included in the main display name
            }
        }
    ImGui::Separator();
    }
    
    // Update previous index after processing list (for scroll sync on next frame)
    previousMediaIndex = currentIndex;
    
    // CRITICAL: Update parent widget focus state AFTER the list ends
    // Following ImGui pattern: We can't check IsItemFocused() for a widget created earlier,
    // so we infer the state based on what we know:
    // - If any list item was focused, parent widget is definitely not focused
    // - If no list item is focused, we might be on parent widget
    // - The state checked right after creating the button is still valid if no items were focused
    if (anyListItemFocused) {
        // A list item is focused, so parent widget is definitely not focused
        isParentWidgetFocused = false;
    }
    // Otherwise, keep the state we checked right after creating the button
    // This follows ImGui's pattern: IsItemFocused() is only valid for the last item,
    // so we rely on the state we captured when the widget was created

}

void MediaPoolGUI::drawWaveform() {
    
    auto currentPlayer = mediaPool->getActivePlayer();
    if (currentPlayer) {
        
        // Create invisible button for interaction area
        ImVec2 canvasSize = ImVec2(-1, waveformHeight);
        ImGui::InvisibleButton("waveform_canvas", canvasSize);
        
        // Get draw list for custom rendering
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        ImVec2 canvasPos = ImGui::GetItemRectMin();
        ImVec2 canvasMax = ImGui::GetItemRectMax();
        
        // Calculate proper playhead position
        float playheadPosition = 0.0f;
        bool showPlayhead = false;
        
        // Always use the position parameter as the single source of truth
        // This ensures consistency between playing and non-playing states
        float mediaPosition = currentPlayer->position.get();
            if (mediaPosition > 0.0f || currentPlayer->isPlaying()) {
                playheadPosition = mediaPosition;
                showPlayhead = true;
            }
            
            // Handle click-to-seek and drag functionality
            // IMPORTANT: Check IsItemHovered OR IsItemActive to support dragging
            // IsItemActive ensures dragging continues even if mouse moves outside hover area
            if (ImGui::IsItemHovered() || ImGui::IsItemActive()) {
                // Show cursor as hand when hovering over waveform
                if (ImGui::IsItemHovered()) {
                ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                }
                
                // Check for mouse click or drag
                if (ImGui::IsMouseClicked(0)) {
                    // Click: seek to position and handle playback appropriately
                    ImVec2 mousePos = ImGui::GetMousePos();
                    float relativeX = (mousePos.x - canvasPos.x) / (canvasMax.x - canvasPos.x);
                    
                    if (relativeX >= 0.0f && relativeX <= 1.0f) {
                        auto player = mediaPool->getActivePlayer();
                        if (player) {
                            // When scrubbing, update both startPosition and position
                            // This allows editing the start position while paused
                            player->startPosition.set(relativeX);
                            // Only update position if not playing (to avoid triggering onPositionChanged feedback loop)
                            if (!player->isPlaying()) {
                            player->position.set(relativeX);
                            }
                            // Use setParameter to trigger synchronization notifications
                            mediaPool->setParameter("position", relativeX, true);
                            
                            // If player is not playing, start it; otherwise it will continue from new position
                            if (!player->isPlaying()) {
                                mediaPool->playMediaManual(mediaPool->getCurrentIndex(), relativeX);
                            }
                        }
                    }
                } else if (ImGui::IsMouseDragging(0)) {
                    // Drag: scrub - seek to position during playback
                    ImVec2 mousePos = ImGui::GetMousePos();
                    float relativeX = (mousePos.x - canvasPos.x) / (canvasMax.x - canvasPos.x);
                    
                    // Clamp to valid range
                    relativeX = std::max(0.0f, std::min(1.0f, relativeX));
                    
                    if (relativeX >= 0.0f && relativeX <= 1.0f) {
                        auto player = mediaPool->getActivePlayer();
                        if (player) {
                            // Update startPosition for future triggers
                            player->startPosition.set(relativeX);
                            
                            // IMPORTANT: For scrubbing during playback, we need to seek directly
                            // onPositionChanged() prevents seeking during playback to avoid feedback loops,
                            // but scrubbing is an explicit user action, so we bypass it
                            if (player->isAudioLoaded()) {
                                player->getAudioPlayer().setPosition(relativeX);
                            }
                            if (player->isVideoLoaded()) {
                                player->getVideoPlayer().getVideoFile().setPosition(relativeX);
                                // Update video after seeking (needed for HAP codec)
                                player->getVideoPlayer().getVideoFile().update();
                            }
                            
                            // Update position parameter for UI display (without triggering expensive seek)
                            // We already set the actual playback position above
                            player->position.set(relativeX);
                            
                            // Use setParameter to trigger synchronization notifications
                            mediaPool->setParameter("position", relativeX, true);
                        }
                    }
                }
            }
            
            // Draw waveform area
            float canvasWidth = canvasMax.x - canvasPos.x;
            float canvasHeight = canvasMax.y - canvasPos.y;
            float centerY = canvasPos.y + canvasHeight * 0.5f;
            
            // Check if we have audio data to draw waveform
            bool hasAudioData = false;
            int numChannels = 0;
            int actualPoints = 0;
            static std::vector<float> timeData;
            static std::vector<std::vector<float>> channelData;
            
            if (currentPlayer->isAudioLoaded()) {
                // Get audio buffer data
                ofSoundBuffer buffer = currentPlayer->getAudioPlayer().getBuffer();
                int numFrames = buffer.getNumFrames();
                numChannels = buffer.getNumChannels();
                
                if (numFrames > 0 && numChannels > 0) {
                    hasAudioData = true;
                    
                    // Prepare data for ImDrawList - much more efficient than manual drawing
                    // Resize vectors if needed
                    int maxPoints = MAX_WAVEFORM_POINTS;
                    int stepSize = std::max(1, numFrames / maxPoints);
                    actualPoints = std::min(maxPoints, numFrames / stepSize);
                    
                    timeData.resize(actualPoints);
                    channelData.resize(numChannels);
                    for (int ch = 0; ch < numChannels; ch++) {
                        channelData[ch].resize(actualPoints);
                    }
                    
                    // Downsample audio data
                    for (int i = 0; i < actualPoints; i++) {
                        int sampleIndex = i * stepSize;
                        if (sampleIndex < numFrames) {
                            timeData[i] = (float)i / (float)actualPoints; // Normalized time 0-1
                            
                            for (int ch = 0; ch < numChannels; ch++) {
                                channelData[ch][i] = buffer.getSample(sampleIndex, ch);
                            }
                        }
                    }
                }
            }
            

            // Draw fallback transparent black rectangle for video-only players
            ImU32 bgColor = IM_COL32(0, 0, 0, 100); // Semi-transparent black
            drawList->AddRectFilled(canvasPos, canvasMax, bgColor);
            
            if (hasAudioData) {
                // Draw actual waveform
                float amplitudeScale = canvasHeight * 0.4f; // Use 80% of height for amplitude
                
                // Draw each channel with white color
                for (int ch = 0; ch < numChannels; ch++) {
                    ImU32 lineColor = IM_COL32(255, 255, 255, 255); // White
                    
                    for (int i = 0; i < actualPoints - 1; i++) {
                        float x1 = canvasPos.x + timeData[i] * canvasWidth;
                        float y1 = centerY - channelData[ch][i] * amplitudeScale;
                        float x2 = canvasPos.x + timeData[i + 1] * canvasWidth;
                        float y2 = centerY - channelData[ch][i + 1] * amplitudeScale;
                        
                        drawList->AddLine(ImVec2(x1, y1), ImVec2(x2, y2), lineColor, 1.0f);
                    }
                }
            }
            
            // Draw playhead with green color (always show if we have a position)
            if (showPlayhead) {
                float playheadX = canvasPos.x + playheadPosition * canvasWidth;
                ImU32 playheadColor = IM_COL32(0, 255, 0, 255); // Green
                
                drawList->AddLine(
                    ImVec2(playheadX, canvasPos.y),
                    ImVec2(playheadX, canvasMax.y),
                    playheadColor, 3.0f
                );
            }
        
    } else {
        ImGui::Text("No active player to display waveform.");
    }
}

ParameterCell MediaPoolGUI::createParameterCellForParameter(const ParameterDescriptor& paramDesc) {
    ParameterCell cell;
    cell.parameterName = paramDesc.name;
    cell.isInteger = (paramDesc.type == ParameterType::INT);
    cell.setValueRange(paramDesc.minValue, paramDesc.maxValue, paramDesc.defaultValue);
    cell.calculateStepIncrement();
    
    auto activePlayer = mediaPool->getActivePlayer();
    
    // Set up getCurrentValue callback using MediaPlayer helper method
    cell.getCurrentValue = [paramDesc, activePlayer]() -> float {
        if (!activePlayer) return paramDesc.defaultValue;
        
        // Use MediaPlayer's helper method for cleaner parameter access
        const auto* param = activePlayer->getFloatParameter(paramDesc.name);
        if (param) {
            return param->get();
        }
        return paramDesc.defaultValue;
    };
    
    // Set up onValueApplied callback
    cell.onValueApplied = [this, paramDesc](const std::string&, float value) {
        if (mediaPool) {
            mediaPool->setParameter(paramDesc.name, value, true);
        }
    };
    
    // Set up formatValue callback (use openFrameworks ofToString for modern C++ string formatting)
    cell.formatValue = [paramDesc](float value) -> std::string {
        if (paramDesc.type == ParameterType::INT) {
            return ofToString((int)std::round(value));
        } else {
            return ofToString(value, 2); // 2 decimal places
        }
    };
    
    return cell;
}

bool MediaPoolGUI::handleParameterCellKeyPress(const ParameterDescriptor& paramDesc, int key, bool ctrlPressed, bool shiftPressed) {
    // Create ParameterCell for the parameter
    ParameterCell cell = createParameterCellForParameter(paramDesc);
    
    // Sync state from MediaPoolGUI to ParameterCell
    bool isSelected = (editingParameter == paramDesc.name);
    cell.isSelected = isSelected;
    
    // If we're entering edit mode via direct typing, enter edit mode now
    // Otherwise, use the current edit mode state
    if (isEditingParameter && !cell.isEditingMode()) {
        cell.enterEditMode();
    } else {
        cell.setEditing(isEditingParameter && isSelected);
    }
    
    if (isEditingParameter && isSelected) {
        cell.setEditBuffer(editBufferCache);
    }
    
    // Delegate keyboard handling to ParameterCell
    bool handled = cell.handleKeyPress(key, ctrlPressed, shiftPressed);
    
    if (handled) {
        // Sync edit mode state back from ParameterCell to MediaPoolGUI
        isEditingParameter = cell.isEditingMode();
        if (isEditingParameter) {
            editBufferCache = cell.getEditBuffer();
            editBufferInitializedCache = cell.isEditBufferInitialized();
        } else {
            editBufferCache.clear();
            editBufferInitializedCache = false;
        }
        
        // Disable/enable ImGui keyboard navigation based on edit mode
        ImGuiIO& io = ImGui::GetIO();
        if (isEditingParameter) {
            io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableKeyboard;
        } else {
            io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
        }
    }
    
    return handled;
}

void MediaPoolGUI::drawParameters() {
    if (!mediaPool) return;
    

    // Get available parameters from MediaPool
    auto params = mediaPool->getParameters();
    auto activePlayer = mediaPool->getActivePlayer();
    
    if (!activePlayer || params.empty()) {
        ImGui::Text("No parameters available");
        return;
    }
    
    // Filter out "note" parameter (it's not editable in the GUI, only used internally)
    // Keep parameters in their natural order from MediaPool::getParameters()
    std::vector<ParameterDescriptor> editableParams;
    for (const auto& param : params) {
        if (param.name != "note") {
            editableParams.push_back(param);
        }
    }
    
    if (editableParams.empty()) {
        ImGui::Text("No editable parameters available");
        return;
    }
    
    // Create a focusable parent widget BEFORE the table for navigation (similar to TrackerSequencer)
    ImGui::PushID("MediaPoolParametersParent");
    
    // Handle parent widget focus requests
    if (requestFocusMoveToParentWidget) {
        ImGui::SetKeyboardFocusHere(0); // Request focus for the upcoming widget
        isParentWidgetFocused = true;
        clearCellFocus();
        requestFocusMoveToParentWidget = false;
    }
    
    // Create an invisible button as the parent widget (similar to TrackerSequencer)
    ImGui::InvisibleButton("##MediaPoolParamsParent", ImVec2(0, 0));
    
    // Handle clicks on parent widget - clear cell focus when clicked
    if (ImGui::IsItemClicked(0)) {
        clearCellFocus();
        isParentWidgetFocused = true;
    }
    
    // Check if parent widget is focused
    if (ImGui::IsItemFocused()) {
        isParentWidgetFocused = true;
    } else if (isParentWidgetFocused && !ImGui::IsAnyItemFocused()) {
        // Parent widget lost focus - update state
        isParentWidgetFocused = false;
    }
    
    parentWidgetId = ImGui::GetItemID();
    ImGui::PopID();
    
    // Tracker-style table styling
    ImGui::PushStyleVar(ImGuiStyleVar_CellPadding, ImVec2(2, 2));
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(1, 1));
    
    // Table flags (responsive sizing - columns stretch to fill available width)
    // Allow column reordering with memory - columns can be moved by dragging headers
    ImGuiTableFlags flags = ImGuiTableFlags_Borders | 
                           ImGuiTableFlags_RowBg | 
                           ImGuiTableFlags_Resizable |
                           ImGuiTableFlags_Reorderable | // Allow column reordering (saved in ImGui settings)
                           ImGuiTableFlags_SizingStretchProp; // Responsive: columns stretch proportionally
    
    int totalColumns = 1 + (int)editableParams.size(); // Media index column + parameter columns
    
    // Reset focus tracking at start of frame
    anyCellFocusedThisFrame = false;
    
    // Use versioned table ID to reset column order if needed (change version number to force reset)
    // This allows us to reset saved column positions while keeping reorderability
    static int tableVersion = 1; // Increment this to reset all saved column settings
    std::string tableId = "MediaPoolParameters_v" + std::to_string(tableVersion);
    
    if (ImGui::BeginTable(tableId.c_str(), totalColumns, flags)) {
        // Setup index column: Fixed width, reorderable (user can move it, but we set it first)
        ImGui::TableSetupColumn("IDX", ImGuiTableColumnFlags_WidthFixed, 50.0f);
        
        // Setup parameter columns (stretch to fill remaining width, equal weight, reorderable)
        for (const auto& paramDesc : editableParams) {
            ImGui::TableSetupColumn(paramDesc.displayName.c_str(), ImGuiTableColumnFlags_WidthStretch, 1.0f);
        }
        
        ImGui::TableSetupScrollFreeze(0, 1);
        
        // Header row
        ImGui::TableNextRow(ImGuiTableRowFlags_Headers);
        
        // Media index column header
        ImGui::TableSetColumnIndex(0);
        ImGui::TableHeader("IDX");
        
        // Parameter column headers
        for (size_t i = 0; i < editableParams.size(); i++) {
            ImGui::TableSetColumnIndex((int)i + 1);
            ImGui::TableHeader(editableParams[i].displayName.c_str());
        }
        
        // Single data row (no steps dimension)
        ImGui::TableNextRow();
        
        // Draw media index button (first column, column index 0) - similar to step number button in TrackerSequencer
        ImGui::TableSetColumnIndex(0);
        drawMediaIndexButton(0, editableParams.size());
        
        // Draw parameter cells (remaining columns, column indices 1+)
        for (size_t i = 0; i < editableParams.size(); i++) {
            ImGui::TableSetColumnIndex((int)i + 1);
            const auto& paramDesc = editableParams[i];
            int columnIndex = (int)i + 1; // Column index (1-based for parameters)
            
            ImGui::PushID((int)(i + 2000)); // Unique ID for parameter cells
            
            // Create ParameterCell for this parameter using helper method
            ParameterCell paramCell = createParameterCellForParameter(paramDesc);
            
            // Sync state from MediaPoolGUI to ParameterCell
            bool isSelected = (editingColumnIndex == columnIndex);
            paramCell.isSelected = isSelected;
            paramCell.setEditing(isEditingParameter && isSelected);
            if (isEditingParameter && isSelected) {
                paramCell.setEditBuffer(editBufferCache);
            }
            
            // Restore drag state if this parameter is being dragged
            bool isDraggingThis = (draggingParameter == paramDesc.name);
            if (isDraggingThis) {
                paramCell.setDragState(true, dragStartY, dragStartX, lastDragValue);
            }
            
            // Determine focus state (similar to TrackerSequencer)
            bool isFocused = (editingColumnIndex == columnIndex);
            bool shouldFocusFirst = (columnIndex == 1 && shouldFocusFirstCell);
            bool shouldRefocus = (editingColumnIndex == columnIndex && shouldRefocusCurrentCell);
            
            // Draw ParameterCell (use ImGui's ID system for unique identification)
            int uniqueId = ImGui::GetID(paramDesc.name.c_str());
            
            ParameterCellInteraction interaction = paramCell.draw(uniqueId, isFocused, shouldFocusFirst, shouldRefocus);
            
            // Sync state back from ParameterCell to MediaPoolGUI (similar to TrackerSequencer)
            if (interaction.focusChanged) {
                int previousColumn = editingColumnIndex;
                editingParameter = paramDesc.name;
                editingColumnIndex = columnIndex;
                anyCellFocusedThisFrame = true;
                isParentWidgetFocused = false;
                
                // Exit edit mode if navigating to a different column
                if (previousColumn != columnIndex && isEditingParameter) {
                    isEditingParameter = false;
                    editBufferCache.clear();
                    editBufferInitializedCache = false;
                }
            }
            
            if (interaction.clicked) {
                // Cell was clicked - focus it but don't enter edit mode yet
                editingParameter = paramDesc.name;
                editingColumnIndex = columnIndex;
                isEditingParameter = false;
                anyCellFocusedThisFrame = true;
                isParentWidgetFocused = false;
            }
            
            // Sync drag state (maintain focus during drag)
            // CRITICAL: Always check drag state if we're dragging this parameter, even if mouse is outside cell
            // This ensures drag continues across entire window (Blender-style)
            if (interaction.dragStarted || interaction.dragEnded || paramCell.getIsDragging() || isDraggingThis) {
                if (paramCell.getIsDragging()) {
                    draggingParameter = paramDesc.name;
                    dragStartY = paramCell.getDragStartY();
                    dragStartX = paramCell.getDragStartX();
                    lastDragValue = paramCell.getLastDragValue();
                    // Maintain focus during drag
                    editingColumnIndex = columnIndex;
                    editingParameter = paramDesc.name;
                } else if (isDraggingThis && !paramCell.getIsDragging()) {
                    // Drag ended - clear drag state
                    draggingParameter.clear();
                }
            }
            
            // Sync edit mode state
            if (paramCell.isEditingMode()) {
                isEditingParameter = true;
                editBufferCache = paramCell.getEditBuffer();
                editBufferInitializedCache = paramCell.isEditBufferInitialized();
            } else if (isEditingParameter && isSelected && !paramCell.isEditingMode()) {
                isEditingParameter = false;
                editBufferCache.clear();
                editBufferInitializedCache = false;
            }
            
            // Clear refocus flag after using it
            if (shouldRefocus) {
                shouldRefocusCurrentCell = false;
            }
            
            ImGui::PopID();
        }
        
        // Clear shouldFocusFirstCell flag after drawing
        if (shouldFocusFirstCell) {
            shouldFocusFirstCell = false;
        }
        
        // After drawing all cells, if column is set but no cell was focused, clear focus
        if (editingColumnIndex >= 0 && !anyCellFocusedThisFrame && !isEditingParameter && !shouldRefocusCurrentCell) {
            clearCellFocus();
        }
        
        ImGui::EndTable();
    }
    
    ImGui::PopStyleVar(2);
}

void MediaPoolGUI::clearCellFocus() {
    editingColumnIndex = -1;
    editingParameter.clear();
    isEditingParameter = false;
    editBufferCache.clear();
    editBufferInitializedCache = false;
    draggingParameter.clear();
}

// Sync edit state from ImGui focus - called from InputRouter when keys are pressed
void MediaPoolGUI::syncEditStateFromImGuiFocus(MediaPoolGUI& gui) {
    // Check if editingColumnIndex is already valid (GUI sync already happened)
    if (gui.editingColumnIndex >= 0) {
        // If editingParameter is empty but editingColumnIndex is set, look it up
        if (gui.editingParameter.empty() && gui.mediaPool) {
            auto params = gui.mediaPool->getParameters();
            std::vector<ParameterDescriptor> editableParams;
            for (const auto& param : params) {
                if (param.name != "note") {
                    editableParams.push_back(param);
                }
            }
            // editingColumnIndex is 1-based for parameters (0 = media index button)
            if (gui.editingColumnIndex > 0 && (size_t)(gui.editingColumnIndex - 1) < editableParams.size()) {
                gui.editingParameter = editableParams[gui.editingColumnIndex - 1].name;
            }
        }
        return; // Already synced
    }
    
    // GUI draw sync should handle this every frame
    // If not set, handleKeyPress will default gracefully
}

void MediaPoolGUI::drawMediaIndexButton(int columnIndex, size_t numParamColumns) {
    if (!mediaPool) return;
    
    size_t currentIndex = mediaPool->getCurrentIndex();
    size_t numPlayers = mediaPool->getNumPlayers();
    auto activePlayer = mediaPool->getActivePlayer();
    
    // Format button text: show current index (1-based) or "--" if no media
    std::string indexText;
    if (numPlayers > 0) {
        int displayIndex = (int)(currentIndex + 1);
        char buf[8];
        snprintf(buf, sizeof(buf), "%02d", displayIndex);
        indexText = buf;
    } else {
        indexText = "--";
    }
    
    // Determine focus state
    bool shouldRefocus = (editingColumnIndex == columnIndex && shouldRefocusCurrentCell);
    
    if (shouldRefocus) {
        ImGui::SetKeyboardFocusHere(0);
    }
    
    // SIMPLIFIED: Button state is based on mode - supports both manual and sequencer playback
    // Button is green if media is playing (either MANUAL_PREVIEW or SEQUENCER_ACTIVE)
    // Button is grey if IDLE (stopped)
    bool isCurrentMediaPlaying = false;
    if (activePlayer != nullptr && currentIndex < numPlayers) {
        auto currentPlayer = mediaPool->getMediaPlayer(currentIndex);
        if (currentPlayer == activePlayer) {
            // Button is green if mode is MANUAL_PREVIEW OR SEQUENCER_ACTIVE
            // This syncs with both manual clicks and external sequencer triggers
            isCurrentMediaPlaying = (mediaPool->isManualPreview() || mediaPool->isSequencerActive()) 
                        && currentPlayer->isPlaying();
        }
    }
    
    // Apply button styling for active playback
    if (isCurrentMediaPlaying) {
        ImGui::PushStyleColor(ImGuiCol_Button, ImGui::GetColorU32(ImVec4(0.2f, 0.7f, 0.2f, 0.8f)));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImGui::GetColorU32(ImVec4(0.25f, 0.75f, 0.25f, 0.9f)));
    }
    
    ImGui::PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
    bool buttonClicked = ImGui::Button(indexText.c_str(), ImVec2(-1, 0));
    ImGui::PopItemFlag();
    
    if (shouldRefocus) {
        ImGui::SetKeyboardFocusHere(-1);
        ImGuiIO& io = ImGui::GetIO();
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    }
    
    if (isCurrentMediaPlaying) {
        ImGui::PopStyleColor(2);
    }
    
    // SIMPLIFIED: Handle button click - simple toggle logic
    bool spacebarPressed = ImGui::IsKeyPressed(ImGuiKey_Space, false);
    
    if (buttonClicked && !spacebarPressed && numPlayers > 0) {
        auto currentPlayer = mediaPool->getMediaPlayer(currentIndex);
        if (currentPlayer) {
            // Only toggle manual preview - don't interfere with sequencer playback
            // If sequencer is active, button click does nothing (sequencer controls playback)
            if (mediaPool->isManualPreview()) {
                // Currently in MANUAL_PREVIEW mode - stop it
                currentPlayer->stop();
                mediaPool->setModeIdle();  // Transition to IDLE immediately
            } else if (mediaPool->isIdle()) {
                // Not playing (IDLE) - start manual preview
                // Note: If SEQUENCER_ACTIVE, we don't do anything (sequencer is in control)
                float startPosition = currentPlayer->position.get();
                mediaPool->playMediaManual(currentIndex, startPosition);
            }
            // If isSequencerActive(), do nothing - sequencer controls playback
        }
    }
    
    // ONE-WAY SYNC: ImGui focus â†’ MediaPoolGUI state
    bool actuallyFocused = ImGui::IsItemFocused();
    if (actuallyFocused) {
        bool itemWasClicked = ImGui::IsItemClicked(0);
        bool keyboardNavActive = (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
        
        if (itemWasClicked || keyboardNavActive || shouldRefocus) {
            anyCellFocusedThisFrame = true;
            bool columnChanged = (editingColumnIndex != columnIndex);
            
            if (isEditingParameter && columnChanged) {
                return;
            }
            
            editingColumnIndex = columnIndex;
            editingParameter.clear();
            isParentWidgetFocused = false;
            
            if (shouldRefocus) {
                shouldRefocusCurrentCell = false;
            }
            
            if (columnChanged && isEditingParameter) {
                isEditingParameter = false;
                editBufferCache.clear();
                editBufferInitializedCache = false;
            }
        }
    }
}

bool MediaPoolGUI::handleKeyPress(int key, bool ctrlPressed, bool shiftPressed) {
    // CRITICAL FIX: If editingColumnIndex is set but editingParameter is empty,
    // look up the parameter name from the column index
    // This handles cases where focus was synced from ImGui but editingParameter wasn't set yet
    if (editingColumnIndex > 0 && editingParameter.empty() && mediaPool) {
        auto params = mediaPool->getParameters();
        // Filter out "note" parameter (it's not editable in the GUI)
        std::vector<ParameterDescriptor> editableParams;
        for (const auto& param : params) {
            if (param.name != "note") {
                editableParams.push_back(param);
            }
        }
        // editingColumnIndex is 1-based for parameters (0 = media index button)
        if (editingColumnIndex > 0 && (size_t)(editingColumnIndex - 1) < editableParams.size()) {
            editingParameter = editableParams[editingColumnIndex - 1].name;
        }
    }
    
    // Handle direct typing (numeric keys, decimal point, operators) - auto-enter edit mode
    // This matches TrackerSequencer behavior: typing directly enters edit mode
    if ((key >= '0' && key <= '9') || key == '.' || key == '-' || key == '+' || key == '*' || key == '/') {
        // Check if we have a valid parameter column focused (not media index button)
        if (!isEditingParameter && editingColumnIndex > 0) {
            // Find the parameter descriptor
            auto params = mediaPool->getParameters();
            const ParameterDescriptor* paramDesc = nullptr;
            
            // If editingParameter is set, use it; otherwise look up by column index
            if (!editingParameter.empty()) {
                for (const auto& param : params) {
                    if (param.name == editingParameter) {
                        paramDesc = &param;
                        break;
                    }
                }
            } else {
                // Look up by column index
                std::vector<ParameterDescriptor> editableParams;
                for (const auto& param : params) {
                    if (param.name != "note") {
                        editableParams.push_back(param);
                    }
                }
                if (editingColumnIndex > 0 && (size_t)(editingColumnIndex - 1) < editableParams.size()) {
                    paramDesc = &editableParams[editingColumnIndex - 1];
                    editingParameter = paramDesc->name; // Set it for future use
                }
            }
            
            if (paramDesc) {
                // Enter edit mode first (similar to TrackerSequencer)
                isEditingParameter = true;
                
                // Disable ImGui keyboard navigation when entering edit mode
                ImGuiIO& io = ImGui::GetIO();
                io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableKeyboard;
                
                // Now handle the key via helper method (which will create cell, enter edit mode, and handle key)
                // The helper method will sync state back
                return handleParameterCellKeyPress(*paramDesc, key, ctrlPressed, shiftPressed);
            }
        }
    }
    
    // If a parameter is selected and in edit mode, delegate to ParameterCell
    if (!editingParameter.empty() && isEditingParameter) {
        // Find the parameter descriptor
        auto params = mediaPool->getParameters();
        const ParameterDescriptor* paramDesc = nullptr;
        for (const auto& param : params) {
            if (param.name == editingParameter) {
                paramDesc = &param;
                break;
            }
        }
        
        if (!paramDesc) return false;
        
        // Use helper method to handle key press (reduces duplication)
        return handleParameterCellKeyPress(*paramDesc, key, ctrlPressed, shiftPressed);
    }
    
    // Handle arrow key navigation (similar to TrackerSequencer)
    // CRITICAL: In edit mode, arrow keys adjust values (don't navigate)
    if (isEditingParameter && editingColumnIndex >= 0) {
        // In edit mode: Arrow keys adjust values
        if (key == OF_KEY_UP || key == OF_KEY_DOWN || key == OF_KEY_LEFT || key == OF_KEY_RIGHT) {
            // Ensure we have the parameter descriptor
            if (!editingParameter.empty()) {
                auto params = mediaPool->getParameters();
                const ParameterDescriptor* paramDesc = nullptr;
                for (const auto& param : params) {
                    if (param.name == editingParameter) {
                        paramDesc = &param;
                        break;
                    }
                }
                if (paramDesc) {
                    return handleParameterCellKeyPress(*paramDesc, key, ctrlPressed, shiftPressed);
                }
            }
        }
    }
    
    // CRITICAL: When NOT in edit mode, let ImGui handle arrow keys for native navigation
    // We'll sync our state from ImGui focus after it processes the keys
    if (!isEditingParameter && editingColumnIndex >= 0) {
        // Not in edit mode: Let ImGui handle arrow keys for native navigation
        // This allows smooth navigation between parameter cells
        // Our state will be synced from ImGui focus in the next frame during draw()
        if (key == OF_KEY_LEFT || key == OF_KEY_RIGHT || key == OF_KEY_UP || key == OF_KEY_DOWN) {
            // Ensure ImGui navigation is enabled so it can handle the keys
            ImGuiIO& io = ImGui::GetIO();
            io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
            
            // Don't consume the key - let ImGui handle navigation
            // Our state will be synced from ImGui focus in drawParameters()
            return false;
        }
    }
    
    // Handle keyboard shortcuts for parameter navigation
    switch (key) {
        case OF_KEY_RETURN:
            if (ctrlPressed || shiftPressed) {
                // Ctrl+Enter or Shift+Enter: Exit parameter editing
                if (isEditingParameter) {
                    isEditingParameter = false;
                    editBufferCache.clear();
                    editBufferInitializedCache = false;
                    ImGuiIO& io = ImGui::GetIO();
                    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
                    shouldRefocusCurrentCell = true; // Refocus cell after exiting edit mode
                    return true;
                }
            }
            if (editingColumnIndex > 0 && !isEditingParameter) {
                // Enter on selected parameter column: Enter edit mode
                // (Column 0 is media index button, which doesn't support editing)
                
                // Ensure editingParameter is set
                if (editingParameter.empty() && mediaPool) {
                    auto params = mediaPool->getParameters();
                    std::vector<ParameterDescriptor> editableParams;
                    for (const auto& param : params) {
                        if (param.name != "note") {
                            editableParams.push_back(param);
                        }
                    }
                    if (editingColumnIndex > 0 && (size_t)(editingColumnIndex - 1) < editableParams.size()) {
                        editingParameter = editableParams[editingColumnIndex - 1].name;
                    }
                }
                
                if (!editingParameter.empty()) {
                    isEditingParameter = true;
                    ImGuiIO& io = ImGui::GetIO();
                    io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableKeyboard;
                    return true;
                }
            }
            break;
            
        case OF_KEY_ESC:
            if (isEditingParameter) {
                isEditingParameter = false;
                editBufferCache.clear();
                editBufferInitializedCache = false;
                ImGuiIO& io = ImGui::GetIO();
                io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
                shouldRefocusCurrentCell = true; // Refocus cell after exiting edit mode
                return true;
            }
            break;
    }
    
    return false;
}
#pragma once
#include "ofxImGui.h"
#include "ofxSoundObjects.h"
#include "ParameterCell.h"
#include "Module.h"  // For ParameterDescriptor
#include <string>
#include <vector>
#include <map>

class MediaPool;  // Forward declaration

class MediaPoolGUI {
public:
    MediaPoolGUI();
    void setMediaPool(MediaPool& pool);
    void draw();
    
    // Navigation state controls (for InputRouter)
    bool getIsParentWidgetFocused() const { return isParentWidgetFocused; }
    void requestFocusMoveToParent() { requestFocusMoveToParentWidget = true; }
    
    // Keyboard input handling (for InputRouter)
    bool handleKeyPress(int key, bool ctrlPressed = false, bool shiftPressed = false);
    bool isKeyboardFocused() const { return editingColumnIndex >= 0; }
    
    // Static sync method (similar to TrackerSequencerGUI)
    static void syncEditStateFromImGuiFocus(MediaPoolGUI& gui);
    
    // Clear cell focus (for focus restoration when window regains focus)
    void clearCellFocus();
    
private:
    MediaPool* mediaPool;
    
    // Search functionality
    char searchBuffer[256];
    std::string searchFilter;
    
    // Waveform visualization
    float waveformHeight;
    static constexpr int MAX_WAVEFORM_POINTS = 2000;  // Maximum number of points for smooth waveform rendering
    
    // Navigation state (parent widget pattern, similar to TrackerSequencerGUI)
    ImGuiID parentWidgetId = 0;
    bool isParentWidgetFocused = false;
    bool requestFocusMoveToParentWidget = false;
    
    // Parameter editing state (similar to TrackerSequencer)
    std::string editingParameter;  // Currently editing parameter name (empty if none)
    int editingColumnIndex;        // Currently editing column index (0 = media index button, 1+ = parameter columns, -1 = none)
    bool isEditingParameter = false;
    std::string editBufferCache;
    bool editBufferInitializedCache = false;
    
    // Focus management (similar to TrackerSequencer)
    bool shouldFocusFirstCell = false;      // Flag to request focus on first cell when entering table
    bool shouldRefocusCurrentCell = false;  // Flag to request focus on current cell after exiting edit mode
    bool anyCellFocusedThisFrame = false;   // Track if any cell was focused this frame
    
    // Drag state for parameter editing
    std::string draggingParameter;  // Parameter being dragged (empty if none)
    float dragStartY = 0.0f;
    float dragStartX = 0.0f;
    float lastDragValue = 0.0f;
    
    // Scroll sync state - track previous index to only sync when it changes
    size_t previousMediaIndex = SIZE_MAX;  // Initialize to invalid value
    
    // Helper methods for focus management
    bool isCellFocused() const { return editingColumnIndex >= 0; }
    
    // GUI section methods
    void drawDirectoryControls();
    void drawSearchBar();
    void drawMediaList();
    void drawWaveform();
    void drawParameters();  // New: Draw parameter editing section as one-row table
    void drawMediaIndexButton(int columnIndex, size_t numParamColumns);  // Draw media index button (play/pause trigger)
    
    // Helper method to create and configure ParameterCell for a parameter (similar to TrackerSequencer)
    ParameterCell createParameterCellForParameter(const ParameterDescriptor& paramDesc);
    
    // Helper method to handle ParameterCell keyboard input (reduces duplication)
    // Returns true if key was handled, false otherwise
    bool handleParameterCellKeyPress(const ParameterDescriptor& paramDesc, int key, bool ctrlPressed, bool shiftPressed);
    
    // Helper method to truncate text to fit within available width
    // showEnd: if true, truncates from start (shows end with ellipsis prefix), 
    //          if false, truncates from end (shows start with ellipsis suffix)
    std::string truncateTextToWidth(const std::string& text, float maxWidth, bool showEnd = false, const std::string& ellipsis = "...");
};

#pragma once

#include <string>
#include <vector>
#include <map>
#include <functional>

// Parameter type enumeration
enum class ParameterType {
    FLOAT,
    INT,
    BOOL
};

// Describes a parameter that can be controlled by TrackerSequencer or other modules
struct ParameterDescriptor {
    std::string name;           // e.g., "position", "speed", "volume"
    ParameterType type;         // FLOAT, INT, BOOL
    float minValue;             // For FLOAT/INT parameters
    float maxValue;             // For FLOAT/INT parameters
    float defaultValue;         // Default value
    std::string displayName;    // User-friendly name, e.g., "Position"
    
    ParameterDescriptor()
        : name(""), type(ParameterType::FLOAT), minValue(0.0f), maxValue(1.0f), defaultValue(0.0f), displayName("") {}
    
    ParameterDescriptor(const std::string& n, ParameterType t, float min, float max, float def, const std::string& display)
        : name(n), type(t), minValue(min), maxValue(max), defaultValue(def), displayName(display) {}
};

// Module type enumeration (SunVox-style: sequencers separate, modules are instruments/effects)
enum class ModuleType {
    INSTRUMENT,   // MediaPool, MIDIOutput - responds to triggers
    EFFECT,       // Future: video effects, audio effects
    UTILITY       // Future: routing, mixing, utilities
};

// Event data for trigger events (discrete step triggers)
struct TriggerEvent {
    // Map of parameter names to values
    // TrackerSequencer sends: {"note": 60, "position": 0.5, "speed": 1.0, "volume": 1.0}
    // Modules map these to their own parameters (e.g., note â†’ mediaIndex)
    std::map<std::string, float> parameters;
    
    // Optional: duration in seconds (for step-based triggers)
    float duration = 0.0f;
};

// Unified base class for instruments and effects (SunVox-style)
// TrackerSequencer stays separate - it connects to Modules but doesn't inherit from Module
// This allows for future BespokeSynth-style evolution where TrackerSequencer becomes a Module too
class Module {
public:
    virtual ~Module() = default;
    
    // Identity
    virtual std::string getName() const = 0;
    virtual ModuleType getType() const = 0;
    
    // Get all available parameters that this module can accept
    // TrackerSequencer will query this to discover what parameters can be mapped to columns
    virtual std::vector<ParameterDescriptor> getParameters() = 0;
    
    // Discrete trigger event (called when a step triggers)
    // This is separate from continuous parameter modulation
    // Parameters map contains all values for this trigger (e.g., note, position, speed, volume)
    // Note: non-const reference to match ofEvent signature requirements
    virtual void onTrigger(TriggerEvent& event) = 0;
    
    // Continuous parameter modulation (for modulators, envelopes, etc.)
    // This is for continuous updates, not discrete triggers
    // paramName: The parameter name (e.g., "position", "speed", "volume")
    // value: The value to set (interpreted based on parameter type)
    // notify: If true, notify parameter change callback (default: true)
    virtual void setParameter(const std::string& paramName, float value, bool notify = true) = 0;
    
    // Parameter change callback (modules can notify external systems like ParameterSync)
    void setParameterChangeCallback(std::function<void(const std::string&, float)> callback) {
        parameterChangeCallback = callback;
    }
    
    // Optional: update loop (for modules that need continuous updates)
    virtual void update() {}
    
    // Optional: draw GUI (for modules that need visual representation)
    virtual void draw() {}

protected:
    // Parameter change callback for synchronization systems
    std::function<void(const std::string&, float)> parameterChangeCallback;
};
#include "ParameterCell.h"
#include "ofxImGui.h"
#include "ofLog.h"
#include <cmath>
#include <algorithm>
#include <sstream>
#include <stack>
#include <cctype>
#include <limits>

// Constants for expression evaluation (used by static function)
namespace {
    constexpr float EPSILON_DIVISION = 1e-9f;
}

ParameterCell::ParameterCell() 
    : isSelected(false), shouldRefocus(false), isEditing(false), editBufferInitialized(false),
      isDragging(false), dragStartY(0.0f), dragStartX(0.0f), lastDragValue(0.0f) {
}

// Helper function to evaluate simple mathematical expressions
// Supports: +, -, *, / with proper precedence
// Handles negative numbers and decimal numbers
static float evaluateExpression(const std::string& expr) {
    if (expr.empty()) {
        throw std::invalid_argument("Empty expression");
    }
    
    // Handle starting with '.' (treat as "0.")
    std::string processed = expr;
    if (processed[0] == '.') {
        processed = "0" + processed;
    }
    
    // Simple expression evaluator using two stacks (shunting yard algorithm simplified)
    std::stack<float> values;
    std::stack<char> ops;
    
    auto applyOp = [&](char op) {
        if (values.size() < 2) return;
        float b = values.top(); values.pop();
        float a = values.top(); values.pop();
        switch (op) {
            case '+': values.push(a + b); break;
            case '-': values.push(a - b); break;
            case '*': values.push(a * b); break;
            case '/': 
                if (std::abs(b) < EPSILON_DIVISION) throw std::runtime_error("Division by zero");
                values.push(a / b); 
                break;
        }
    };
    
    auto precedence = [](char op) -> int {
        if (op == '+' || op == '-') return 1;
        if (op == '*' || op == '/') return 2;
        return 0;
    };
    
    size_t i = 0;
    bool expectNumber = true;
    
    while (i < processed.length()) {
        // Skip whitespace
        if (std::isspace(processed[i])) {
            i++;
            continue;
        }
        
        // Handle '-' - could be negative number or subtraction
        if (processed[i] == '-') {
            if (expectNumber) {
                // Check if this is a negative number (followed by digit or '.')
                // or subtraction (not followed by digit/'.' and we have values)
                bool isNegative = false;
                if (i + 1 < processed.length() && (std::isdigit(processed[i + 1]) || processed[i + 1] == '.')) {
                    isNegative = true;
                } else if (values.empty()) {
                    // No values yet, must be negative (even if incomplete, user is typing)
                    isNegative = true;
                }
                // Otherwise, it's subtraction (handled below)
                
                if (isNegative) {
                    i++; // Consume the '-'
                    if (i >= processed.length()) {
                        // Incomplete negative - user might be typing, allow it
                        // Don't throw, just return 0 or let it be handled by caller
                        throw std::invalid_argument("Incomplete negative number");
                    }
                    
                    size_t start = i;
                    bool hasDecimal = false;
                    while (i < processed.length() && (std::isdigit(processed[i]) || processed[i] == '.')) {
                        if (processed[i] == '.') {
                            if (hasDecimal) throw std::invalid_argument("Multiple decimal points");
                            hasDecimal = true;
                        }
                        i++;
                    }
                    
                    if (i == start) throw std::invalid_argument("Invalid negative number");
                    float val = std::stof(processed.substr(start, i - start));
                    values.push(-val);
                    expectNumber = false;
                    continue;
                }
            }
            // Fall through to operator handling for subtraction
        }
        
        // Parse number (positive, starting with digit or '.')
        if (std::isdigit(processed[i]) || processed[i] == '.') {
            size_t start = i;
            bool hasDecimal = false;
            while (i < processed.length() && (std::isdigit(processed[i]) || processed[i] == '.')) {
                if (processed[i] == '.') {
                    if (hasDecimal) throw std::invalid_argument("Multiple decimal points");
                    hasDecimal = true;
                }
                i++;
            }
            float val = std::stof(processed.substr(start, i - start));
            values.push(val);
            expectNumber = false;
            continue;
        }
        
        // Handle operators (binary operations: +, -, *, /)
        if (processed[i] == '+' || processed[i] == '-' || processed[i] == '*' || processed[i] == '/') {
            if (expectNumber) {
                throw std::invalid_argument("Unexpected operator");
            }
            
            // This is a binary operator
            while (!ops.empty() && precedence(ops.top()) >= precedence(processed[i])) {
                applyOp(ops.top());
                ops.pop();
            }
            ops.push(processed[i]);
            expectNumber = true;
            i++;
            continue;
        }
        
        throw std::invalid_argument("Invalid character in expression");
    }
    
    // Apply remaining operators
    while (!ops.empty()) {
        applyOp(ops.top());
        ops.pop();
    }
    
    if (values.size() != 1) {
        throw std::invalid_argument("Invalid expression");
    }
    
    return values.top();
}

// Helper function implementations
bool ParameterCell::isOnlyDashes(const std::string& str) {
    if (str.empty()) return false;
    for (char c : str) {
        if (c != '-') return false;
    }
    return true;
}

std::string ParameterCell::trimWhitespace(const std::string& str) {
    size_t first = str.find_first_not_of(" \t");
    if (first == std::string::npos) return "";
    size_t last = str.find_last_not_of(" \t");
    return str.substr(first, (last - first + 1));
}

void ParameterCell::disableImGuiKeyboardNav() {
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableKeyboard;
}

void ParameterCell::enableImGuiKeyboardNav() {
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
}

void ParameterCell::removeParameter() {
    if (onValueRemoved) {
        onValueRemoved(parameterName);
    }
}

void ParameterCell::setValueRange(float min, float max, float defaultValue) {
    if (min > max) {
        ofLogWarning("ParameterCell") << "Invalid range: min > max, swapping values";
        std::swap(min, max);
    }
    minVal = min;
    maxVal = max;
    this->defaultValue = std::max(min, std::min(max, defaultValue));
}

void ParameterCell::calculateStepIncrement() {
    // Calculate optimal step increment based on parameter type and range
    if (isInteger || isFixed) {
        // Integer parameters: always use 1.0
        stepIncrement = 1.0f;
    } else {
        // Float parameter: determine precision based on range size
        // Use finer precision for smaller ranges, coarser for larger ranges
        float rangeSize = maxVal - minVal;
        if (rangeSize <= 1.0f) {
            // Small range (e.g., position 0-1): use 0.001 precision
            stepIncrement = 0.001f;
        } else if (rangeSize <= 2.0f) {
            // Small-medium range (e.g., volume 0-2): use 0.01 precision
            stepIncrement = 0.01f;
        } else if (rangeSize <= 20.0f) {
            // Medium range (e.g., speed -10 to 10): use 0.01 precision for finer control
            stepIncrement = 0.01f;
        } else {
            // Large range: use 0.1 precision
            stepIncrement = 0.1f;
        }
    }
}

void ParameterCell::setEditing(bool e) {
    if (e && !isEditing) {
        enterEditMode();
    } else if (!e && isEditing) {
        exitEditMode();
    }
}

void ParameterCell::setEditBuffer(const std::string& buffer) {
    editBuffer = buffer;
    if (!editBuffer.empty()) {
        // If setting a non-empty buffer, ensure we're in edit mode
        if (!isEditing) {
            isEditing = true;
            // Don't call enterEditMode() here as it would re-initialize the buffer
            // Just disable ImGui keyboard navigation
            disableImGuiKeyboardNav();
        }
    }
}

void ParameterCell::setEditBuffer(const std::string& buffer, bool initialized) {
    editBuffer = buffer;
    editBufferInitialized = initialized;
    if (!editBuffer.empty()) {
        // If setting a non-empty buffer, ensure we're in edit mode
        if (!isEditing) {
            isEditing = true;
            // Don't call enterEditMode() here as it would re-initialize the buffer
            // Just disable ImGui keyboard navigation
            disableImGuiKeyboardNav();
        }
    }
}

void ParameterCell::enterEditMode() {
    isEditing = true;
    initializeEditBuffer();
    editBufferInitialized = true;
    
    // Disable ImGui keyboard navigation when entering edit mode
    disableImGuiKeyboardNav();
}

void ParameterCell::exitEditMode() {
    isEditing = false;
    editBuffer.clear();
    editBufferInitialized = false;
    
    // Re-enable ImGui keyboard navigation when exiting edit mode
    enableImGuiKeyboardNav();
}

bool ParameterCell::handleKeyPress(int key, bool ctrlPressed, bool shiftPressed) {
    // Enter key behavior
    if (key == OF_KEY_RETURN) {
        if (ctrlPressed || shiftPressed) {
            // Ctrl+Enter or Shift+Enter: Exit edit mode
            exitEditMode();
            return true;
        }
        
        if (isEditing) {
            // In edit mode: Confirm and exit edit mode
            applyValue();
            shouldRefocus = true;
            exitEditMode();
            return true;
        } else if (isSelected) {
            // Selected but not editing: Enter edit mode
            enterEditMode();
            return true;
        }
        return false;
    }
    
    // Escape: Exit edit mode
    if (key == OF_KEY_ESC) {
        if (isEditing) {
            cancelEdit();
            return true;
        }
        return false;
    }
    
    // Backspace: Delete last character in edit buffer
    if (key == OF_KEY_BACKSPACE) {
        if (isEditing && !editBuffer.empty()) {
            editBuffer.pop_back();
            editBufferInitialized = false;
            
            // Re-apply value after backspace (Blender-style reactive editing)
            // This allows the value to update as the user corrects their input
            if (editBuffer.empty() || isOnlyDashes(editBuffer)) {
                // Buffer is empty or only dashes - remove parameter (set to "none")
                removeParameter();
            } else {
                try {
                    // Try to evaluate as expression (supports operations)
                    float floatValue = evaluateExpression(editBuffer);
                    applyEditValueFloat(floatValue);
                } catch (...) {
                    // Expression invalid - remove parameter (set to "none")
                    // This handles invalid expressions
                    removeParameter();
                }
            }
            return true;
        }
        return false;
    }
    
    // Delete key: Clear edit buffer
    if (key == OF_KEY_DEL) {
        if (isEditing) {
            editBuffer.clear();
            editBufferInitialized = false;
            return true;
        }
        return false;
    }
    
    // Numeric input (0-9) - Blender-style: direct typing enters edit mode and replaces value
    if (key >= '0' && key <= '9') {
        bool justEnteredEditMode = false;
        if (!isEditing) {
            // Auto-enter edit mode if cell is selected
            if (isSelected) {
                enterEditMode();
                justEnteredEditMode = true;
            } else {
                return false;  // Not selected, don't handle
            }
        }
        
        // Only clear buffer if we just entered edit mode via numeric key
        // This allows typing decimals after numbers (e.g., "1.5") and using backspace to correct
        if (justEnteredEditMode) {
            editBuffer.clear();
            editBufferInitialized = false;
        }
        // NOTE: We do NOT clear the buffer if already in edit mode - this allows:
        // - Typing multi-digit numbers (e.g., "123")
        // - Typing decimals after numbers (e.g., "1.5")
        // - Using backspace to correct input
        
        // Append digit to buffer
        editBuffer += (char)key;
        if (editBuffer.length() > MAX_EDIT_BUFFER_LENGTH) {
            editBuffer = editBuffer.substr(editBuffer.length() - MAX_EDIT_BUFFER_LENGTH);
        }
        
        // Apply value immediately (Blender-style reactive editing)
        // Try to evaluate as expression (supports operations like "2*3", "10/2", etc.)
        if (!editBuffer.empty()) {
            if (isOnlyDashes(editBuffer)) {
                // Only dashes (e.g., "-", "--") - remove parameter (set to "none")
                removeParameter();
            } else {
                try {
                    float floatValue = evaluateExpression(editBuffer);
                    applyEditValueFloat(floatValue);
                } catch (...) {
                    // Expression invalid or incomplete
                    // If it's clearly invalid (not just incomplete), remove parameter
                    // For incomplete expressions (like "2*"), let user continue typing
                    // We can't easily distinguish, so for now, let user continue
                    // The final parseAndApplyEditBuffer will handle invalid expressions
                }
            }
        }
        return true;
    }
    
    // Mathematical operators: +, *, /
    if (key == '+' || key == '*' || key == '/') {
        if (!isEditing) {
            // Auto-enter edit mode if cell is selected
            if (isSelected) {
                enterEditMode();
                // Don't clear buffer - allow appending operator to existing value
                // This allows operations like "5*2" or "10/2"
            } else {
                return false;  // Not selected, don't handle
            }
        }
        
        // Append operator to buffer
        editBuffer += (char)key;
        if (editBuffer.length() > MAX_EDIT_BUFFER_LENGTH) {
            editBuffer = editBuffer.substr(editBuffer.length() - MAX_EDIT_BUFFER_LENGTH);
        }
        
        // Try to evaluate expression if it's complete
        // For operators, we wait for the next number before evaluating
        // But we can try to evaluate if the expression is already valid
        if (!editBuffer.empty()) {
            // Check if buffer contains only operators/dashes
            bool onlyOpsOrDashes = true;
            for (char c : editBuffer) {
                if (c != '-' && c != '+' && c != '*' && c != '/') {
                    onlyOpsOrDashes = false;
                    break;
                }
            }
            
            if (onlyOpsOrDashes) {
                // Only operators/dashes - remove parameter (set to "none")
                removeParameter();
            } else {
                try {
                    float floatValue = evaluateExpression(editBuffer);
                    applyEditValueFloat(floatValue);
                } catch (...) {
                    // Expression incomplete or invalid - let user continue typing
                    // Final validation happens in parseAndApplyEditBuffer
                }
            }
        }
        return true;
    }
    
    // Decimal point and minus sign (can be negative number or subtraction)
    if (key == '.' || key == '-') {
        if (!isEditing) {
            // Auto-enter edit mode if cell is selected
            if (isSelected) {
                enterEditMode();
                // Clear buffer when entering edit mode via decimal/minus (replaces current value)
                editBuffer.clear();
                editBufferInitialized = false;
            } else {
                return false;  // Not selected, don't handle
            }
        }
        
        // If already in edit mode, don't clear - this allows typing decimals after numbers (e.g., "1.5")
        // and using backspace to correct input
        // NOTE: We do NOT clear the buffer if already in edit mode
        
        // Allow decimal point and minus sign in edit buffer
        // For minus: allow at start (negative number) or as subtraction operator
        // The expression evaluator will handle distinguishing between negative and subtraction
        if (key == '-') {
            // Always allow minus - expression evaluator will handle it correctly
            // (negative at start/after operator, subtraction otherwise)
        }
        
        // Only allow one decimal point per number (but allow multiple in expression like "1.5*2.3")
        if (key == '.') {
            // Find the last number in the buffer (after last operator)
            size_t lastOp = editBuffer.find_last_of("+-*/");
            std::string lastNumber = (lastOp == std::string::npos) ? editBuffer : editBuffer.substr(lastOp + 1);
            if (lastNumber.find('.') != std::string::npos) {
                return true;  // This number already has a decimal point
            }
        }
        
        editBuffer += (char)key;
        if (editBuffer.length() > MAX_EDIT_BUFFER_LENGTH) {
            editBuffer = editBuffer.substr(editBuffer.length() - MAX_EDIT_BUFFER_LENGTH);
        }
        
        // Apply value immediately (Blender-style)
        // Check if buffer is empty, single '.', or contains only dashes
        if (editBuffer.empty() || editBuffer == "." || isOnlyDashes(editBuffer)) {
            // Buffer is only dashes, empty, or single '.' - remove parameter (set to "none")
            removeParameter();
        } else {
            try {
                // Try to evaluate as expression (supports operations)
                float floatValue = evaluateExpression(editBuffer);
                applyEditValueFloat(floatValue);
            } catch (...) {
                // Expression invalid - remove parameter (set to "none")
                // This handles invalid expressions like "abc", "2**3", etc.
                removeParameter();
            }
        }
        return true;
    }
    
    // Arrow keys in edit mode: Adjust values ONLY (no navigation)
    // CRITICAL: When editing, arrow keys must ONLY adjust values, never navigate
    // This ensures focus stays locked to the editing cell
    if (isEditing) {
        if (key == OF_KEY_UP || key == OF_KEY_DOWN || key == OF_KEY_LEFT || key == OF_KEY_RIGHT) {
            // Adjust value based on arrow direction
            int delta = 0;
            if (key == OF_KEY_UP || key == OF_KEY_RIGHT) {
                delta = 1;  // Up/Right = increase
            } else {
                delta = -1; // Down/Left = decrease
            }
            adjustValue(delta);
            // Always return true to consume the event and prevent navigation
            return true;
        }
    }
    
    return false;
}

void ParameterCell::appendDigit(char digit) {
    if (!isEditing) {
        enterEditMode();
    }
    editBuffer += digit;
    if (editBuffer.length() > MAX_EDIT_BUFFER_LENGTH) {
        editBuffer = editBuffer.substr(editBuffer.length() - MAX_EDIT_BUFFER_LENGTH);
    }
}

void ParameterCell::appendChar(char c) {
    if (!isEditing) {
        enterEditMode();
    }
    editBuffer += c;
    if (editBuffer.length() > MAX_EDIT_BUFFER_LENGTH) {
        editBuffer = editBuffer.substr(editBuffer.length() - MAX_EDIT_BUFFER_LENGTH);
    }
}

void ParameterCell::backspace() {
    if (isEditing && !editBuffer.empty()) {
        editBuffer.pop_back();
        editBufferInitialized = false;
    }
}

void ParameterCell::deleteChar() {
    if (isEditing) {
        editBuffer.clear();
        editBufferInitialized = false;
    }
}

void ParameterCell::applyValue() {
    parseAndApplyEditBuffer();
}

void ParameterCell::cancelEdit() {
    exitEditMode();
}

void ParameterCell::adjustValue(int delta) {
    if (!getCurrentValue) return;
    
    float currentVal = getCurrentValue();
    
    // If current value is NaN (not set), start from default value or middle of range
    if (std::isnan(currentVal)) {
        // Use default value if available, otherwise use middle of range
        if (defaultValue >= minVal && defaultValue <= maxVal) {
            currentVal = defaultValue;
        } else {
            currentVal = (minVal + maxVal) / 2.0f;
        }
    }
    
    float stepSize;
    
    // Use configured step increment (set based on parameter type and range)
    // This is set in createParameterCellForColumn based on:
    // - Integer parameters: 1.0
    // - Float parameters: 0.001, 0.01, or 0.1 based on range size
    stepSize = stepIncrement;
    
    float newValue = currentVal + (delta * stepSize);
    
    // For integer parameters, round to nearest integer
    if (isInteger || isFixed) {
        newValue = std::round(newValue);
    }
    
    newValue = std::max(minVal, std::min(maxVal, newValue));
    
    // Update edit buffer with new value
    if (formatValue) {
        editBuffer = formatValue(newValue);
    } else {
        editBuffer = getDefaultFormatValue(newValue);
    }
    editBufferInitialized = false;
    
    // Apply immediately
    applyEditValueFloat(newValue);
}

void ParameterCell::initializeEditBuffer() {
    if (!getCurrentValue) {
        editBuffer.clear();
        return;
    }
    
    float currentVal = getCurrentValue();
    
    if (isFixed && fixedType == FIXED_TYPE_INDEX) {
        // Index column: 1-based display (01-99), 0 = rest
        // currentVal is already in 1-based display format (0 = rest, 1+ = media index)
        int indexVal = (int)std::round(currentVal);
        if (indexVal <= 0) {
            editBuffer = "00"; // Rest
        } else {
            char buf[8];
            snprintf(buf, sizeof(buf), "%02d", indexVal);
            editBuffer = buf;
        }
    } else if (isFixed && fixedType == FIXED_TYPE_LENGTH) {
        // Length column: 1-16 range
        int lengthVal = (int)std::round(currentVal);
        char buf[8];
        snprintf(buf, sizeof(buf), "%d", lengthVal);
        editBuffer = buf;
    } else {
        // Dynamic parameter or MediaPool parameter
        if (formatValue) {
            editBuffer = formatValue(currentVal);
        } else {
            editBuffer = getDefaultFormatValue(currentVal);
        }
    }
}

std::string ParameterCell::formatDisplayText(float value) const {
    // Check for NaN (not a number) - indicates empty/not set (show "--")
    // This represents "none" state - let MediaPool handle the parameter
    // Using NaN allows parameters with negative ranges (like speed -10 to 10) to distinguish
    // between "not set" (NaN/--) and explicit values like 1.0 or -1.0
    if (std::isnan(value)) {
        return "--";
    }
    
    if (isBool) {
        return value > 0.5f ? "ON" : "OFF";
    }
    
    if (isFixed && fixedType == FIXED_TYPE_INDEX) {
        // Index: 1-based display (01-99)
        // For fixed columns, we still use -1.0f to indicate rest (compatibility)
        if (value < 0.0f) {
            return "--";
        }
        int idx = (int)std::round(value);
        if (idx <= 0) {
            return "--";
        }
        char buf[8];
        snprintf(buf, sizeof(buf), "%02d", idx);
        return buf;
    }
    
    if (isFixed && fixedType == FIXED_TYPE_LENGTH) {
        // Length: 1-16 range, formatted as "02"
        // For fixed columns, we still use -1.0f to indicate rest (compatibility)
        if (value < 0.0f) {
            return "--";
        }
        int len = std::max(LENGTH_MIN, std::min(LENGTH_MAX, (int)std::round(value)));
        char buf[8];
        snprintf(buf, sizeof(buf), "%02d", len);
        return buf;
    }
    
    // Float value: 2 decimal places
    char buf[16];
    snprintf(buf, sizeof(buf), "%.2f", value);
    return buf;
}

float ParameterCell::calculateFillPercent(float value) const {
    // Check for NaN (not a number) - indicates empty/not set (no fill)
    if (std::isnan(value)) {
        return 0.0f;
    }
    
    // For fixed columns, we still use -1.0f to indicate rest (compatibility)
    if (isFixed && value < 0.0f) {
        return 0.0f;
    }
    
    float rangeSize = maxVal - minVal;
    if (rangeSize > 0.0f) {
        float fillPercent = (value - minVal) / rangeSize;
        return std::max(0.0f, std::min(1.0f, fillPercent));
    }
    return 0.0f;
}

void ParameterCell::applyEditValueFloat(float floatValue) {
    if (isFixed && fixedType == FIXED_TYPE_LENGTH) {
        // Length must be integer between 1-16
        // For fixed columns, clamp to valid range
        int newValue = std::max(LENGTH_MIN, std::min(LENGTH_MAX, (int)std::round(floatValue)));
        applyEditValueInt(newValue);
    } else if (isFixed && fixedType == FIXED_TYPE_INDEX) {
        // Index: 0 = rest, 1+ = media index (1-based display)
        // For fixed columns, clamp to valid range
        int maxIdx = getMaxIndex ? getMaxIndex() : INDEX_MAX_DEFAULT;
        int newValue = std::max(0, std::min(maxIdx, (int)std::round(floatValue)));
        applyEditValueInt(newValue);
    } else {
        // Dynamic parameter or MediaPool parameter
        // If value is outside range, remove parameter (set to "none" state)
        // This allows users to clear invalid values by typing out-of-range numbers
        if (floatValue < minVal || floatValue > maxVal) {
            // Value is outside valid range - remove parameter
            removeParameter();
        } else {
            // Value is within range - apply it
            if (onValueApplied) {
                onValueApplied(parameterName, floatValue);
            }
        }
    }
}

void ParameterCell::applyEditValueInt(int intValue) {
    if (isFixed && fixedType == FIXED_TYPE_INDEX) {
        // Index: 0 = rest (-1 in storage), 1+ = media index (0-based in storage)
        // But we work with 1-based display values here
        // The callback should handle the conversion
        if (onValueApplied) {
            onValueApplied(parameterName, (float)intValue);
        }
    } else if (isFixed && fixedType == FIXED_TYPE_LENGTH) {
        // Length: 1-16 range
        int clampedValue = std::max(LENGTH_MIN, std::min(LENGTH_MAX, intValue));
        if (onValueApplied) {
            onValueApplied(parameterName, (float)clampedValue);
        }
    } else {
        // Shouldn't happen for non-fixed, but handle it
        if (onValueApplied) {
            onValueApplied(parameterName, (float)intValue);
        }
    }
}

bool ParameterCell::parseAndApplyEditBuffer() {
    // For fixed columns, empty buffer is invalid
    if (isFixed && editBuffer.empty()) {
        return false;
    }
    
    // Handle empty buffer or invalid input for dynamic parameters (removes parameter)
    if (!isFixed) {
        // Trim whitespace for comparison
        std::string trimmed = trimWhitespace(editBuffer);
        
        // Check for clear patterns: empty, or strings containing only dashes
        if (trimmed.empty() || isOnlyDashes(trimmed)) {
            // Empty buffer or only dashes - remove parameter
            removeParameter();
            return true;
        }
    }
    
    // Try to parse the buffer
    try {
        if (isFixed && fixedType == FIXED_TYPE_LENGTH) {
            int lengthValue = std::max(LENGTH_MIN, std::min(LENGTH_MAX, (int)std::round(std::stof(editBuffer))));
            applyEditValueInt(lengthValue);
            return true;
        } else if (isFixed && fixedType == FIXED_TYPE_INDEX) {
            int maxIdx = getMaxIndex ? getMaxIndex() : INDEX_MAX_DEFAULT;
            int indexValue = std::max(0, std::min(maxIdx, (int)std::round(std::stof(editBuffer))));
            applyEditValueInt(indexValue);
            return true;
        } else {
            // Dynamic parameter - parse as expression (supports operations)
            float floatValue;
            if (parseValue) {
                try {
                    floatValue = parseValue(editBuffer);
                } catch (...) {
                    // Parse failed - remove parameter (set to "none")
                    removeParameter();
                    return true;
                }
            } else {
                // Try to evaluate as expression first, fall back to simple float parse
                try {
                    floatValue = evaluateExpression(editBuffer);
                } catch (...) {
                    // Expression invalid - try simple float parse
                    try {
                        floatValue = std::stof(editBuffer);
                    } catch (...) {
                        // All parsing failed - remove parameter (set to "none")
                        removeParameter();
                        return true;
                    }
                }
            }
            // Apply value (will check range and remove if out of range)
            applyEditValueFloat(floatValue);
            return true;
        }
    } catch (...) {
        // Parse failed - for dynamic parameters, remove it (set to "none")
        if (!isFixed) {
            removeParameter();
            return true;
        }
        // Invalid value for fixed column
        return false;
    }
}

std::string ParameterCell::getDefaultFormatValue(float value) const {
    if (isBool) {
        return value > 0.5f ? "ON" : "OFF";
    }
    char buf[16];
    snprintf(buf, sizeof(buf), "%.2f", value);
    return buf;
}

float ParameterCell::getDefaultParseValue(const std::string& str) const {
    try {
        // Try to evaluate as expression first (supports operations)
        return evaluateExpression(str);
    } catch (...) {
        // Fall back to simple float parse
        try {
            return std::stof(str);
        } catch (...) {
            return defaultValue;
        }
    }
}

ImU32 ParameterCell::getFillBarColor() const {
    static ImU32 color = ImGui::GetColorU32(ImVec4(0.5f, 0.5f, 0.5f, 0.25f));
    return color;
}

ImU32 ParameterCell::getRedOutlineColor() const {
    static ImU32 color = ImGui::GetColorU32(ImVec4(0.9f, 0.05f, 0.1f, 1.0f));
    return color;
}

ImU32 ParameterCell::getOrangeOutlineColor() const {
    static ImU32 color = ImGui::GetColorU32(ImVec4(1.0f, 0.5f, 0.0f, 1.0f));
    return color;
}

ParameterCellInteraction ParameterCell::draw(int uniqueId,
                                            bool isFocused,
                                            bool shouldFocusFirst,
                                            bool shouldRefocusCurrentCell) {
    ParameterCellInteraction result;
    
    ImGui::PushID(uniqueId);
    
    // Get current value for display
    // Note: We keep NaN as-is for formatDisplayText (which will show "--")
    // but use a default value for fill bar calculations
    float currentVal = getCurrentValue ? getCurrentValue() : defaultValue;
    float displayVal = currentVal; // Keep NaN for display formatting
    
    // Get display text (formatDisplayText handles NaN and shows "--")
    std::string displayText;
    if (isEditing && isSelected) {
        // Show edit buffer when editing (even if empty, to show edit mode is active)
        if (editBuffer.empty()) {
            displayText = formatDisplayText(displayVal);
        } else {
            displayText = editBuffer;
        }
    } else {
        displayText = formatDisplayText(displayVal);
    }
    
    // Calculate fill percent for visualization (calculateFillPercent handles NaN)
    float fillPercent = calculateFillPercent(currentVal);
    
    // Get cell rect for value bar (before drawing button)
    ImVec2 cellMin = ImGui::GetCursorScreenPos();
    float cellHeight = ImGui::GetFrameHeight();
    float cellWidth = ImGui::GetColumnWidth();
    ImVec2 cellMax = ImVec2(cellMin.x + cellWidth, cellMin.y + cellHeight);
    
    // Draw value bar background first (as true background layer)
    if (fillPercent > 0.01f) {
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        if (drawList) {
            ImVec2 fillEnd = ImVec2(cellMin.x + (cellMax.x - cellMin.x) * fillPercent, cellMax.y);
            drawList->AddRectFilled(cellMin, fillEnd, getFillBarColor());
        }
    }
    
    // Apply edit mode styling: dark grey/black background (Blender-style)
    if (isEditing && isSelected) {
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.0f, 0.0f, 0.0f, 0.8f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.05f, 0.05f, 0.05f, 0.8f));
        ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.1f, 0.1f, 0.1f, 1.0f));
    } else {
        // Make button backgrounds completely transparent when not editing
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0, 0, 0, 0));
        ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0, 0, 0, 0));
    }
    
    ImGui::PushStyleVar(ImGuiStyleVar_ButtonTextAlign, ImVec2(1.0f, 0.5f));
    
    // CRITICAL: Prevent ImGui from auto-focusing cells when clicking empty space
    ImGui::PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
    
    // Set focus on first cell if requested
    if (shouldFocusFirst) {
        ImGui::SetKeyboardFocusHere(0);
    }
    
    // Draw button
    bool buttonClicked = ImGui::Button(displayText.c_str(), ImVec2(-1, 0));
    
    // Pop the flag after creating the button
    ImGui::PopItemFlag();
    
    // Refocus current cell after exiting edit mode
    if (shouldRefocusCurrentCell && isSelected) {
        ImGui::SetKeyboardFocusHere(-1);
        ImGuiIO& io = ImGui::GetIO();
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    }
    
    // Prevent spacebar from triggering button clicks
    bool spacebarPressed = ImGui::IsKeyPressed(ImGuiKey_Space, false);
    
    // Check actual focus state after drawing (ImGui::IsItemFocused() works for last item)
    bool actuallyFocused = ImGui::IsItemFocused();
    
    // Handle drag state (Blender-style: works across entire window)
    // CRITICAL: Check drag state FIRST to handle restored drag states from previous frames
    // When drag state is restored, isDragging is true but IsItemActive() might be false
    if (isDragging) {
        // Continue drag - update value based on mouse movement (works even if mouse left cell)
        // This handles both active drags and restored drag states
        updateDrag();
        // Ensure we mark drag as started if it was restored (for proper state sync back to GUI)
        if (!result.dragStarted) {
            result.dragStarted = true;
        }
    } else if (ImGui::IsItemActive() && ImGui::IsMouseDragging(0)) {
        // Start drag when cell is active and mouse is dragging
        // IsItemActive() returns true when mouse was clicked on this item and is still held
        // This works even if mouse has moved outside the cell (Blender-style)
        // NOTE: Don't require isSelected - IsItemActive() is sufficient to indicate the cell was clicked
        // Set isSelected when drag starts to maintain proper state
        if (!isSelected) {
            isSelected = true;
            result.focusChanged = true;
        }
        startDrag();
        result.dragStarted = true;
    }
    
    // Check if drag ended (mouse released anywhere in window)
    // This check happens AFTER updateDrag() so we can properly detect drag end
    // updateDrag() also checks for mouse release internally, but we need to sync the dragEnded flag
    if (isDragging && !ImGui::IsMouseDown(0)) {
        endDrag();
        result.dragEnded = true;
    }
    
    // Sync ImGui focus to selection state
    // Only sync when item was actually clicked, keyboard-navigated, or refocusing after edit
    if (actuallyFocused) {
        bool itemWasClicked = ImGui::IsItemClicked(0);
        bool keyboardNavActive = (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
        bool shouldRefocus = shouldRefocusCurrentCell && isSelected;
        
        // Only sync if this is an intentional focus (click, keyboard nav, or refocus)
        if (itemWasClicked || keyboardNavActive || shouldRefocus) {
            result.focusChanged = true;
            
            // Lock focus to editing cell - arrow keys adjust values, not navigate
            if (isEditing && !isSelected) {
                // Don't sync focus change during edit
                result.shouldExitEarly = true;
            } else {
                isSelected = true;
            }
        }
    }
    
    // Early exit after syncing (but before drawing outline)
    if (result.shouldExitEarly) {
        ImGui::PopStyleVar(1);
        ImGui::PopStyleColor(3);
        ImGui::PopID();
        return result;
    }
    
    // Handle click
    bool isItemClicked = ImGui::IsItemClicked(0);
    if (buttonClicked && !ImGui::IsMouseDragging(0) && !spacebarPressed && isItemClicked) {
        result.clicked = true;
        isSelected = true;
        // DON'T enter edit mode on click - just focus the cell
        // User can type numbers directly (auto-enters edit mode) or hit Enter to enter edit mode
        if (isEditing) {
            exitEditMode();
        }
    }
    
    // Maintain focus during drag (even when mouse leaves cell)
    if (isDragging && !actuallyFocused) {
        // Keep cell focused during drag for visual feedback
        // Don't require IsItemActive() - drag works across entire window
        ImGui::SetKeyboardFocusHere(-1);
    }
    
    // Pop style var and colors
    ImGui::PopStyleVar(1);
    ImGui::PopStyleColor(3);
    
    // Draw outline for selected/editing cells
    bool shouldShowOutline = isSelected || isDragging || (actuallyFocused && !isEditing);
    if (shouldShowOutline) {
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        if (drawList) {
            ImVec2 outlineMin = ImVec2(cellMin.x - 1, cellMin.y - 1);
            ImVec2 outlineMax = ImVec2(cellMax.x + 1, cellMax.y + 1);
            // Orange outline when in edit mode, red outline when just selected or dragging
            ImU32 outlineColor = (isSelected && isEditing)
                ? getOrangeOutlineColor()
                : getRedOutlineColor();
            drawList->AddRect(outlineMin, outlineMax, outlineColor, 0.0f, 0, 2.0f);
        }
    }
    
    ImGui::PopID();
    return result;
}

void ParameterCell::startDrag() {
    if (isDragging) return; // Already dragging
    
    // Exit edit mode when dragging starts
    if (isEditing) {
        exitEditMode();
    }
    
    // Initialize drag state
    isDragging = true;
    dragStartY = ImGui::GetMousePos().y;
    dragStartX = ImGui::GetMousePos().x;
    
    // Get current value as starting point
    if (getCurrentValue) {
        float val = getCurrentValue();
        // Handle NaN (not set) - use default value or middle of range
        if (std::isnan(val)) {
            if (defaultValue >= minVal && defaultValue <= maxVal) {
                lastDragValue = defaultValue;
            } else {
                lastDragValue = (minVal + maxVal) / 2.0f;
            }
        } else {
            lastDragValue = val;
        }
    } else {
        lastDragValue = defaultValue;
    }
    
    // Disable keyboard navigation during drag
    disableImGuiKeyboardNav();
}

void ParameterCell::updateDrag() {
    if (!isDragging) return;
    
    // Check if mouse is still down (allows dragging across entire window)
    if (!ImGui::IsMouseDown(0)) {
        // Mouse released - end drag
        endDrag();
        return;
    }
    
    // Calculate drag delta (both vertical AND horizontal)
    ImVec2 currentPos = ImGui::GetMousePos();
    float dragDeltaY = dragStartY - currentPos.y; // Up = positive (increase)
    float dragDeltaX = currentPos.x - dragStartX; // Right = positive (increase)
    
    // Use the larger of horizontal or vertical movement for maximum precision
    // This allows dragging in any direction with equal effectiveness
    float totalDragDelta = std::abs(dragDeltaY) > std::abs(dragDeltaX) ? dragDeltaY : dragDeltaX;
    
    // Direct range mapping: map pixel movement directly to value range
    // Sensitivity: pixels needed to traverse full range
    float rangeSize = maxVal - minVal;
    
    // Calculate value change directly from pixel movement (maximum precision)
    float valueDelta = (totalDragDelta / DRAG_SENSITIVITY_PIXELS) * rangeSize;
    float newValue = lastDragValue + valueDelta;
    
    // Clamp to valid range
    newValue = std::max(minVal, std::min(maxVal, newValue));
    
    // For integer parameters, round to nearest integer
    if (isInteger || isFixed) {
        newValue = std::round(newValue);
    }
    
    // Apply immediately (no threshold - maximum precision and responsiveness)
    applyDragValue(newValue);
}

void ParameterCell::endDrag() {
    if (!isDragging) return;
    
    isDragging = false;
    dragStartY = 0.0f;
    dragStartX = 0.0f;
    lastDragValue = 0.0f;
    
    // Re-enable keyboard navigation when drag ends
    enableImGuiKeyboardNav();
}

void ParameterCell::applyDragValue(float newValue) {
    if (!onValueApplied) return;
    
    // Clamp value to range
    float clampedValue = std::max(minVal, std::min(maxVal, newValue));
    
    // Apply via callback
    onValueApplied(parameterName, clampedValue);
}



#pragma once

#include "ofMain.h"
#include <string>
#include <functional>

// Forward declarations for ImGui types
typedef unsigned int ImU32;

// Interaction result from ParameterCell::draw()
struct ParameterCellInteraction {
    bool clicked = false;
    bool focusChanged = false;
    bool dragStarted = false;
    bool dragEnded = false;
    bool shouldExitEarly = false;
    
    ParameterCellInteraction() = default;
};

// ParameterCell - Reusable editing widget for parameter values
// Supports keyboard input, drag editing, and visual feedback
class ParameterCell {
public:
    ParameterCell();
    
    // Configuration
    void setValueRange(float min, float max, float defaultValue);
    
    // Helper: Calculate optimal step increment based on parameter range and type
    // This can be called after setValueRange() to auto-configure stepIncrement
    void calculateStepIncrement();
    
    // Edit mode management
    void setEditing(bool e);
    void enterEditMode();
    void exitEditMode();
    bool isEditingMode() const { return isEditing; }
    bool isSelectedState() const { return isSelected; }
    
    // Edit buffer management
    void setEditBuffer(const std::string& buffer);
    void setEditBuffer(const std::string& buffer, bool initialized); // Overload to set both buffer and initialized flag
    const std::string& getEditBuffer() const { return editBuffer; }
    bool isEditBufferInitialized() const { return editBufferInitialized; }
    
    // Keyboard input handling
    bool handleKeyPress(int key, bool ctrlPressed = false, bool shiftPressed = false);
    
    // Manual buffer manipulation
    void appendDigit(char digit);
    void appendChar(char c);
    void backspace();
    void deleteChar();
    
    // Edit operations
    void applyValue();
    void cancelEdit();
    void adjustValue(int delta);
    
    // Display and formatting
    std::string formatDisplayText(float value) const;
    float calculateFillPercent(float value) const;
    
    // Drawing
    ParameterCellInteraction draw(int uniqueId,
                                  bool isFocused,
                                  bool shouldFocusFirst = false,
                                  bool shouldRefocusCurrentCell = false);
    
    // Drag editing
    void startDrag();
    void updateDrag();
    void endDrag();
    
    // Drag state management (for persistence across frames)
    bool getIsDragging() const { return isDragging; }
    void setDragState(bool dragging, float startY, float startX, float lastValue) {
        isDragging = dragging;
        dragStartY = startY;
        dragStartX = startX;
        lastDragValue = lastValue;
    }
    float getDragStartY() const { return dragStartY; }
    float getDragStartX() const { return dragStartX; }
    float getLastDragValue() const { return lastDragValue; }
    
    // Callbacks - set these to connect to your data model
    std::function<float()> getCurrentValue;              // Get current value for display
    std::function<void(const std::string&, float)> onValueApplied;  // Called when value is applied
    std::function<void(const std::string&)> onValueRemoved;         // Called when parameter is removed
    std::function<std::string(float)> formatValue;       // Optional: custom formatter
    std::function<float(const std::string&)> parseValue; // Optional: custom parser
    std::function<int()> getMaxIndex;                    // For index columns: max index value
    
    // Configuration properties
    std::string parameterName;  // Parameter name (e.g., "position", "speed", "volume")
    bool isFixed = false;       // True for fixed columns (index, length)
    std::string fixedType;      // "index" or "length" for fixed columns
    bool isBool = false;        // True for boolean parameters
    bool isInteger = false;     // True for integer parameters (affects arrow key increments)
    float stepIncrement = 0.01f; // Step size for arrow key adjustments (0.001, 0.01, 0.1, or 1.0)
    
    // Value range
    float minVal = 0.0f;
    float maxVal = 1.0f;
    float defaultValue = 0.0f;
    
    // Selection state (can be set externally)
    bool isSelected = false;
    bool shouldRefocus = false;
    
private:
    // Constants
    static constexpr size_t MAX_EDIT_BUFFER_LENGTH = 50;
    static constexpr float DRAG_SENSITIVITY_PIXELS = 200.0f;
    static constexpr float EPSILON_DIVISION = 1e-9f;
    static constexpr int INDEX_MAX_DEFAULT = 127;
    static constexpr int LENGTH_MIN = 1;
    static constexpr int LENGTH_MAX = 16;
    static constexpr const char* FIXED_TYPE_INDEX = "index";
    static constexpr const char* FIXED_TYPE_LENGTH = "length";
    
    // Internal state
    bool isEditing = false;
    bool editBufferInitialized = false;
    std::string editBuffer;
    
    // Drag state
    bool isDragging = false;
    float dragStartY = 0.0f;
    float dragStartX = 0.0f;
    float lastDragValue = 0.0f;
    
    // Internal methods
    void initializeEditBuffer();
    void applyEditValueFloat(float floatValue);
    void applyEditValueInt(int intValue);
    bool parseAndApplyEditBuffer();
    
    // Helper methods
    std::string getDefaultFormatValue(float value) const;
    float getDefaultParseValue(const std::string& str) const;
    void applyDragValue(float newValue);
    
    // String utility helpers
    static bool isOnlyDashes(const std::string& str);
    static std::string trimWhitespace(const std::string& str);
    
    // ImGui state management helpers
    void disableImGuiKeyboardNav();
    void enableImGuiKeyboardNav();
    
    // Value removal helper
    void removeParameter();
    
    // Color helpers
    ImU32 getFillBarColor() const;
    ImU32 getRedOutlineColor() const;
    ImU32 getOrangeOutlineColor() const;
};


#include "ParameterSync.h"
#include "TrackerSequencer.h"
#include "MediaPool.h"
#include "MediaPlayer.h"
#include "Module.h"
#include "ofLog.h"
#include <cmath>

ParameterSync::ParameterSync() {
}

ParameterSync::~ParameterSync() {
    bindings.clear();
}

void ParameterSync::connect(
    void* source,
    const std::string& sourceParam,
    void* target,
    const std::string& targetParam,
    std::function<bool()> condition
) {
    if (!source || !target) {
        ofLogError("ParameterSync") << "Cannot connect: source or target is null";
        return;
    }
    
    // Use emplace_back to construct Binding in place (can't copy due to atomic member)
    bindings.emplace_back();
    Binding& binding = bindings.back();
    binding.source = source;
    binding.sourceParam = sourceParam;
    binding.target = target;
    binding.targetParam = targetParam;
    binding.condition = condition ? condition : []() { return true; };
    binding.syncing.store(false, std::memory_order_relaxed);
    
    ofLogNotice("ParameterSync") << "Connected: " << sourceParam << " -> " << targetParam;
}

void ParameterSync::disconnect(void* source, const std::string& sourceParam) {
    auto it = bindings.begin();
    while (it != bindings.end()) {
        if (it->source == source && it->sourceParam == sourceParam) {
            it = bindings.erase(it);
            ofLogNotice("ParameterSync") << "Disconnected: " << sourceParam;
        } else {
            ++it;
        }
    }
}

void ParameterSync::update() {
    // Periodic update can be used for polling-based sync if needed
    // For now, we rely on parameter change notifications
}

void ParameterSync::notifyParameterChange(void* module, const std::string& paramName, float value) {
    // Find all bindings where this module is the source
    auto bindingIndices = findBindingsForSource(module, paramName);
    
    for (size_t idx : bindingIndices) {
        if (idx >= bindings.size()) continue;
        
        Binding& binding = bindings[idx];
        
        // Check if sync should be active
        if (!binding.condition()) {
            continue;
        }
        
        // Prevent feedback loop
        if (binding.syncing.load(std::memory_order_acquire)) {
            continue;
        }
        
        // Set syncing flag
        binding.syncing.store(true, std::memory_order_release);
        
        // Get current target value to check if update is needed
        float currentTargetValue = getParameterValue(binding.target, binding.targetParam);
        
        // Only update if value actually changed (avoid unnecessary updates)
        // Also, for position sync, don't sync 0 if current value is non-zero (preserve position)
        // This prevents resetting position when sync system returns 0 incorrectly
        bool shouldUpdate = std::abs(currentTargetValue - value) > 0.0001f;
        if (binding.targetParam == "position" && value == 0.0f && currentTargetValue > 0.001f) {
            // Don't sync 0 if we have a valid position - this prevents unwanted resets
            shouldUpdate = false;
        }
        
        if (shouldUpdate) {
            setParameterValue(binding.target, binding.targetParam, value);
        }
        
        // Clear syncing flag
        binding.syncing.store(false, std::memory_order_release);
    }
}

float ParameterSync::getParameterValue(void* module, const std::string& paramName) const {
    if (!module) {
        return 0.0f;
    }
    
    // Try TrackerSequencer first (check by parameter name)
    if (paramName == "currentStepPosition") {
        TrackerSequencer* ts = static_cast<TrackerSequencer*>(module);
        return ts->getCurrentStepPosition();
    }
    
    // Try MediaPool (check by parameter name)
    // For position sync, we want to get startPosition (not playhead position)
    if (paramName == "position") {
        MediaPool* mp = static_cast<MediaPool*>(module);
        auto* player = mp->getActivePlayer();
        if (player) {
            // Return startPosition for sync (this is what we sync with tracker)
            return player->startPosition.get();
        }
    }
    
    return 0.0f;
}

void ParameterSync::setParameterValue(void* module, const std::string& paramName, float value) {
    if (!module) {
        return;
    }
    
    // Try TrackerSequencer first (check by parameter name)
    if (paramName == "currentStepPosition") {
        TrackerSequencer* ts = static_cast<TrackerSequencer*>(module);
        ts->setCurrentStepPosition(value);
        return;
    }
    
    // Try MediaPool (check by parameter name)
    if (paramName == "position") {
        MediaPool* mp = static_cast<MediaPool*>(module);
        // Use setParameter with notify=false to prevent feedback loop
        mp->setParameter(paramName, value, false);
        return;
    }
    
    // For other modules, use standard setParameter
    Module* mod = static_cast<Module*>(module);
    if (mod) {
        mod->setParameter(paramName, value, false);
    }
}

std::vector<size_t> ParameterSync::findBindingsForSource(void* source, const std::string& paramName) const {
    std::vector<size_t> indices;
    for (size_t i = 0; i < bindings.size(); ++i) {
        if (bindings[i].source == source && bindings[i].sourceParam == paramName) {
            indices.push_back(i);
        }
    }
    return indices;
}

std::vector<size_t> ParameterSync::findBindingsForTarget(void* target, const std::string& paramName) const {
    std::vector<size_t> indices;
    for (size_t i = 0; i < bindings.size(); ++i) {
        if (bindings[i].target == target && bindings[i].targetParam == paramName) {
            indices.push_back(i);
        }
    }
    return indices;
}

#pragma once

#include "Module.h"
#include <functional>
#include <string>
#include <vector>
#include <atomic>
#include <memory>
#include <cstddef>

// Forward declarations
class TrackerSequencer;
class MediaPool;

/**
 * ParameterSync - Modular parameter synchronization connector
 * 
 * Connects modules via named parameter bindings with bidirectional sync.
 * Prevents feedback loops and respects conditional sync rules.
 * 
 * Usage:
 *   ParameterSync sync;
 *   sync.connect(&trackerSequencer, "currentStepPosition", &mediaPool, "position",
 *                [this]() { return !clock.isPlaying(); });
 */
class ParameterSync {
public:
    ParameterSync();
    ~ParameterSync();
    
    /**
     * Connect two modules with bidirectional parameter binding
     * @param source Source module
     * @param sourceParam Parameter name in source module (e.g., "currentStepPosition")
     * @param target Target module
     * @param targetParam Parameter name in target module (e.g., "position")
     * @param condition Optional function that returns true when sync should be active
     */
    void connect(
        void* source,
        const std::string& sourceParam,
        void* target,
        const std::string& targetParam,
        std::function<bool()> condition = nullptr
    );
    
    /**
     * Disconnect a binding
     * @param source Source module
     * @param sourceParam Parameter name to disconnect
     */
    void disconnect(void* source, const std::string& sourceParam);
    
    /**
     * Update method - call from ofApp::update() to process sync
     */
    void update();
    
    /**
     * Register a parameter change from a module
     * Modules call this when their parameters change
     * @param module Module that changed
     * @param paramName Parameter name that changed
     * @param value New parameter value
     */
    void notifyParameterChange(void* module, const std::string& paramName, float value);
    
    /**
     * Get parameter value from a module (for sync system)
     */
    float getParameterValue(void* module, const std::string& paramName) const;
    
    /**
     * Set parameter value in a module (for sync system)
     */
    void setParameterValue(void* module, const std::string& paramName, float value);

private:
    struct Binding {
        void* source;
        std::string sourceParam;
        void* target;
        std::string targetParam;
        std::function<bool()> condition;
        std::atomic<bool> syncing; // Guard to prevent feedback loops
        
        Binding() : source(nullptr), target(nullptr), syncing(false) {}
        
        // Delete copy constructor and assignment (atomic is not copyable)
        Binding(const Binding&) = delete;
        Binding& operator=(const Binding&) = delete;
        
        // Allow move constructor and assignment
        Binding(Binding&& other) noexcept
            : source(other.source)
            , sourceParam(std::move(other.sourceParam))
            , target(other.target)
            , targetParam(std::move(other.targetParam))
            , condition(std::move(other.condition))
            , syncing(other.syncing.load(std::memory_order_acquire))
        {}
        
        Binding& operator=(Binding&& other) noexcept {
            if (this != &other) {
                source = other.source;
                sourceParam = std::move(other.sourceParam);
                target = other.target;
                targetParam = std::move(other.targetParam);
                condition = std::move(other.condition);
                syncing.store(other.syncing.load(std::memory_order_acquire), std::memory_order_release);
            }
            return *this;
        }
    };
    
    std::vector<Binding> bindings;
    
    // Helper to find bindings
    std::vector<size_t> findBindingsForSource(void* source, const std::string& paramName) const;
    std::vector<size_t> findBindingsForTarget(void* target, const std::string& paramName) const;
};

#include "Pattern.h"
#include "ofLog.h"
#include "ofUtils.h"

// PatternCell implementation
//--------------------------------------------------------------
void PatternCell::clear() {
    index = -1;
    length = 1;  // Changed to int
    parameterValues.clear();
    
    // Don't set default parameters here - defaults come from MediaPool/MediaPlayer
    // Empty parameterValues means "use defaults/position memory" when triggering
}

float PatternCell::getParameterValue(const std::string& paramName, float defaultValue) const {
    auto it = parameterValues.find(paramName);
    if (it != parameterValues.end()) {
        return it->second;
    }
    return defaultValue;
}

void PatternCell::setParameterValue(const std::string& paramName, float value) {
    parameterValues[paramName] = value;
}

bool PatternCell::hasParameter(const std::string& paramName) const {
    return parameterValues.find(paramName) != parameterValues.end();
}

void PatternCell::removeParameter(const std::string& paramName) {
    parameterValues.erase(paramName);
}

bool PatternCell::operator==(const PatternCell& other) const {
    if (index != other.index || length != other.length) {
        return false;
    }
    if (parameterValues.size() != other.parameterValues.size()) {
        return false;
    }
    for (const auto& pair : parameterValues) {
        auto it = other.parameterValues.find(pair.first);
        if (it == other.parameterValues.end() || it->second != pair.second) {
            return false;
        }
    }
    return true;
}

bool PatternCell::operator!=(const PatternCell& other) const {
    return !(*this == other);
}

std::string PatternCell::toString() const {
    if (isEmpty()) {
        return "---";
    }
    
    std::string result = "[" + ofToString(index) + "]";
    result += " len:" + ofToString(length);
    
    // Add parameter values
    for (const auto& pair : parameterValues) {
        result += " " + pair.first + ":" + ofToString(pair.second, 2);
    }
    
    return result;
}

// Pattern implementation
//--------------------------------------------------------------
Pattern::Pattern(int numSteps) {
    setStepCount(numSteps);
}

PatternCell& Pattern::getCell(int step) {
    if (!isValidStep(step)) {
        static PatternCell emptyCell;
        ofLogWarning("Pattern") << "Invalid step index: " << step;
        return emptyCell;
    }
    return cells[step];
}

const PatternCell& Pattern::getCell(int step) const {
    if (!isValidStep(step)) {
        static PatternCell emptyCell;
        ofLogWarning("Pattern") << "Invalid step index: " << step;
        return emptyCell;
    }
    return cells[step];
}

void Pattern::setCell(int step, const PatternCell& cell) {
    if (!isValidStep(step)) {
        ofLogWarning("Pattern") << "Invalid step index: " << step;
        return;
    }
    cells[step] = cell;
}

void Pattern::clearCell(int step) {
    if (!isValidStep(step)) {
        return;
    }
    cells[step].clear();
}

void Pattern::clear() {
    for (auto& cell : cells) {
        cell.clear();
    }
}

bool Pattern::isEmpty() const {
    for (const auto& cell : cells) {
        if (!cell.isEmpty()) {
            return false;
        }
    }
    return true;
}

bool Pattern::duplicateRange(int fromStep, int toStep, int destinationStep) {
    // Validate input range
    if (fromStep < 0 || toStep < 0 || destinationStep < 0) {
        ofLogError("Pattern") << "Invalid step index (negative): from=" << fromStep 
                              << ", to=" << toStep << ", dest=" << destinationStep;
        return false;
    }
    
    if (fromStep > toStep) {
        ofLogError("Pattern") << "Invalid range: fromStep (" << fromStep 
                              << ") > toStep (" << toStep << ")";
        return false;
    }
    
    int rangeSize = toStep - fromStep + 1;
    
    // Validate that source range is within bounds
    if (toStep >= (int)cells.size()) {
        ofLogError("Pattern") << "Source range exceeds pattern size: toStep=" << toStep 
                              << ", pattern size=" << cells.size();
        return false;
    }
    
    // Validate that destination range is within bounds
    if (destinationStep + rangeSize - 1 >= (int)cells.size()) {
        ofLogError("Pattern") << "Destination range exceeds pattern size: dest=" << destinationStep 
                              << ", range size=" << rangeSize << ", pattern size=" << cells.size();
        return false;
    }
    
    // Check for overlap (if source and destination overlap, we need to copy to temp first)
    bool hasOverlap = (destinationStep >= fromStep && destinationStep <= toStep) ||
                      (destinationStep + rangeSize - 1 >= fromStep && destinationStep + rangeSize - 1 <= toStep);
    
    if (hasOverlap) {
        // Copy to temporary buffer first to handle overlapping ranges
        std::vector<PatternCell> tempBuffer;
        tempBuffer.reserve(rangeSize);
        for (int i = fromStep; i <= toStep; i++) {
            tempBuffer.push_back(cells[i]);
        }
        
        // Now copy from temp buffer to destination
        for (size_t i = 0; i < tempBuffer.size(); i++) {
            cells[destinationStep + i] = tempBuffer[i];
        }
    } else {
        // No overlap, direct copy
        for (int i = 0; i < rangeSize; i++) {
            cells[destinationStep + i] = cells[fromStep + i];
        }
    }
    
    ofLogNotice("Pattern") << "Duplicated steps " << fromStep << "-" << toStep 
                           << " to position " << destinationStep;
    return true;
}

void Pattern::setStepCount(int steps) {
    if (steps <= 0) {
        ofLogWarning("Pattern") << "Invalid number of steps: " << steps;
        return;
    }
    
    size_t oldSize = cells.size();
    cells.resize(steps);
    
    // Initialize new cells
    for (size_t i = oldSize; i < cells.size(); i++) {
        cells[i] = PatternCell();
    }
}

void Pattern::doubleSteps() {
    int currentSize = (int)cells.size();
    if (currentSize <= 0) {
        ofLogWarning("Pattern") << "Cannot double steps: pattern is empty";
        return;
    }
    
    // Resize to double the current size
    cells.resize(currentSize * 2);
    
    // Duplicate existing cells
    for (int i = 0; i < currentSize; i++) {
        cells[currentSize + i] = cells[i];
    }
    
    ofLogNotice("Pattern") << "Doubled pattern steps from " << currentSize << " to " << (currentSize * 2);
}

ofJson Pattern::toJson() const {
    ofJson patternArray = ofJson::array();
    for (size_t i = 0; i < cells.size(); i++) {
        ofJson cellJson;
        const auto& cell = cells[i];
        cellJson["index"] = cell.index;
        cellJson["length"] = cell.length;
        
        // Save parameter values
        ofJson paramJson = ofJson::object();
        for (const auto& pair : cell.parameterValues) {
            paramJson[pair.first] = pair.second;
        }
        cellJson["parameters"] = paramJson;
        patternArray.push_back(cellJson);
    }
    return patternArray;
}

void Pattern::fromJson(const ofJson& json) {
    if (!json.is_array()) {
        ofLogError("Pattern") << "Invalid JSON format: expected array";
        return;
    }
    
    cells.clear();
    cells.resize(json.size());
    
    for (size_t i = 0; i < json.size(); i++) {
        auto cellJson = json[i];
        PatternCell cell;
        
        // Load fixed fields
        if (cellJson.contains("index")) {
            cell.index = cellJson["index"];
        } else if (cellJson.contains("mediaIndex")) {
            cell.index = cellJson["mediaIndex"]; // Legacy support
        }
        
        if (cellJson.contains("length")) {
            cell.length = cellJson["length"];
        } else if (cellJson.contains("stepLength")) {
            cell.length = cellJson["stepLength"]; // Legacy support
        }
        
        // Load parameter values (new format)
        if (cellJson.contains("parameters") && cellJson["parameters"].is_object()) {
            auto paramJson = cellJson["parameters"];
            for (auto it = paramJson.begin(); it != paramJson.end(); ++it) {
                cell.setParameterValue(it.key(), it.value());
            }
        } else {
            // Legacy: migrate old format to new parameter map
            if (cellJson.contains("position")) cell.setParameterValue("position", cellJson["position"]);
            if (cellJson.contains("speed")) cell.setParameterValue("speed", cellJson["speed"]);
            if (cellJson.contains("volume")) cell.setParameterValue("volume", cellJson["volume"]);
        }
        // Legacy: audioEnabled/videoEnabled fields are ignored (backward compatibility)
        
        cells[i] = cell;
    }
}

#pragma once

#include "ofMain.h"
#include "ofJson.h"
#include <string>
#include <vector>
#include <map>

// PatternCell represents a single step in a tracker pattern
struct PatternCell {
    // Fixed fields (always present)
    int index = -1;              // Media index (-1 = empty/rest, 0+ = media index)
    int length = 1;              // Step length in sequencer steps (1-16, integer count)
    
    // Dynamic parameter values (keyed by parameter name)
    // These use float for precision (position: 0-1, speed: -10 to 10, volume: 0-2)
    std::map<std::string, float> parameterValues;

    PatternCell() = default;
    // Legacy constructor for backward compatibility during migration
    PatternCell(int mediaIdx, float pos, float spd, float vol, float len)
        : index(mediaIdx), length((int)len) {
        // Store old parameters in map for migration
        parameterValues["position"] = pos;
        parameterValues["speed"] = spd;
        parameterValues["volume"] = vol;
    }

    bool isEmpty() const { return index < 0; }
    
    // Parameter access methods
    float getParameterValue(const std::string& paramName, float defaultValue = 0.0f) const;
    void setParameterValue(const std::string& paramName, float value);
    bool hasParameter(const std::string& paramName) const;
    void removeParameter(const std::string& paramName);
    
    // Additional methods
    void clear();
    bool operator==(const PatternCell& other) const;
    bool operator!=(const PatternCell& other) const;
    std::string toString() const;
};

// Pattern represents a complete tracker pattern (sequence of steps)
class Pattern {
public:
    Pattern(int numSteps = 16);
    
    // Cell access
    PatternCell& getCell(int step);
    const PatternCell& getCell(int step) const;
    void setCell(int step, const PatternCell& cell);
    void clearCell(int step);
    
    // Pattern operations
    void clear();
    bool isEmpty() const;
    
    // Multi-step duplication: copy a range of steps to a destination
    // fromStep: inclusive start of source range
    // toStep: inclusive end of source range
    // destinationStep: where to copy the range (overwrites existing cells)
    // Returns true if successful, false if range is invalid
    bool duplicateRange(int fromStep, int toStep, int destinationStep);
    
    // Pattern info
    int getStepCount() const { return (int)cells.size(); }
    void setStepCount(int steps);
    
    // Double the pattern length by duplicating all steps
    void doubleSteps();
    
    // Direct access for performance-critical code (used by GUI)
    PatternCell& operator[](int step) { return cells[step]; }
    const PatternCell& operator[](int step) const { return cells[step]; }
    
    // Serialization
    ofJson toJson() const;
    void fromJson(const ofJson& json);
    
private:
    std::vector<PatternCell> cells;
    
    bool isValidStep(int step) const {
        return step >= 0 && step < (int)cells.size();
    }
};
#include "TrackerSequencer.h"
#include "Clock.h"
#include "Module.h"
#include "ofLog.h"
#include "ofJson.h"
#include "ofxImGui.h"  // Add this line for ImGui support
#include <cmath>  // For std::round
#include <limits>  // For std::numeric_limits

// TrackerSequencer implementation
//--------------------------------------------------------------
TrackerSequencer::TrackerSequencer() 
    : clock(nullptr), stepsPerBeat(4), gatingEnabled(true), playbackStep(0), lastTriggeredStep(-1), 
      playing(false), currentMediaStartStep(-1), 
      currentMediaStepLength(0.0f), 
      sampleAccumulator(0.0), lastBpm(120.0f),
      draggingStep(-1), draggingColumn(-1), lastDragValue(0.0f), dragStartY(0.0f), dragStartX(0.0f),
      stepStartTime(0.0f), stepEndTime(0.0f),
      showGUI(true),
      currentPlayingStep(-1),
      currentPatternIndex(0), currentChainIndex(0), currentChainRepeat(0), usePatternChain(true) {
    // Initialize with one empty pattern (default 16 steps)
    patterns.push_back(Pattern(16));
    // Initialize pattern chain with first pattern
    patternChain.push_back(0);
    patternChainRepeatCounts[0] = 1;
}

TrackerSequencer::~TrackerSequencer() {
}

void TrackerSequencer::setup(Clock* clockRef, int steps) {
    clock = clockRef;
    playbackStep = 0; // Initialize playback step
    // Note: GUI state initialization removed - managed by TrackerSequencerGUI
    
    // Initialize patterns (ensure at least one pattern exists)
    if (patterns.empty()) {
        patterns.push_back(Pattern(steps));
        currentPatternIndex = 0;
    } else {
        // Set step count for current pattern only (per-pattern step count)
        getCurrentPattern().setStepCount(steps);
    }
    
    // Initialize default column configuration if empty
            if (columnConfig.empty()) {
                initializeDefaultColumns();
            }
            
            // Connect to Clock's time events for sample-accurate timing
    if (clock) {
        ofAddListener(clock->timeEvent, this, &TrackerSequencer::onTimeEvent);
        // Sync Clock's SPB with TrackerSequencer's SPB
        clock->setStepsPerBeat(stepsPerBeat);
        
        // Subscribe to Clock transport changes
        clock->addTransportListener([this](bool isPlaying) {
            this->onClockTransportChanged(isPlaying);
        });
    }
    
    ofLogNotice("TrackerSequencer") << "Setup complete with " << getCurrentPattern().getStepCount() << " steps";
}

void TrackerSequencer::setIndexRangeCallback(IndexRangeCallback callback) {
    indexRangeCallback = callback;
}

//--------------------------------------------------------------
void TrackerSequencer::onClockTransportChanged(bool isPlaying) {
    if (isPlaying) {
        // Clock started - start the sequencer from step 1
        play();
        // Reset to step 1 and trigger it
        playbackStep = 0; // Start playback at step 0 (0-based internally, so step 1 is index 0)
        currentPlayingStep = -1;  // Reset current playing step
        stepStartTime = 0.0f;
        stepEndTime = 0.0f;
        triggerStep(0);  // Trigger step 1 (0-based)
        ofLogNotice("TrackerSequencer") << "Clock transport started - sequencer playing from step 1";
    } else {
        // Clock stopped - pause the sequencer (don't reset step)
        pause();
        ofLogNotice("TrackerSequencer") << "Clock transport stopped - sequencer paused at step " << (playbackStep + 1);
    }
}


void TrackerSequencer::setStepCount(int steps) {
    if (steps <= 0) return;
    
    // Only update current pattern (per-pattern step count)
    getCurrentPattern().setStepCount(steps);

    ofLogNotice("TrackerSequencer") << "Step count changed to " << steps << " for current pattern";
}

int TrackerSequencer::getStepCount() const {
    // Returns current pattern's step count
    return getCurrentPattern().getStepCount();
}

// Helper to get current pattern
Pattern& TrackerSequencer::getCurrentPattern() {
    if (patterns.empty()) {
        // Safety: create a pattern if none exist (default 16 steps)
        patterns.push_back(Pattern(16));
        currentPatternIndex = 0;
    }
    if (currentPatternIndex < 0 || currentPatternIndex >= (int)patterns.size()) {
        currentPatternIndex = 0;
    }
    return patterns[currentPatternIndex];
}

const Pattern& TrackerSequencer::getCurrentPattern() const {
    if (patterns.empty() || currentPatternIndex < 0 || currentPatternIndex >= (int)patterns.size()) {
        static Pattern emptyPattern(16);
        return emptyPattern;
    }
    return patterns[currentPatternIndex];
}

void TrackerSequencer::setCell(int step, const PatternCell& cell) {
    if (!isValidStep(step)) return;
    
    // Check if position parameter changed and notify if it's the current playback step
    const PatternCell& oldCell = getCurrentPattern().getCell(step);
    float oldPosition = oldCell.getParameterValue("position", 0.0f);
    float newPosition = cell.getParameterValue("position", 0.0f);
    
    // Update the pattern
    getCurrentPattern().setCell(step, cell);
    
    // Notify if position changed and this is the current playback step
    // Note: Edit step checking removed - GUI state is managed by TrackerSequencerGUI
    // The GUI will handle edit step notifications separately if needed
    if (parameterChangeCallback && std::abs(oldPosition - newPosition) > 0.0001f) {
        if (step == playbackStep) {
            parameterChangeCallback("currentStepPosition", newPosition);
        }
    }
    
    // Removed verbose logging for performance
}

PatternCell TrackerSequencer::getCell(int step) const {
    if (!isValidStep(step)) return PatternCell();
    return getCurrentPattern().getCell(step);
}

void TrackerSequencer::clearCell(int step) {
    if (!isValidStep(step)) return;
    
    getCurrentPattern().clearCell(step);
    
    // Removed verbose logging for performance
}

void TrackerSequencer::clearPattern() {
    getCurrentPattern().clear();
    
    ofLogNotice("TrackerSequencer") << "Pattern cleared";
}

void TrackerSequencer::randomizePattern() {
    if (!indexRangeCallback) {
        ofLogWarning("TrackerSequencer") << "Cannot randomize pattern: IndexRangeCallback not set";
        return;
    }
    
    int numMedia = indexRangeCallback();
    if (numMedia == 0) {
        ofLogWarning("TrackerSequencer") << "Cannot randomize pattern: No media available";
        return;
    }
    
    int stepCount = getCurrentPattern().getStepCount();
    for (int i = 0; i < stepCount; i++) {
        PatternCell cell;
        
        // 70% chance of having a media item, 30% chance of being empty (rest)
        if (ofRandom(1.0f) < 0.7f) {
            cell.index = ofRandom(0, numMedia);
            
            // Use parameter ranges dynamically instead of hardcoded values
            auto posRange = getParameterRange("position");
            auto speedRange = getParameterRange("speed");
            auto volumeRange = getParameterRange("volume");
            
            cell.setParameterValue("position", ofRandom(posRange.first, posRange.second));
            cell.setParameterValue("speed", ofRandom(speedRange.first, speedRange.second));
            // Use 25% to 75% of volume range for randomization (avoiding extremes)
            float volumeRangeSize = volumeRange.second - volumeRange.first;
            cell.setParameterValue("volume", ofRandom(
                volumeRange.first + volumeRangeSize * 0.25f,
                volumeRange.first + volumeRangeSize * 0.75f
            ));
            cell.length = ofRandom(1, stepCount);
        } else {
            cell.clear(); // Empty/rest step
        }
        
        getCurrentPattern().setCell(i, cell);
    }
    
    ofLogNotice("TrackerSequencer") << "Pattern randomized with " << numMedia << " media items";
}

void TrackerSequencer::randomizeColumn(int columnIndex) {
    if (columnIndex < 0 || columnIndex >= (int)columnConfig.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid column index for randomization: " << columnIndex;
        return;
    }
    
    const auto& colConfig = columnConfig[columnIndex];
    
    if (colConfig.parameterName == "index") {
        // Randomize index column
        if (!indexRangeCallback) {
            ofLogWarning("TrackerSequencer") << "Cannot randomize index column: IndexRangeCallback not set";
            return;
        }
        
        int numMedia = indexRangeCallback();
        if (numMedia == 0) {
            ofLogWarning("TrackerSequencer") << "Cannot randomize index column: No media available";
            return;
        }
        
        int stepCount = getCurrentPattern().getStepCount();
        for (int i = 0; i < stepCount; i++) {
            // 70% chance of having a media item, 30% chance of being empty (rest)
            if (ofRandom(1.0f) < 0.7f) {
                getCurrentPattern()[i].index = ofRandom(0, numMedia);
            } else {
                getCurrentPattern()[i].index = -1; // Empty/rest
            }
        }
        ofLogNotice("TrackerSequencer") << "Index column randomized";
    } else if (colConfig.parameterName == "length") {
        // Randomize length column
        int stepCount = getCurrentPattern().getStepCount();
        for (int i = 0; i < stepCount; i++) {
            if (getCurrentPattern()[i].index >= 0) { // Only randomize if step has a media item
                getCurrentPattern()[i].length = ofRandom(1, stepCount + 1);
            }
        }
        ofLogNotice("TrackerSequencer") << "Length column randomized";
    } else {
        // Randomize parameter column
        auto range = getParameterRange(colConfig.parameterName);
        int stepCount = getCurrentPattern().getStepCount();
        for (int i = 0; i < stepCount; i++) {
            if (getCurrentPattern()[i].index >= 0) { // Only randomize if step has a media item
                if (colConfig.parameterName == "volume") {
                    // Use 25% to 75% of volume range for randomization (avoiding extremes)
                    float volumeRangeSize = range.second - range.first;
                    getCurrentPattern()[i].setParameterValue(colConfig.parameterName, ofRandom(
                        range.first + volumeRangeSize * 0.25f,
                        range.first + volumeRangeSize * 0.75f
                    ));
                } else {
                    getCurrentPattern()[i].setParameterValue(colConfig.parameterName, ofRandom(range.first, range.second));
                }
            }
        }
        ofLogNotice("TrackerSequencer") << "Parameter column '" << colConfig.parameterName << "' randomized";
    }
}

void TrackerSequencer::applyLegato() {
    // Apply legato: set each step's length to the number of steps until the next step with a note
    // This creates smooth transitions between steps (no gaps)
    int stepCount = getCurrentPattern().getStepCount();
    for (int i = 0; i < stepCount; i++) {
        if (getCurrentPattern()[i].index >= 0) {
            // This step has a note - find the next step with a note
            int stepsToNext = 1;
            bool foundNext = false;
            
            for (int j = i + 1; j < stepCount; j++) {
                if (getCurrentPattern()[j].index >= 0) {
                    // Found the next step with a note
                    stepsToNext = j - i;
                    foundNext = true;
                    break;
                }
            }
            
            if (foundNext) {
                // Set length to reach the next step (clamp to max 16)
                getCurrentPattern()[i].length = std::min(16, stepsToNext);
            } else {
                // No next step found - keep current length or set to remaining steps
                int remainingSteps = stepCount - i;
                getCurrentPattern()[i].length = std::min(16, remainingSteps);
            }
        }
    }
    ofLogNotice("TrackerSequencer") << "Legato applied to length column";
}

bool TrackerSequencer::duplicateRange(int fromStep, int toStep, int destinationStep) {
    // Delegate to Pattern class
    return getCurrentPattern().duplicateRange(fromStep, toStep, destinationStep);
}

// Timing and playback control
void TrackerSequencer::processAudioBuffer(ofSoundBuffer& buffer) {
    // This method is now deprecated - timing is handled by Clock's beat events
    // Keep for compatibility but do nothing
}

void TrackerSequencer::onTimeEvent(TimeEvent& data) {
    if (!playing) return;
    
    // Only process STEP events (ignore BEAT events)
    if (data.type != TimeEventType::STEP) return;

    // Advance to next step (sample-accurate timing from Clock!)
    advanceStep();
}

//--------------------------------------------------------------
void TrackerSequencer::setStepsPerBeat(int steps) {
    stepsPerBeat = std::max(1, std::min(96, steps));
    updateStepInterval();
    // Sync with Clock's SPB
    if (clock) {
        clock->setStepsPerBeat(stepsPerBeat);
    }
}

void TrackerSequencer::updateStepInterval() {
    if (!clock) return;
    
    // Get steps per beat from pattern sequencer (single source of truth)
    int spb = stepsPerBeat;
    
    // Calculate time between sequencer steps based on BPM and steps per beat
    // For example: 120 BPM with 4 steps per beat = 16th notes
    // Each beat = 60/120 = 0.5 seconds
    // Each step = 0.5 / 4 = 0.125 seconds
    float bpm = clock->getBPM();
    float stepInterval = (60.0f / bpm) / spb;
    
    ofLogNotice("TrackerSequencer") << "Updated timing: SPB=" << spb 
                                   << ", stepInterval=" << stepInterval << "s";
}

void TrackerSequencer::play() {
    playing = true;
    // Reset timing state
    currentPlayingStep = -1;
    stepStartTime = 0.0f;
    stepEndTime = 0.0f;
    // Reset audio-rate timing for fresh start
    sampleAccumulator = 0.0;
}

void TrackerSequencer::pause() {
    playing = false;
    // Clear current playing step so GUI shows inactive state when paused
    // This ensures visual feedback matches the paused state
    currentPlayingStep = -1;
    // Keep playbackStep and timing state for resume (if needed)
}

void TrackerSequencer::stop() {
    playing = false;
    playbackStep = 0; // Reset playback step indicator
    currentPlayingStep = -1;
    stepStartTime = 0.0f;
    stepEndTime = 0.0f;
    // Reset audio-rate timing
    sampleAccumulator = 0.0;
}

void TrackerSequencer::reset() {
    playbackStep = 0; // Reset playback step indicator
    playing = false;
    currentPlayingStep = -1;
    stepStartTime = 0.0f;
    stepEndTime = 0.0f;
    // Reset audio-rate timing
    sampleAccumulator = 0.0;
}

void TrackerSequencer::setCurrentStep(int step) {
    if (isValidStep(step)) {
        playbackStep = step; // Update playback step indicator
    }
}

bool TrackerSequencer::saveState(const std::string& filename) const {
    ofJson json;
    json["currentStep"] = playbackStep;  // Save playback step for backward compatibility
    // Note: GUI state (editStep, etc.) no longer saved here - managed by TrackerSequencerGUI
    
    // Save column configuration
    ofJson columnArray = ofJson::array();
    for (const auto& col : columnConfig) {
        ofJson colJson;
        colJson["parameterName"] = col.parameterName;
        colJson["displayName"] = col.displayName;
        colJson["isFixed"] = col.isFixed;
        colJson["columnIndex"] = col.columnIndex;
        columnArray.push_back(colJson);
    }
    json["columnConfig"] = columnArray;
    
    // Save multi-pattern support
    json["currentPatternIndex"] = currentPatternIndex;
    json["usePatternChain"] = usePatternChain;
    json["currentChainIndex"] = currentChainIndex;
    
    // Save all patterns
    ofJson patternsArray = ofJson::array();
    for (const auto& p : patterns) {
        patternsArray.push_back(p.toJson());
    }
    json["patterns"] = patternsArray;
    
    // Save pattern chain with repeat counts
    ofJson chainArray = ofJson::array();
    for (size_t i = 0; i < patternChain.size(); i++) {
        ofJson entryJson;
        entryJson["patternIndex"] = patternChain[i];
        entryJson["repeatCount"] = getPatternChainRepeatCount((int)i);
        chainArray.push_back(entryJson);
    }
    json["patternChain"] = chainArray;
    json["currentChainRepeat"] = currentChainRepeat;
    
    // Legacy: Save single pattern for backward compatibility
    json["pattern"] = getCurrentPattern().toJson();
    
    ofFile file(filename, ofFile::WriteOnly);
    if (file.is_open()) {
        file << json.dump(4); // Pretty print with 4 spaces
        file.close();
        ofLogNotice("TrackerSequencer") << "State saved to " << filename;
        return true;
    } else {
        ofLogError("TrackerSequencer") << "Failed to save state to " << filename;
        return false;
    }
}

bool TrackerSequencer::loadState(const std::string& filename) {
    ofFile file(filename, ofFile::ReadOnly);
    if (!file.is_open()) {
        ofLogError("TrackerSequencer") << "Failed to load state from " << filename;
        return false;
    }
    
    std::string jsonString = file.readToBuffer().getText();
    file.close();
    
    ofJson json;
    try {
        json = ofJson::parse(jsonString);
    } catch (const std::exception& e) {
        ofLogError("TrackerSequencer") << "Failed to parse JSON: " << e.what();
        return false;
    }
    
    // Load basic properties
    if (json.contains("currentStep")) {
        playbackStep = json["currentStep"];
    }
    // Note: GUI state (editStep, etc.) no longer loaded here - managed by TrackerSequencerGUI
    
    // Load column configuration (migration: use defaults if missing)
    if (json.contains("columnConfig") && json["columnConfig"].is_array()) {
        columnConfig.clear();
        auto columnArray = json["columnConfig"];
        for (const auto& colJson : columnArray) {
            if (colJson.contains("parameterName") && colJson.contains("displayName")) {
                std::string paramName = colJson["parameterName"];
                std::string displayName = colJson["displayName"];
                bool isFixed = colJson.contains("isFixed") ? (bool)colJson["isFixed"] : false;
                int colIndex = colJson.contains("columnIndex") ? (int)colJson["columnIndex"] : (int)columnConfig.size();
                columnConfig.push_back(ColumnConfig(paramName, displayName, isFixed, colIndex));
            }
        }
        
        // Ensure we have at least the fixed columns (index and length)
        // MODULAR: Check for required fixed columns using isFixed flag
        bool hasIndex = false;
        bool hasLength = false;
        for (const auto& col : columnConfig) {
            if (col.isFixed && col.parameterName == "index") hasIndex = true;
            if (col.isFixed && col.parameterName == "length") hasLength = true;
        }
        
        if (!hasIndex || !hasLength || columnConfig.empty()) {
            ofLogNotice("TrackerSequencer") << "Column configuration missing or incomplete, using defaults";
            initializeDefaultColumns();
        }
    } else {
        // Migration: old file format - initialize default columns
        ofLogNotice("TrackerSequencer") << "Old pattern file format detected, initializing default column configuration";
        initializeDefaultColumns();
    }
    
    // Load multi-pattern support (new format)
    if (json.contains("patterns") && json["patterns"].is_array()) {
        patterns.clear();
        auto patternsArray = json["patterns"];
        for (const auto& patternJson : patternsArray) {
            Pattern p(16);  // Default step count - actual count comes from JSON array size
            p.fromJson(patternJson);
            // Pattern size is now per-pattern, so we don't force it to match
            // Each pattern keeps its own step count from JSON
            patterns.push_back(p);
        }
        
        // Load current pattern index
        if (json.contains("currentPatternIndex")) {
            int loadedIndex = json["currentPatternIndex"];
            if (loadedIndex >= 0 && loadedIndex < (int)patterns.size()) {
                currentPatternIndex = loadedIndex;
            } else {
                currentPatternIndex = 0;
            }
        }
        
        // Load pattern chain with repeat counts (support both new and legacy keys)
        ofJson chainArray;
        if (json.contains("patternChain") && json["patternChain"].is_array()) {
            chainArray = json["patternChain"];
        } else if (json.contains("orderList") && json["orderList"].is_array()) {
            // Legacy: support old "orderList" key
            chainArray = json["orderList"];
        }
        
        if (!chainArray.is_null() && chainArray.is_array()) {
            patternChain.clear();
            patternChainRepeatCounts.clear();
            for (size_t i = 0; i < chainArray.size(); i++) {
                const auto& chainEntry = chainArray[i];
                int patternIdx = -1;
                int repeatCount = 1;
                
                // Support both old format (int) and new format (object)
                if (chainEntry.is_number()) {
                    // Legacy format: just pattern index
                    patternIdx = chainEntry;
                } else if (chainEntry.is_object()) {
                    // New format: object with patternIndex and repeatCount
                    if (chainEntry.contains("patternIndex")) {
                        patternIdx = chainEntry["patternIndex"];
                    }
                    if (chainEntry.contains("repeatCount")) {
                        repeatCount = chainEntry["repeatCount"];
                        repeatCount = std::max(1, std::min(99, repeatCount));
                    }
                }
                
                if (patternIdx >= 0 && patternIdx < (int)patterns.size()) {
                    patternChain.push_back(patternIdx);
                    patternChainRepeatCounts[(int)i] = repeatCount;
                    patternChainDisabled[(int)i] = false;  // Default to enabled when loading
                }
            }
        }
        
        // Load pattern chain settings (support both new and legacy keys)
        if (json.contains("usePatternChain")) {
            usePatternChain = json["usePatternChain"];
        } else if (json.contains("useOrderList")) {
            // Legacy: support old "useOrderList" key
            usePatternChain = json["useOrderList"];
        } else {
            // Default to enabled for new files
            usePatternChain = true;
        }
        
        if (json.contains("currentChainIndex")) {
            int loadedChainIndex = json["currentChainIndex"];
            if (loadedChainIndex >= 0 && loadedChainIndex < (int)patternChain.size()) {
                currentChainIndex = loadedChainIndex;
            } else {
                currentChainIndex = 0;
            }
        } else if (json.contains("currentOrderIndex")) {
            // Legacy: support old "currentOrderIndex" key
            int loadedChainIndex = json["currentOrderIndex"];
            if (loadedChainIndex >= 0 && loadedChainIndex < (int)patternChain.size()) {
                currentChainIndex = loadedChainIndex;
            } else {
                currentChainIndex = 0;
            }
        }
        
        if (json.contains("currentChainRepeat")) {
            currentChainRepeat = json["currentChainRepeat"];
        } else if (json.contains("currentOrderRepeat")) {
            // Legacy: support old "currentOrderRepeat" key
            currentChainRepeat = json["currentOrderRepeat"];
        } else {
            currentChainRepeat = 0;
        }
        
        // If pattern chain is empty but enabled, initialize with all patterns
        if (usePatternChain && patternChain.empty() && !patterns.empty()) {
            for (size_t i = 0; i < patterns.size(); i++) {
                patternChain.push_back((int)i);
                patternChainRepeatCounts[(int)i] = 1;
            }
            currentChainIndex = 0;
            currentChainRepeat = 0;
        }
        
        ofLogNotice("TrackerSequencer") << "Loaded " << patterns.size() << " patterns, current pattern: " << currentPatternIndex;
    } else if (json.contains("pattern") && json["pattern"].is_array()) {
        // Legacy: Load single pattern (backward compatibility)
        patterns.clear();
        Pattern p(16);  // Default step count - actual count comes from JSON array size
        p.fromJson(json["pattern"]);
        // Pattern size is now per-pattern, so we don't force it to match
        patterns.push_back(p);
        currentPatternIndex = 0;
        patternChain.clear();
        patternChainRepeatCounts.clear();
        // Initialize pattern chain with the single pattern for legacy files
        patternChain.push_back(0);
        patternChainRepeatCounts[0] = 1;
        usePatternChain = true;  // Enable by default
        currentChainIndex = 0;
        currentChainRepeat = 0;
        ofLogNotice("TrackerSequencer") << "Loaded legacy single pattern format";
    } else {
        // No pattern data - ensure we have at least one empty pattern
        if (patterns.empty()) {
            patterns.push_back(Pattern(16));  // Default step count
            currentPatternIndex = 0;
        }
        // Initialize pattern chain with the first pattern
        if (patternChain.empty() && !patterns.empty()) {
            patternChain.push_back(0);
            patternChainRepeatCounts[0] = 1;
            usePatternChain = true;  // Enable by default
            currentChainIndex = 0;
            currentChainRepeat = 0;
        }
    }
    
    ofLogNotice("TrackerSequencer") << "State loaded from " << filename;
    return true;
}

void TrackerSequencer::addStepEventListener(std::function<void(int, float, const PatternCell&)> listener) {
    stepEventListeners.push_back(listener);
}

void TrackerSequencer::advanceStep() {
    if (!playing) return;
    
    float currentTime = ofGetElapsedTimef();
    
    // Check if current step duration has expired
    bool currentStepExpired = (currentPlayingStep >= 0 && stepEndTime > 0.0f && currentTime >= stepEndTime);
    
    if (currentStepExpired) {
        // Current step finished - clear playing state
        currentPlayingStep = -1;
        stepStartTime = 0.0f;
        stepEndTime = 0.0f;
    }
    
    // Always advance playback step (for visual indicator)
    int stepCount = getCurrentPattern().getStepCount();
    int previousStep = playbackStep;
    playbackStep = (playbackStep + 1) % stepCount;
    
    // Check if we wrapped around (pattern finished)
    bool patternFinished = (playbackStep == 0 && previousStep == stepCount - 1);
    
    // If pattern finished and using pattern chain, handle repeat counts
    if (patternFinished && usePatternChain && !patternChain.empty()) {
        // Increment repeat counter
        currentChainRepeat++;
        
        // Get repeat count for current chain entry (default to 1 if not set)
        int repeatCount = 1;
        auto it = patternChainRepeatCounts.find(currentChainIndex);
        if (it != patternChainRepeatCounts.end()) {
            repeatCount = it->second;
        }
        
        // Check if we've finished all repeats for current chain entry
        if (currentChainRepeat >= repeatCount) {
            // Move to next chain entry (skip disabled entries)
            currentChainRepeat = 0;
            int startIndex = currentChainIndex;
            do {
                currentChainIndex = (currentChainIndex + 1) % (int)patternChain.size();
                // If we've looped back to start and all are disabled, break to avoid infinite loop
                if (currentChainIndex == startIndex) break;
            } while (isPatternChainEntryDisabled(currentChainIndex) && currentChainIndex != startIndex);
        }
        
        // Update current pattern index (only if not disabled)
        if (!isPatternChainEntryDisabled(currentChainIndex)) {
            int nextPatternIdx = patternChain[currentChainIndex];
            if (nextPatternIdx >= 0 && nextPatternIdx < (int)patterns.size()) {
                currentPatternIndex = nextPatternIdx;
                ofLogVerbose("TrackerSequencer") << "Pattern finished, advancing to pattern " << nextPatternIdx 
                                                 << " (chain position " << currentChainIndex 
                                                 << ", repeat " << (currentChainRepeat + 1) << "/" << repeatCount << ")";
            }
        }
    }
    
    // Check if we should trigger the new step
    const PatternCell& newCell = getCell(playbackStep);
    
    // Trigger new step if:
    // 1. No step is currently playing (currentPlayingStep < 0), OR
    // 2. New step has media (index >= 0) - this overrides current playing step
    if (currentPlayingStep < 0 || newCell.index >= 0) {
        triggerStep(playbackStep);
    }
}

void TrackerSequencer::triggerStep(int step) {
    // step is now 0-based internally
    if (!isValidStep(step)) return;
    if (!clock) return;
    
    // Apply any pending edit for this step before triggering
    if (pendingEdit.step == step && pendingEdit.step >= 0) {
        applyPendingEdit();
        // Clear pending edit after applying
        pendingEdit = PendingEdit();
    }

    const PatternCell& cell = getCell(step); // Direct 0-based array access
    float bpm = clock->getBPM();
    
    playbackStep = step;
    
    // Calculate duration in seconds (same for both manual and playback)
    float stepLength = cell.index >= 0 ? (float)cell.length : 1.0f;
    float duration = (stepLength * 60.0f) / (bpm * stepsPerBeat);
    
    // Set timing for ALL triggers (unified for manual and playback)
    if (cell.index >= 0) {
        float currentTime = ofGetElapsedTimef();
        stepStartTime = currentTime;
        stepEndTime = currentTime + duration;
        currentPlayingStep = step;
    } else {
        // Empty step - clear playing state
        currentPlayingStep = -1;
        stepStartTime = 0.0f;
        stepEndTime = 0.0f;
    }
    
    // Create TriggerEvent with TrackerSequencer parameters
    // TrackerSequencer exposes its own parameters (note, position, speed, volume)
    // Modules will map these to their own parameters
    TriggerEvent triggerEvt;
    triggerEvt.duration = duration;
    
    // Map PatternCell parameters to TrackerSequencer parameters
    // "note" is the sequencer's parameter name (maps to cell.index for MediaPool)
    if (cell.index >= 0) {
        triggerEvt.parameters["note"] = (float)cell.index;
    } else {
        triggerEvt.parameters["note"] = -1.0f; // Rest/empty step
    }
    
    // MODULAR: Iterate through all available parameters dynamically
    // Only add parameters to event if they are explicitly set in the cell
    // This allows position memory: if position is not set, MediaPool will use current position
    auto availableParams = getAvailableParameters();
    for (const auto& param : availableParams) {
        // Skip "note" - it's handled separately above
        if (param.name == "note") continue;
        
        // Only add parameter if explicitly set in cell
        // If not set, don't add to event - Module will use default or position memory
        if (cell.hasParameter(param.name)) {
            float value = cell.getParameterValue(param.name, param.defaultValue);
            // Validate value using parameter ranges (clamp to valid range)
            float clampedValue = std::max(param.minValue, std::min(param.maxValue, value));
            triggerEvt.parameters[param.name] = clampedValue;
        }
        // If parameter NOT set, don't add to event - Module will handle defaults/position memory
    }
    
    // Broadcast trigger event to all subscribers (modular!)
    // NOTE: ofNotifyEvent is called from audio thread - this is acceptable for event dispatch
    // The actual handlers (MediaPool::onTrigger) now use lock-free queue
    ofNotifyEvent(triggerEvent, triggerEvt);
    
    // Legacy: Also notify old event system for backward compatibility
    // Optimized: Pass cell and duration directly to avoid redundant lookups
    if (!stepEventListeners.empty()) {
        float noteDuration = duration; // Already calculated above
        int step1Based = step + 1; // Convert to 1-based for display
        for (auto& callback : stepEventListeners) {
            callback(step1Based, noteDuration, cell);
        }
    }
    
    // NO LOGGING IN AUDIO THREAD - removed ofLogVerbose calls
}

///MARK: - DRAW
// GUI drawing methods have been moved to TrackerSequencerGUI class
// All ImGui drawing code is now in TrackerSequencerGUI::draw() and related methods

void TrackerSequencer::handleMouseClick(int x, int y, int button) {
    // Handle pattern grid clicks
    if (showGUI) {
        handlePatternGridClick(x, y);
    }
}

bool TrackerSequencer::handleKeyPress(int key, bool ctrlPressed, bool shiftPressed, GUIState& guiState) {
    // If a cell is selected (editStep/editColumn are valid), delegate to ParameterCell
    // This handles both editing cells and selected cells (for auto-entering edit mode)
    if (isValidStep(guiState.editStep) && guiState.editColumn > 0) {
        // Create ParameterCell for current cell and delegate keyboard handling
        ParameterCell cell = createParameterCellForColumn(guiState.editStep, guiState.editColumn);
        
        // Sync state from GUI state to ParameterCell
        cell.isSelected = true;
        if (guiState.isEditingCell) {
            // Set editing state first (this will initialize buffer with current value)
            cell.setEditing(true);
            // Then restore the cached buffer to preserve state across frames
            // This overwrites the initialized buffer with the cached one
            cell.setEditBuffer(guiState.editBufferCache, guiState.editBufferInitializedCache);
        } else {
            cell.setEditing(false);
        }
        
        // Delegate keyboard handling to ParameterCell
        bool handled = cell.handleKeyPress(key, ctrlPressed, shiftPressed);
        
        if (handled) {
            // Check state changes BEFORE syncing
            bool wasEditing = guiState.isEditingCell;
            bool nowEditing = cell.isEditingMode();
            
            // Sync edit mode state back from ParameterCell to GUI state
            guiState.isEditingCell = nowEditing;
            // Cache edit buffer for persistence across frames (ParameterCell owns the logic)
            if (nowEditing) {
                guiState.editBufferCache = cell.getEditBuffer();
                guiState.editBufferInitializedCache = cell.isEditBufferInitialized();
            } else {
                guiState.editBufferCache.clear();
                guiState.editBufferInitializedCache = false;
            }
            
            // If ParameterCell entered edit mode, sync that
            if (nowEditing && !wasEditing) {
                // Disable ImGui keyboard navigation when entering edit mode
                ImGuiIO& io = ImGui::GetIO();
                io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableKeyboard;
            }
            
            // If ParameterCell exited edit mode, sync that too
            if (!nowEditing && wasEditing) {
                // Re-enable ImGui keyboard navigation when exiting edit mode
                ImGuiIO& io = ImGui::GetIO();
                io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
            }
            return true;
        }
        // If ParameterCell didn't handle it, fall through to grid navigation logic
    }
    
    // Handle keyboard shortcuts for pattern editing (grid navigation)
    switch (key) {
        // Enter key behavior:
        // - Enter on step number column (editColumn == 0): Trigger step
        // - Enter on data column: Enter/exit edit mode
        case OF_KEY_RETURN:
            if (ctrlPressed || shiftPressed) {
                // Ctrl+Enter or Shift+Enter: Exit grid navigation
                ofLogNotice("TrackerSequencer") << "[DEBUG] [SET editStep] Ctrl/Shift+Enter - clearing editStep to -1";
                // If we were in edit mode, restore ImGui keyboard navigation
                if (guiState.isEditingCell) {
                    ImGuiIO& io = ImGui::GetIO();
                    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
                }
                guiState.editStep = -1;
                guiState.editColumn = -1;
                guiState.isEditingCell = false;
                guiState.editBufferCache.clear();
                guiState.editBufferInitializedCache = false;
                return true;
            }
            
            if (guiState.isEditingCell) {
                // Should have been handled by ParameterCell above, but handle fallback
                if (isValidStep(guiState.editStep) && guiState.editColumn > 0) {
                    ParameterCell cell = createParameterCellForColumn(guiState.editStep, guiState.editColumn);
                    cell.isSelected = true;
                    cell.setEditing(true);
                    cell.applyValue(); // Confirm edit
                }
                guiState.isEditingCell = false;
                guiState.editBufferCache.clear();
                guiState.editBufferInitializedCache = false;
                
                // Re-enable ImGui keyboard navigation when exiting edit mode
                ImGuiIO& io = ImGui::GetIO();
                io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
                
                return true;
            } else if (isValidStep(guiState.editStep) && guiState.editColumn >= 0) {
                if (guiState.editColumn == 0) {
                    // Step number column: Trigger step
                    triggerStep(guiState.editStep);
                    return true;
                }
                // Data column: Enter edit mode
                if (guiState.editColumn > 0 && guiState.editColumn <= (int)columnConfig.size()) {
                    guiState.isEditingCell = true;
                    // Initialize via ParameterCell (ParameterCell manages its own edit buffer)
                    ParameterCell cell = createParameterCellForColumn(guiState.editStep, guiState.editColumn);
                    cell.isSelected = true;
                    cell.enterEditMode();
                    // Cache edit buffer after entering edit mode
                    guiState.editBufferCache = cell.getEditBuffer();
                    guiState.editBufferInitializedCache = cell.isEditBufferInitialized();
                    
                    // CRITICAL: Disable ImGui keyboard navigation when entering edit mode
                    ImGuiIO& io = ImGui::GetIO();
                    io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableKeyboard;
                    
                    return true;
                }
                return false;
            } else {
                // No cell selected - check if we're on header row
                if (guiState.editStep == -1 && !guiState.isEditingCell) {
                    // On header row - don't select first cell, let ImGui handle it
                    return false;
                }
                // No cell selected: Enter grid and select first data cell
                int stepCount = getCurrentPattern().getStepCount();
                if (stepCount > 0 && !columnConfig.empty()) {
                    ofLogNotice("TrackerSequencer") << "[DEBUG] [SET editStep] Enter key - setting editStep to 0, editColumn to 1 (Enter grid)";
                    guiState.editStep = 0;
                    guiState.editColumn = 1;
                    guiState.isEditingCell = false;
                    guiState.editBufferCache.clear();
                    guiState.editBufferInitializedCache = false;
                    return true;
                }
            }
            return false;
            
        // Escape: Exit edit mode (should be handled by ParameterCell, but handle fallback)
        case OF_KEY_ESC:
            if (guiState.isEditingCell) {
                guiState.isEditingCell = false;
                guiState.editBufferCache.clear();
                guiState.editBufferInitializedCache = false;
                
                // CRITICAL: Re-enable ImGui keyboard navigation when exiting edit mode
                ImGuiIO& io = ImGui::GetIO();
                io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
                
                return true;
            }
            return false;
            
        // Backspace and Delete: Should be handled by ParameterCell above
        case OF_KEY_BACKSPACE:
        case OF_KEY_DEL:
            // These should have been handled by ParameterCell if in edit mode
            return false;
            
        // Tab: Always let ImGui handle for panel navigation
        // (Exit edit mode is handled by clicking away or pressing Escape)
        case OF_KEY_TAB:
            return false; // Always let ImGui handle Tab for panel/window navigation
            
        // Arrow keys: 
        // - Cmd+Arrow Up/Down: Move playback step (walk through steps)
        // - In edit mode: Adjust values ONLY (no navigation) - handled by ParameterCell
        // - Not in edit mode: Let ImGui handle navigation between cells
        case OF_KEY_UP:
            if (ctrlPressed && !guiState.isEditingCell) {
                // Cmd+Up: Move playback step up
                if (isValidStep(guiState.editStep)) {
                    int stepCount = getCurrentPattern().getStepCount();
                    playbackStep = (playbackStep - 1 + stepCount) % stepCount;
                    triggerStep(playbackStep);
                    return true;
                }
                return false;
            }
            if (guiState.isEditingCell) {
                // In edit mode: Should be handled by ParameterCell above
                // Fallback: adjust value directly
                if (isValidStep(guiState.editStep) && guiState.editColumn > 0) {
                    ParameterCell cell = createParameterCellForColumn(guiState.editStep, guiState.editColumn);
                    cell.isSelected = true;
                    cell.setEditing(true);
                    cell.adjustValue(1);
                    return true;
                }
                return false;
            }
            // Not in edit mode: Navigate to cell above
            if (isValidStep(guiState.editStep) && guiState.editColumn >= 0) {
                if (guiState.editStep > 0) {
                    // Move to cell above (same column)
                    guiState.editStep--;
                    return true;
                } else {
                    // At top of grid - exit grid focus to allow navigation to other widgets
                    guiState.editStep = -1;
                    guiState.editColumn = -1;
                    guiState.isEditingCell = false;
                    guiState.editBufferCache.clear();
                    guiState.editBufferInitializedCache = false;
                    return false; // Let ImGui handle navigation to other widgets
                }
            }
            // Not in edit mode: Check if on header row (editStep == -1 means no cell focused, likely on header)
            if (guiState.editStep == -1 && !guiState.isEditingCell) {
                // On header row - clear cell focus and let ImGui handle navigation naturally
                guiState.editStep = -1;
                guiState.editColumn = -1;
                guiState.isEditingCell = false;
                guiState.editBufferCache.clear();
                guiState.editBufferInitializedCache = false;
                return false; // Let ImGui handle the UP key to navigate to other widgets
            }
            // Not in edit mode: Let ImGui handle navigation
            return false;
            
        case OF_KEY_DOWN: {
            if (ctrlPressed && !guiState.isEditingCell) {
                // Cmd+Down: Move playback step down
                if (isValidStep(guiState.editStep)) {
                    int stepCount = getCurrentPattern().getStepCount();
                    playbackStep = (playbackStep + 1) % stepCount;
                    triggerStep(playbackStep);
                    return true;
                }
                return false;
            }
            if (guiState.isEditingCell) {
                // In edit mode: Should be handled by ParameterCell above
                // Fallback: adjust value directly
                if (isValidStep(guiState.editStep) && guiState.editColumn > 0) {
                    ParameterCell cell = createParameterCellForColumn(guiState.editStep, guiState.editColumn);
                    cell.isSelected = true;
                    cell.setEditing(true);
                    cell.adjustValue(-1);
                    return true;
                }
                return false;
            }
            // Not in edit mode: Navigate to cell below
            if (isValidStep(guiState.editStep) && guiState.editColumn >= 0) {
                int stepCount = getCurrentPattern().getStepCount();
                if (guiState.editStep < stepCount - 1) {
                    // Move to cell below (same column)
                    guiState.editStep++;
                    return true;
                } else {
                    // At bottom of grid - exit grid focus to allow navigation to other widgets
                    guiState.editStep = -1;
                    guiState.editColumn = -1;
                    guiState.isEditingCell = false;
                    guiState.editBufferCache.clear();
                    guiState.editBufferInitializedCache = false;
                    return false; // Let ImGui handle navigation to other widgets
                }
            }
            // Not in edit mode: Let ImGui handle navigation
            return false;
        }
            
        case OF_KEY_LEFT:
            if (guiState.isEditingCell) {
                // In edit mode: Should be handled by ParameterCell above
                // Fallback: adjust value directly
                if (isValidStep(guiState.editStep) && guiState.editColumn > 0) {
                    ParameterCell cell = createParameterCellForColumn(guiState.editStep, guiState.editColumn);
                    cell.isSelected = true;
                    cell.setEditing(true);
                    cell.adjustValue(-1);
                    return true;
                }
                return false;
            }
            // Not in edit mode: Navigate to cell to the left
            if (isValidStep(guiState.editStep) && guiState.editColumn >= 0) {
                if (guiState.editColumn > 1) {
                    // Move to cell to the left (decrement column)
                    guiState.editColumn--;
                    return true;
                } else if (guiState.editColumn == 1) {
                    // At first data column - move to step number column (column 0)
                    guiState.editColumn = 0;
                    return true;
                } else {
                    // At step number column (column 0) - exit grid focus
                    return false;
                }
            }
            // Not in edit mode: Let ImGui handle navigation
            return false;
            
        case OF_KEY_RIGHT:
            if (guiState.isEditingCell) {
                // In edit mode: Should be handled by ParameterCell above
                // Fallback: adjust value directly
                if (isValidStep(guiState.editStep) && guiState.editColumn > 0) {
                    ParameterCell cell = createParameterCellForColumn(guiState.editStep, guiState.editColumn);
                    cell.isSelected = true;
                    cell.setEditing(true);
                    cell.adjustValue(1);
                    return true;
                }
                return false;
            }
            // Not in edit mode: Navigate to cell to the right
            if (isValidStep(guiState.editStep) && guiState.editColumn >= 0) {
                int maxColumn = (int)columnConfig.size();
                if (guiState.editColumn == 0) {
                    // At step number column - move to first data column (column 1)
                    guiState.editColumn = 1;
                    return true;
                } else if (guiState.editColumn < maxColumn) {
                    // Move to cell to the right (increment column)
                    guiState.editColumn++;
                    return true;
                } else {
                    // At rightmost column - exit grid focus
                    return false;
                }
            }
            // Not in edit mode: Let ImGui handle navigation
            return false;
            
        // Pattern editing - all operations use editStep
        case 'c':
        case 'C':
            if (isValidStep(guiState.editStep)) {
                clearCell(guiState.editStep);
                return true;
            }
            break;
            
        case 'x':
        case 'X':
            // Copy from previous step
            if (isValidStep(guiState.editStep) && guiState.editStep > 0) {
                        getCurrentPattern().setCell(guiState.editStep, getCurrentPattern().getCell(guiState.editStep - 1));
                return true;
            }
            break;
            
        // Numeric input (0-9) - Blender-style: direct typing enters edit mode and starts editing
        // This should be handled by ParameterCell if in edit mode, but handle auto-enter and media selection
        case '0': case '1': case '2': case '3': case '4': case '5': 
        case '6': case '7': case '8': case '9': {
            // If not in edit mode, check if we should auto-enter edit mode or handle media selection
            if (!guiState.isEditingCell) {
                // Check if we have a valid cell focused
                if (isValidStep(guiState.editStep) && guiState.editColumn > 0 && guiState.editColumn <= (int)columnConfig.size()) {
                    // We have a valid cell: enter edit mode and delegate to ParameterCell
                    // Use the general handler approach to ensure proper state management
                    guiState.isEditingCell = true;
                    ParameterCell cell = createParameterCellForColumn(guiState.editStep, guiState.editColumn);
                    cell.isSelected = true;
                    // Enter edit mode (this initializes buffer with current value)
                    cell.enterEditMode();
                    // For direct typing, clear the buffer so the digit replaces the current value
                    // ParameterCell's handleKeyPress will handle clearing on first digit
                    // But we need to ensure the buffer is cleared for direct typing
                    cell.setEditBuffer("", false);
                    
                    // Disable ImGui keyboard navigation when entering edit mode
                    ImGuiIO& io = ImGui::GetIO();
                    io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableKeyboard;
                    
                    // Now handle the digit key via ParameterCell
                    cell.handleKeyPress(key, ctrlPressed, shiftPressed);
                    // Cache edit buffer after handling key
                    guiState.editBufferCache = cell.getEditBuffer();
                    guiState.editBufferInitializedCache = cell.isEditBufferInitialized();
                    return true;
                } else if (isValidStep(guiState.editStep) && guiState.editColumn == 1) {
                    // Not in edit mode and on index column: media selection (1-9, 0) for quick selection
                    if (key == '0') {
                        // Clear media index (rest)
                        getCurrentPattern()[guiState.editStep].index = -1;
                        return true;
                    } else {
                        int mediaIndex = key - '1';
                        if (indexRangeCallback && mediaIndex < indexRangeCallback()) {
                            getCurrentPattern()[guiState.editStep].index = mediaIndex;
                            return true;
                        }
                    }
                } else {
                    // No valid cell focused - don't auto-enter edit mode
                    ofLogNotice("TrackerSequencer") << "[DEBUG] Digit key ignored - no cell focused (editStep=" << guiState.editStep << ", editColumn=" << guiState.editColumn << ")";
                    return false;
                }
            }
            // If already in edit mode, should have been handled by ParameterCell delegation above
            break;
        }
        
        // Decimal point and minus sign for numeric input
        // This should be handled by ParameterCell if in edit mode, but handle auto-enter
        case '.':
        case '-': {
            // If not in edit mode, auto-enter edit mode if we have a valid cell focused
            if (!guiState.isEditingCell) {
                // Check if we have a valid cell focused
                if (isValidStep(guiState.editStep) && guiState.editColumn > 0 && guiState.editColumn <= (int)columnConfig.size()) {
                    // We have a valid cell: enter edit mode and delegate to ParameterCell
                    guiState.isEditingCell = true;
                    ParameterCell cell = createParameterCellForColumn(guiState.editStep, guiState.editColumn);
                    cell.isSelected = true;
                    // Enter edit mode (this initializes buffer with current value)
                    cell.enterEditMode();
                    // For direct typing, clear the buffer so the decimal/minus replaces the current value
                    cell.setEditBuffer("", false);
                    
                    // Disable ImGui keyboard navigation when entering edit mode
                    ImGuiIO& io = ImGui::GetIO();
                    io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableKeyboard;
                    
                    // Now handle the decimal/minus key via ParameterCell
                    cell.handleKeyPress(key, ctrlPressed, shiftPressed);
                    // Cache edit buffer after handling key
                    guiState.editBufferCache = cell.getEditBuffer();
                    guiState.editBufferInitializedCache = cell.isEditBufferInitialized();
                    return true;
                } else {
                    // No valid cell focused - don't auto-enter edit mode
                    ofLogNotice("TrackerSequencer") << "[DEBUG] Decimal/minus key ignored - no cell focused (editStep=" << guiState.editStep << ", editColumn=" << guiState.editColumn << ")";
                    return false;
                }
            }
            // If already in edit mode, should have been handled by ParameterCell delegation above
            break;
        }
        
        // Note: Numpad keys are already handled above - openFrameworks converts
        // numpad 0-9 to regular '0'-'9' characters and numpad Enter to OF_KEY_RETURN
        // So numpad support works automatically!
        
    }
    return false;
}

// Private methods
//--------------------------------------------------------------

// GUI drawing methods (drawPatternRow, drawStepNumber, drawParameterCell) 
// have been moved to TrackerSequencerGUI class

// drawAudioEnabled and drawVideoEnabled removed - A/V toggles no longer used

bool TrackerSequencer::handlePatternGridClick(int x, int y) {
    // Calculate grid position (simplified - would need proper coordinate mapping)
    // This is a placeholder implementation
    return false;
}

bool TrackerSequencer::handlePatternRowClick(int step, int column) {
    // Unused - cycling functionality removed
    return false;
}

// toggleAudio and toggleVideo removed - A/V toggles no longer used
// Audio/video always enabled when available

// Additional missing method implementations
//--------------------------------------------------------------
bool TrackerSequencer::isValidStep(int step) const {
    return step >= 0 && step < getCurrentPattern().getStepCount();
}

// Column configuration methods
//--------------------------------------------------------------
void TrackerSequencer::initializeDefaultColumns() {
    columnConfig.clear();
    columnConfig.push_back(ColumnConfig("index", "Index", true, 0));      // Fixed
    columnConfig.push_back(ColumnConfig("length", "Length", true, 1));    // Fixed
    columnConfig.push_back(ColumnConfig("position", "Position", false, 2));
    columnConfig.push_back(ColumnConfig("speed", "Speed", false, 3));
    columnConfig.push_back(ColumnConfig("volume", "Volume", false, 4));
}

void TrackerSequencer::addColumn(const std::string& parameterName, const std::string& displayName, int position) {
    // Don't allow duplicate parameter names
    for (const auto& col : columnConfig) {
        if (col.parameterName == parameterName) {
            ofLogWarning("TrackerSequencer") << "Column for parameter '" << parameterName << "' already exists";
            return;
        }
    }
    
    int insertPos = (position < 0 || position >= (int)columnConfig.size()) ? (int)columnConfig.size() : position;
    
    // Insert at specified position
    columnConfig.insert(columnConfig.begin() + insertPos, ColumnConfig(parameterName, displayName, false, insertPos));
    
    // Update column indices
    for (size_t i = 0; i < columnConfig.size(); i++) {
        columnConfig[i].columnIndex = (int)i;
    }
}

void TrackerSequencer::removeColumn(int columnIndex) {
    if (columnIndex < 0 || columnIndex >= (int)columnConfig.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid column index: " << columnIndex;
        return;
    }
    
    // Don't allow removing fixed columns
    if (columnConfig[columnIndex].isFixed) {
        ofLogWarning("TrackerSequencer") << "Cannot remove fixed column: " << columnConfig[columnIndex].parameterName;
        return;
    }
    
    columnConfig.erase(columnConfig.begin() + columnIndex);
    
    // Update column indices
    for (size_t i = 0; i < columnConfig.size(); i++) {
        columnConfig[i].columnIndex = (int)i;
    }
}

void TrackerSequencer::reorderColumn(int fromIndex, int toIndex) {
    if (fromIndex < 0 || fromIndex >= (int)columnConfig.size() ||
        toIndex < 0 || toIndex >= (int)columnConfig.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid column indices for reorder: " << fromIndex << " -> " << toIndex;
        return;
    }
    
    // Don't allow moving fixed columns
    if (columnConfig[fromIndex].isFixed) {
        ofLogWarning("TrackerSequencer") << "Cannot move fixed column: " << columnConfig[fromIndex].parameterName;
        return;
    }
    
    // Move the column
    ColumnConfig col = columnConfig[fromIndex];
    columnConfig.erase(columnConfig.begin() + fromIndex);
    columnConfig.insert(columnConfig.begin() + toIndex, col);
    
    // Update column indices
    for (size_t i = 0; i < columnConfig.size(); i++) {
        columnConfig[i].columnIndex = (int)i;
    }
}

bool TrackerSequencer::isColumnFixed(int columnIndex) const {
    if (columnIndex < 0 || columnIndex >= (int)columnConfig.size()) {
        return false;
    }
    return columnConfig[columnIndex].isFixed;
}

const TrackerSequencer::ColumnConfig& TrackerSequencer::getColumnConfig(int columnIndex) const {
    static ColumnConfig emptyConfig;
    if (columnIndex < 0 || columnIndex >= (int)columnConfig.size()) {
        return emptyConfig;
    }
    return columnConfig[columnIndex];
}

int TrackerSequencer::getColumnCount() const {
    return (int)columnConfig.size();
}

// Dynamic column drawing - drawParameterCell() has been moved to TrackerSequencerGUI class

// Edit mode helpers
//--------------------------------------------------------------
// Legacy edit methods removed - use ParameterCell methods instead
// The pending edit queue is handled via ParameterCell callbacks

bool TrackerSequencer::shouldQueueEdit(int editStep, int editColumn) const {
    return playing && isValidStep(editStep) && editStep == playbackStep && editColumn > 0;
}

void TrackerSequencer::applyPendingEdit() {
    if (!isValidStep(pendingEdit.step)) {
        return;
    }
    
    auto& cell = getCurrentPattern()[pendingEdit.step];
    
    if (pendingEdit.shouldRemove) {
        cell.removeParameter(pendingEdit.parameterName);
        setCell(pendingEdit.step, cell);
    } else if (pendingEdit.isLength) {
        cell.length = pendingEdit.lengthValue;
        setCell(pendingEdit.step, cell);
    } else if (pendingEdit.isIndex) {
        cell.index = pendingEdit.indexValue;
        setCell(pendingEdit.step, cell);
    } else if (!pendingEdit.parameterName.empty()) {
        auto range = getParameterRange(pendingEdit.parameterName);
        float clampedValue = std::max(range.first, std::min(range.second, pendingEdit.value));
        cell.setParameterValue(pendingEdit.parameterName, clampedValue);
        setCell(pendingEdit.step, cell);
    }
}

// initializeEditBuffer() removed - use ParameterCell::enterEditMode() instead
// ParameterCell manages its own edit buffer initialization

// Expose TrackerSequencer parameters for discovery
//--------------------------------------------------------------
// Module interface implementation
//--------------------------------------------------------------
std::vector<ParameterDescriptor> TrackerSequencer::getParameters() {
    return getAvailableParameters();
}

void TrackerSequencer::onTrigger(TriggerEvent& event) {
    // Sequencers don't receive triggers - they generate them
    // This method must exist to satisfy Module interface, but does nothing
}

void TrackerSequencer::setParameter(const std::string& paramName, float value, bool notify) {
    // Sequencers don't have settable parameters in the traditional sense
    // Parameters are set per-step via pattern cells
    // This method exists for Module interface compliance but does nothing
    if (notify && parameterChangeCallback) {
        parameterChangeCallback(paramName, value);
    }
}

bool TrackerSequencer::handleKeyPress(ofKeyEventArgs& keyEvent, GUIState& guiState) {
    // Convert ofKeyEventArgs to existing handleKeyPress signature
    int key = keyEvent.key;
    bool ctrlPressed = keyEvent.hasModifier(OF_KEY_CONTROL);
    bool shiftPressed = keyEvent.hasModifier(OF_KEY_SHIFT);
    return handleKeyPress(key, ctrlPressed, shiftPressed, guiState);
}

std::vector<ParameterDescriptor> TrackerSequencer::getAvailableParameters() const {
    std::vector<ParameterDescriptor> params;
    
    // TrackerSequencer exposes its own parameters
    // These are the parameters that the sequencer sends in trigger events
    // Receivers map these to their own parameters (e.g., note â†’ mediaIndex)
    params.push_back(ParameterDescriptor("note", ParameterType::INT, 0.0f, 127.0f, 60.0f, "Note"));
    params.push_back(ParameterDescriptor("position", ParameterType::FLOAT, 0.0f, 1.0f, 0.0f, "Position"));
    params.push_back(ParameterDescriptor("speed", ParameterType::FLOAT, -10.0f, 10.0f, 1.0f, "Speed"));
    params.push_back(ParameterDescriptor("volume", ParameterType::FLOAT, 0.0f, 2.0f, 1.0f, "Volume")); // Default to 1.0 (normal volume)
    
    return params;
}

bool TrackerSequencer::isPatternEmpty() const {
    return getCurrentPattern().isEmpty();
}

void TrackerSequencer::notifyStepEvent(int step, float stepLength) {
    // step is 1-based from PatternSequencer, convert to 0-based for internal access
    const PatternCell& cell = getCell(step - 1);
    float bpm = clock ? clock->getBPM() : 120.0f;
    
    // Calculate duration in seconds using patternSequencer's stepsPerBeat
    int spb = stepsPerBeat;
    float stepDuration = (60.0f / bpm) / spb;  // Duration of ONE step
    float noteDuration = stepDuration * stepLength;     // Duration for THIS note
    
    for (auto& callback : stepEventListeners) {
        callback(step, noteDuration, cell);  // Pass 1-based step number for display
    }
}

float TrackerSequencer::getCurrentStepPosition() const {
    // Note: GUI state (editStep, editColumn) is now managed by TrackerSequencerGUI
    // This method now only returns position for the playback step
    // The GUI should handle edit step position separately if needed
    if (!isValidStep(playbackStep)) {
        return 0.0f;
    }
    
    const PatternCell& cell = getCurrentPattern()[playbackStep];
    return cell.getParameterValue("position", 0.0f);
}

void TrackerSequencer::setCurrentStepPosition(float position) {
    // Note: GUI state (editStep, editColumn, isEditingCell) is now managed by TrackerSequencerGUI
    // This method now only sets position for the playback step
    // The GUI should handle edit step position separately if needed
    
    // Clamp position to valid range
    position = std::max(0.0f, std::min(1.0f, position));
    
    if (!isValidStep(playbackStep)) {
        return;
    }
    
    PatternCell& cell = getCurrentPattern()[playbackStep];
    float oldValue = cell.getParameterValue("position", 0.0f);
    
    // Only update if value actually changed to avoid unnecessary notifications
    if (std::abs(oldValue - position) > 0.0001f) {
        cell.setParameterValue("position", position);
        // Use setCell to properly update the pattern and trigger notifications
        setCell(playbackStep, cell);
    }
}

float TrackerSequencer::getCurrentBpm() const {
    return clock ? clock->getBPM() : 120.0f;
}

// Parameter range conversion helpers
// These use actual parameter ranges from getAvailableParameters() dynamically
//--------------------------------------------------------------
std::pair<float, float> TrackerSequencer::getParameterRange(const std::string& paramName) {
    // MODULAR: Use getAvailableParameters() to get ranges dynamically
    // Create temporary instance to call getAvailableParameters() (it's non-static but doesn't depend on instance state)
    static TrackerSequencer tempInstance;
    auto params = tempInstance.getAvailableParameters();
    for (const auto& param : params) {
        if (param.name == paramName) {
            return std::make_pair(param.minValue, param.maxValue);
        }
    }
    // Default range for unknown parameters
    return std::make_pair(0.0f, 1.0f);
}

// Static helper to get default value
// MODULAR: Uses getAvailableParameters() dynamically instead of hardcoding
float TrackerSequencer::getParameterDefault(const std::string& paramName) {
    // MODULAR: Use getAvailableParameters() to get defaults dynamically
    // Create temporary instance to call getAvailableParameters() (it's non-static but doesn't depend on instance state)
    static TrackerSequencer tempInstance;
    auto params = tempInstance.getAvailableParameters();
    for (const auto& param : params) {
        if (param.name == paramName) {
            return param.defaultValue;
        }
    }
    // Fallback default
    return 0.0f;
}

// MODULAR: Get parameter type dynamically from getAvailableParameters()
ParameterType TrackerSequencer::getParameterType(const std::string& paramName) {
    static TrackerSequencer tempInstance;
    auto params = tempInstance.getAvailableParameters();
    for (const auto& param : params) {
        if (param.name == paramName) {
            return param.type;
        }
    }
    // Default to FLOAT for unknown parameters
    return ParameterType::FLOAT;
}

// MODULAR: Format parameter value based on parameter type, not hardcoded names
std::string TrackerSequencer::formatParameterValue(const std::string& paramName, float value) {
    ParameterType type = getParameterType(paramName);
    char buf[16];
    
    if (type == ParameterType::INT) {
        // Integer parameters: no decimal places
        snprintf(buf, sizeof(buf), "%d", (int)std::round(value));
    } else {
        // Float parameters: 2 decimal places (standard for all float params)
        snprintf(buf, sizeof(buf), "%.2f", value);
    }
    
    return std::string(buf);
}

void TrackerSequencer::updateStepActiveState() {
    // Check if current step duration has expired (works for both manual and playback)
    // PERFORMANCE: Early return checks BEFORE expensive system call
    if (currentPlayingStep >= 0 && stepEndTime > 0.0f) {
        float currentTime = ofGetElapsedTimef();
        if (currentTime >= stepEndTime) {
            // Step duration expired - clear playing state
            currentPlayingStep = -1;
            stepStartTime = 0.0f;
            stepEndTime = 0.0f;
        }
    }
}

// Multi-pattern support implementation
//--------------------------------------------------------------
void TrackerSequencer::setCurrentPatternIndex(int index) {
    if (index >= 0 && index < (int)patterns.size()) {
        currentPatternIndex = index;
        ofLogNotice("TrackerSequencer") << "Switched to pattern " << index;
    } else {
        ofLogWarning("TrackerSequencer") << "Invalid pattern index: " << index;
    }
}

int TrackerSequencer::addPattern() {
    // New pattern uses same step count as current pattern
    int stepCount = getCurrentPattern().getStepCount();
    Pattern newPattern(stepCount);
    patterns.push_back(newPattern);
    int newIndex = (int)patterns.size() - 1;
    ofLogNotice("TrackerSequencer") << "Added new pattern at index " << newIndex << " with " << stepCount << " steps";
    return newIndex;
}

void TrackerSequencer::removePattern(int index) {
    if (patterns.size() <= 1) {
        ofLogWarning("TrackerSequencer") << "Cannot remove pattern: must have at least one pattern";
        return;
    }
    
    if (index < 0 || index >= (int)patterns.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid pattern index for removal: " << index;
        return;
    }
    
    patterns.erase(patterns.begin() + index);
    
    // Adjust current pattern index if necessary
    if (currentPatternIndex >= (int)patterns.size()) {
        currentPatternIndex = (int)patterns.size() - 1;
    }
    
    // Adjust pattern chain indices
    for (size_t i = 0; i < patternChain.size(); i++) {
        if (patternChain[i] == index) {
            // Remove entry from pattern chain
            patternChain.erase(patternChain.begin() + i);
            i--; // Adjust index after removal
        } else if (patternChain[i] > index) {
            // Decrement indices greater than removed index
            patternChain[i]--;
        }
    }
    
    // Adjust current chain index if necessary
    if (currentChainIndex >= (int)patternChain.size()) {
        currentChainIndex = std::max(0, (int)patternChain.size() - 1);
    }
    
    ofLogNotice("TrackerSequencer") << "Removed pattern at index " << index;
}

void TrackerSequencer::copyPattern(int sourceIndex, int destIndex) {
    if (sourceIndex < 0 || sourceIndex >= (int)patterns.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid source pattern index: " << sourceIndex;
        return;
    }
    
    if (destIndex < 0 || destIndex >= (int)patterns.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid destination pattern index: " << destIndex;
        return;
    }
    
    // Copy pattern data
    patterns[destIndex] = patterns[sourceIndex];
    ofLogNotice("TrackerSequencer") << "Copied pattern " << sourceIndex << " to pattern " << destIndex;
}

void TrackerSequencer::duplicatePattern(int index) {
    if (index < 0 || index >= (int)patterns.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid pattern index for duplication: " << index;
        return;
    }
    
    Pattern newPattern = patterns[index];
    patterns.push_back(newPattern);
    int newIndex = (int)patterns.size() - 1;
    ofLogNotice("TrackerSequencer") << "Duplicated pattern " << index << " to new pattern " << newIndex;
}

// Pattern chain (pattern chaining) implementation
//--------------------------------------------------------------
void TrackerSequencer::setCurrentChainIndex(int index) {
    if (index >= 0 && index < (int)patternChain.size()) {
        currentChainIndex = index;
        currentChainRepeat = 0;  // Reset repeat counter
        // Update current pattern index based on pattern chain
        if (usePatternChain) {
            int patternIdx = patternChain[currentChainIndex];
            if (patternIdx >= 0 && patternIdx < (int)patterns.size()) {
                currentPatternIndex = patternIdx;
            }
        }
        ofLogNotice("TrackerSequencer") << "Set chain index to " << index;
    } else {
        ofLogWarning("TrackerSequencer") << "Invalid chain index: " << index;
    }
}

void TrackerSequencer::addToPatternChain(int patternIndex) {
    if (patternIndex < 0 || patternIndex >= (int)patterns.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid pattern index for chain: " << patternIndex;
        return;
    }
    
    int newIndex = (int)patternChain.size();
    patternChain.push_back(patternIndex);
    patternChainRepeatCounts[newIndex] = 1;  // Default repeat count
    ofLogNotice("TrackerSequencer") << "Added pattern " << patternIndex << " to chain";
}

void TrackerSequencer::removeFromPatternChain(int chainIndex) {
    if (chainIndex < 0 || chainIndex >= (int)patternChain.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid chain index for removal: " << chainIndex;
        return;
    }
    
    patternChain.erase(patternChain.begin() + chainIndex);
    
    // Remove repeat count and adjust indices
    patternChainRepeatCounts.erase(chainIndex);
    std::map<int, int> newRepeatCounts;
    for (const auto& pair : patternChainRepeatCounts) {
        if (pair.first < chainIndex) {
            newRepeatCounts[pair.first] = pair.second;
        } else if (pair.first > chainIndex) {
            newRepeatCounts[pair.first - 1] = pair.second;
        }
    }
    patternChainRepeatCounts = newRepeatCounts;
    
    // Adjust current chain index if necessary
    bool wasCurrentIndex = (currentChainIndex == chainIndex);
    if (currentChainIndex > chainIndex) {
        // If current index is after the removed one, decrement it
        // (the pattern that was at currentChainIndex is now at currentChainIndex - 1)
        currentChainIndex--;
    }
    // If we removed the current index, currentChainIndex stays the same
    // (it now points to the pattern that was at chainIndex+1, which shifted down)
    // If current index is out of bounds, clamp to last valid index
    if (currentChainIndex >= (int)patternChain.size()) {
        currentChainIndex = std::max(0, (int)patternChain.size() - 1);
    }
    if (wasCurrentIndex) {
        // If we removed the current index, reset repeat counter
        currentChainRepeat = 0;
    }
    
    // Switch to the pattern at the new current chain index
    if (!patternChain.empty() && currentChainIndex >= 0 && currentChainIndex < (int)patternChain.size()) {
        int newPatternIndex = patternChain[currentChainIndex];
        setCurrentPatternIndex(newPatternIndex);
    }
    
    ofLogNotice("TrackerSequencer") << "Removed chain entry at index " << chainIndex;
}

void TrackerSequencer::clearPatternChain() {
    patternChain.clear();
    patternChainRepeatCounts.clear();
    patternChainDisabled.clear();
    currentChainIndex = 0;
    currentChainRepeat = 0;
    usePatternChain = false;
    ofLogNotice("TrackerSequencer") << "Pattern chain cleared";
}

int TrackerSequencer::getPatternChainEntry(int chainIndex) const {
    if (chainIndex >= 0 && chainIndex < (int)patternChain.size()) {
        return patternChain[chainIndex];
    }
    return -1;
}

void TrackerSequencer::setPatternChainEntry(int chainIndex, int patternIndex) {
    if (chainIndex < 0) {
        ofLogWarning("TrackerSequencer") << "Invalid chain index: " << chainIndex;
        return;
    }
    
    if (patternIndex < 0 || patternIndex >= (int)patterns.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid pattern index: " << patternIndex;
        return;
    }
    
    // Resize pattern chain if necessary
    if (chainIndex >= (int)patternChain.size()) {
        patternChain.resize(chainIndex + 1, 0);
        // Set default repeat count for new entries
        if (patternChainRepeatCounts.find(chainIndex) == patternChainRepeatCounts.end()) {
            patternChainRepeatCounts[chainIndex] = 1;
        }
    }
    
    patternChain[chainIndex] = patternIndex;
    ofLogNotice("TrackerSequencer") << "Set chain entry " << chainIndex << " to pattern " << patternIndex;
}

int TrackerSequencer::getPatternChainRepeatCount(int chainIndex) const {
    if (chainIndex < 0 || chainIndex >= (int)patternChain.size()) {
        return 1;  // Default repeat count
    }
    auto it = patternChainRepeatCounts.find(chainIndex);
    if (it != patternChainRepeatCounts.end()) {
        return it->second;
    }
    return 1;  // Default repeat count
}

void TrackerSequencer::setPatternChainRepeatCount(int chainIndex, int repeatCount) {
    if (chainIndex < 0 || chainIndex >= (int)patternChain.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid chain index: " << chainIndex;
        return;
    }
    
    repeatCount = std::max(1, std::min(99, repeatCount));  // Clamp to 1-99
    patternChainRepeatCounts[chainIndex] = repeatCount;
    ofLogNotice("TrackerSequencer") << "Set chain entry " << chainIndex << " repeat count to " << repeatCount;
}

bool TrackerSequencer::isPatternChainEntryDisabled(int chainIndex) const {
    if (chainIndex < 0 || chainIndex >= (int)patternChain.size()) {
        return false;
    }
    auto it = patternChainDisabled.find(chainIndex);
    return (it != patternChainDisabled.end() && it->second);
}

void TrackerSequencer::setPatternChainEntryDisabled(int chainIndex, bool disabled) {
    if (chainIndex < 0 || chainIndex >= (int)patternChain.size()) {
        ofLogWarning("TrackerSequencer") << "Invalid chain index: " << chainIndex;
        return;
    }
    patternChainDisabled[chainIndex] = disabled;
    ofLogVerbose("TrackerSequencer") << "Set chain entry " << chainIndex << " disabled: " << (disabled ? "true" : "false");
}

// ParameterCell adapter methods - bridge PatternCell to ParameterCell
//--------------------------------------------------------------
ParameterCell TrackerSequencer::createParameterCellForColumn(int step, int column) {
    if (!isValidStep(step) || column <= 0 || column > (int)columnConfig.size()) {
        return ParameterCell(); // Return empty cell for invalid input
    }
    
    int colIdx = column - 1;
    if (colIdx < 0 || colIdx >= (int)columnConfig.size()) {
        return ParameterCell();
    }
    
    const auto& col = columnConfig[colIdx];
    ParameterCell cell;
    
    // Configure basic properties
    cell.parameterName = col.parameterName;
    cell.isFixed = col.isFixed;
    if (col.isFixed) {
        cell.fixedType = col.parameterName; // "index" or "length"
        // Fixed columns are always integers
        cell.isInteger = true;
        cell.stepIncrement = 1.0f;
    }
    
    // Set value range based on column type
    if (col.isFixed && col.parameterName == "index") {
        // Index column: 0 = rest, 1+ = media index (1-based display)
        int maxIndex = indexRangeCallback ? indexRangeCallback() : 127;
        cell.setValueRange(0.0f, (float)maxIndex, 0.0f);
        cell.getMaxIndex = [this]() { return indexRangeCallback ? indexRangeCallback() : 127; };
    } else if (col.isFixed && col.parameterName == "length") {
        // Length column: 1-16 range
        cell.setValueRange(1.0f, 16.0f, 1.0f);
    } else {
        // Dynamic parameter column - use parameter ranges
        auto range = getParameterRange(col.parameterName);
        float defaultValue = getParameterDefault(col.parameterName);
        cell.setValueRange(range.first, range.second, defaultValue);
        
        // Determine if parameter is integer or float
        ParameterType paramType = getParameterType(col.parameterName);
        cell.isInteger = (paramType == ParameterType::INT);
        
        // Calculate optimal step increment based on range and type
        cell.calculateStepIncrement();
    }
    
    // Configure callbacks
    configureParameterCellCallbacks(cell, step, column);
    
    return cell;
}

void TrackerSequencer::configureParameterCellCallbacks(ParameterCell& cell, int step, int column) {
    if (!isValidStep(step) || column <= 0 || column > (int)columnConfig.size()) {
        return;
    }
    
    int colIdx = column - 1;
    if (colIdx < 0 || colIdx >= (int)columnConfig.size()) {
        return;
    }
    
    const auto& col = columnConfig[colIdx];
    std::string paramName = col.parameterName; // Capture by value for lambda
    bool isFixedCol = col.isFixed; // Capture by value
    std::string fixedTypeCol = col.isFixed ? col.parameterName : ""; // Capture by value
    
    // getCurrentValue callback - returns current value from PatternCell
    // Returns NaN to indicate empty/not set (will display as "--")
    // For fixed columns, still uses -1.0f for compatibility
    cell.getCurrentValue = [this, step, paramName, isFixedCol, fixedTypeCol]() -> float {
        if (!isValidStep(step)) {
            // Return NaN for invalid step (will display as "--")
            return std::numeric_limits<float>::quiet_NaN();
        }
        
        auto& patternCell = getCurrentPattern()[step];
        
        if (isFixedCol && fixedTypeCol == "index") {
            // Index: return 1-based display value (0 = rest, 1+ = media index)
            int idx = patternCell.index;
            return (idx < 0) ? 0.0f : (float)(idx + 1);
        } else if (isFixedCol && fixedTypeCol == "length") {
            // Length: return -1.0f if index is -1 (rest), otherwise return length
            // For fixed columns, we still use -1.0f for compatibility
            if (patternCell.index < 0) {
                return -1.0f; // Show "--" when index is rest
            }
            return (float)patternCell.length;
        } else {
            // Dynamic parameter: return NaN if parameter doesn't exist (will display as "--")
            // This allows parameters with negative ranges (like speed -10 to 10) to distinguish
            // between "not set" (NaN/--) and explicit values like 1.0 or -1.0
            if (!patternCell.hasParameter(paramName)) {
                return std::numeric_limits<float>::quiet_NaN();
            }
            return patternCell.getParameterValue(paramName, 0.0f);
        }
    };
    
    // onValueApplied callback - applies value to PatternCell
    cell.onValueApplied = [this, step, colIdx, paramName, isFixedCol, fixedTypeCol](const std::string&, float value) {
        if (!isValidStep(step)) return;
        
        // Check if we should queue this edit (playback editing)
        // Note: GUI state (editStep, editColumn) is now managed by TrackerSequencerGUI
        // Since this callback is only called for the cell being edited, we just check if it's the playback step
        bool shouldQueue = playing && isValidStep(step) && step == playbackStep && (colIdx + 1) > 0;
        
        if (shouldQueue) {
            // Queue edit for next trigger
            pendingEdit.step = step;
            pendingEdit.column = colIdx + 1;
            pendingEdit.parameterName = paramName;
            
            if (isFixedCol && fixedTypeCol == "index") {
                // Index: value is 1-based display, convert to 0-based storage
                // 0 = rest (-1), 1+ = media index (0-based)
                int indexValue = (int)std::round(value);
                pendingEdit.isIndex = true;
                pendingEdit.indexValue = (indexValue == 0) ? -1 : (indexValue - 1);
            } else if (isFixedCol && fixedTypeCol == "length") {
                // Length: clamp to 1-16
                int lengthValue = std::max(1, std::min(16, (int)std::round(value)));
                pendingEdit.isLength = true;
                pendingEdit.lengthValue = lengthValue;
            } else {
                // Dynamic parameter
                pendingEdit.value = value;
            }
            pendingEdit.shouldRemove = false;
        } else {
            // Apply immediately
            auto& patternCell = getCurrentPattern()[step];
            if (isFixedCol && fixedTypeCol == "index") {
                // Index: value is 1-based display, convert to 0-based storage
                int indexValue = (int)std::round(value);
                patternCell.index = (indexValue == 0) ? -1 : (indexValue - 1);
            } else if (isFixedCol && fixedTypeCol == "length") {
                // Length: clamp to 1-16
                patternCell.length = std::max(1, std::min(16, (int)std::round(value)));
            } else {
                // Dynamic parameter
                patternCell.setParameterValue(paramName, value);
            }
            setCell(step, patternCell);
        }
    };
    
    // onValueRemoved callback - removes parameter from PatternCell
    cell.onValueRemoved = [this, step, colIdx, paramName, isFixedCol](const std::string&) {
        if (!isValidStep(step)) return;
        
        // Check if we should queue this edit (playback editing)
        // Note: GUI state (editStep, editColumn) is now managed by TrackerSequencerGUI
        // Since this callback is only called for the cell being edited, we just check if it's the playback step
        bool shouldQueue = playing && isValidStep(step) && step == playbackStep && (colIdx + 1) > 0;
        
        if (shouldQueue) {
            // Queue removal for next trigger
            pendingEdit.step = step;
            pendingEdit.column = colIdx + 1;
            pendingEdit.parameterName = paramName;
            pendingEdit.shouldRemove = true;
        } else {
            // Remove immediately (only for dynamic parameters)
            if (!isFixedCol) {
                auto& patternCell = getCurrentPattern()[step];
                patternCell.removeParameter(paramName);
                setCell(step, patternCell);
            }
        }
    };
    
    // formatValue callback - uses TrackerSequencer's formatting (static method)
    cell.formatValue = [paramName](float value) -> std::string {
        return formatParameterValue(paramName, value);
    };
    
    // parseValue callback - uses default parsing (can be enhanced if needed)
    // ParameterCell already has default parsing, so we can leave this unset
    // or provide custom parsing if needed
}



#pragma once

#include "ofMain.h"
#include "ofEvents.h"
#include "Module.h"
#include "Pattern.h"
#include "ParameterCell.h"
#include <string>
#include <vector>
#include <map>
#include <functional>

// Forward declarations
class Clock;
struct TimeEvent;

class TrackerSequencer {
    friend class TrackerSequencerGUI;  // Allow GUI to access private members for rendering
    
public:

    // Event for step triggers - broadcasts TriggerEvent to all subscribers
    // This makes TrackerSequencer truly modular - receivers subscribe via ofAddListener
    ofEvent<TriggerEvent> triggerEvent;
    
    
    TrackerSequencer();
    ~TrackerSequencer();

    // Callback types for querying external state
    using IndexRangeCallback = std::function<int()>;
    
    void setup(Clock* clockRef, int steps = 16);
    void setIndexRangeCallback(IndexRangeCallback callback);
    void processAudioBuffer(ofSoundBuffer& buffer);
    void onTimeEvent(TimeEvent& data); // Sample-accurate time event from Clock (filters for STEP type)
    
    // Event listener system
    void addStepEventListener(std::function<void(int, float, const PatternCell&)> listener);
    
    // Expose TrackerSequencer parameters (for discovery by modules)
    // TrackerSequencer exposes its own parameters (note, position, speed, volume)
    // Modules map these to their own parameters (e.g., note â†’ mediaIndex)
    // NOTE: TrackerSequencer does NOT inherit from Module (SunVox-style)
    // This prepares for future BespokeSynth-style migration where TrackerSequencer becomes a Module
    std::vector<ParameterDescriptor> getAvailableParameters() const;
    
    // Module interface compatibility methods (for future Module inheritance)
    std::vector<ParameterDescriptor> getParameters(); // Alias for getAvailableParameters
    void onTrigger(TriggerEvent& event); // Sequencers don't receive triggers, but method exists for interface
    void setParameter(const std::string& paramName, float value, bool notify = true); // Interface compliance
    
    // Transport listener for Clock play/stop events
    void onClockTransportChanged(bool isPlaying);
    
    // Pattern management
    void setCell(int step, const PatternCell& cell);
    PatternCell getCell(int step) const;
    void setStepCount(int steps);  // Set step count for current pattern only
    void clearCell(int step);
    void clearPattern();
    void randomizePattern();
    void randomizeColumn(int columnIndex);  // Randomize a specific column (0 = index, 1 = length, 2+ = parameter columns)
    void applyLegato();  // Apply legato to length column (extend lengths to connect steps)
    
    // Multi-step duplication: copy a range of steps to a destination
    // fromStep: inclusive start of source range
    // toStep: inclusive end of source range
    // destinationStep: where to copy the range (overwrites existing cells)
    // Returns true if successful, false if range is invalid
    bool duplicateRange(int fromStep, int toStep, int destinationStep);
    
    // Multi-pattern support
    int getNumPatterns() const { return (int)patterns.size(); }
    int getCurrentPatternIndex() const { return currentPatternIndex; }
    void setCurrentPatternIndex(int index);
    int addPattern();  // Add a new empty pattern, returns its index
    void removePattern(int index);  // Remove a pattern (cannot remove if it's the only one)
    void copyPattern(int sourceIndex, int destIndex);  // Copy one pattern to another
    void duplicatePattern(int index);  // Duplicate a pattern (adds new pattern)
    
    // Pattern chain (pattern chaining) support
    int getPatternChainSize() const { return (int)patternChain.size(); }
    int getCurrentChainIndex() const { return currentChainIndex; }
    void setCurrentChainIndex(int index);
    void addToPatternChain(int patternIndex);  // Add pattern to chain
    void removeFromPatternChain(int chainIndex);  // Remove entry from chain
    void clearPatternChain();  // Clear pattern chain
    int getPatternChainEntry(int chainIndex) const;  // Get pattern index at chain position
    void setPatternChainEntry(int chainIndex, int patternIndex);  // Set pattern at chain position
    const std::vector<int>& getPatternChain() const { return patternChain; }
    
    // Pattern chain repeat counts
    int getPatternChainRepeatCount(int chainIndex) const;  // Get repeat count for chain entry (1-99)
    void setPatternChainRepeatCount(int chainIndex, int repeatCount);  // Set repeat count (1-99)
    
    // Pattern chain toggle
    bool getUsePatternChain() const { return usePatternChain; }
    void setUsePatternChain(bool use) { usePatternChain = use; }
    
    // Pattern chain disable (temporary disable during playback for performance)
    bool isPatternChainEntryDisabled(int chainIndex) const;
    void setPatternChainEntryDisabled(int chainIndex, bool disabled);
    
    // Helper to get current pattern (for internal use)
    Pattern& getCurrentPattern();
    const Pattern& getCurrentPattern() const;
    
    // Playback control
    void play();
    void pause();
    void stop();
    void reset();
    void setCurrentStep(int step);
    void advanceStep();
    void triggerStep(int step);
    
    // State management
    bool loadState(const std::string& filename);
    bool saveState(const std::string& filename) const;
    
    // UI interaction
    // Note: GUI state (editStep, editColumn, isEditingCell, editBufferCache) is now managed by TrackerSequencerGUI
    // These methods accept GUI state as parameters instead of using member variables
    struct GUIState {
        int editStep = -1;
        int editColumn = -1;
        bool isEditingCell = false;
        std::string editBufferCache;
        bool editBufferInitializedCache = false;
    };
    bool handleKeyPress(int key, bool ctrlPressed, bool shiftPressed, GUIState& guiState);
    bool handleKeyPress(ofKeyEventArgs& keyEvent, GUIState& guiState); // Overload for ofKeyEventArgs
    void handleMouseClick(int x, int y, int button);
    
    // Getters
    int getStepCount() const;  // Returns current pattern's step count
    int getCurrentStep() const { return playbackStep; }  // Backward compatibility: returns playback step
    int getPlaybackStep() const { return playbackStep; }
    int getPlaybackStepIndex() const { return playbackStep; }  // GUI compatibility alias
    // Sequencer playback state - derived from Clock transport state
    // This represents whether the sequencer is actively advancing steps.
    // It's synchronized with Clock via onClockTransportChanged() listener.
    // NOTE: This is sequencer-specific state, not global transport state.
    // For global transport state, query clock->isPlaying() instead.
    bool isPlaying() const { return playing; }
    int getCurrentPlayingStep() const { return currentPlayingStep; }
    
    // Note: GUI state accessors (editStep, editColumn, isEditingCell, editBufferCache) removed
    // Use TrackerSequencerGUI::getEditStep(), etc. instead
    
    // Pattern cell accessor for GUI
    PatternCell& getPatternCell(int step) { return getCurrentPattern()[step]; }
    const PatternCell& getPatternCell(int step) const { return getCurrentPattern()[step]; }
    
    // Drag state accessors for GUI (still needed for ParameterCell interaction)
    float getDragStartY() const { return dragStartY; }
    float getDragStartX() const { return dragStartX; }
    float getLastDragValue() const { return lastDragValue; }
    void setLastDragValue(float value) { lastDragValue = value; }
    
    // Note: Focus management flags removed - these are GUI concerns managed by TrackerSequencerGUI
    // Update step active state (clears manually triggered steps when duration expires)
    void updateStepActiveState();
    float getCurrentBpm() const;
    int getStepsPerBeat() const { return stepsPerBeat; }
    
    // Setters
    void setStepsPerBeat(int steps);
    
    // Parameter synchronization methods (for ParameterSync system)
    // Get position parameter from current edit step (for sync)
    float getCurrentStepPosition() const;
    
    // Set position parameter for current edit step (for sync)
    void setCurrentStepPosition(float position);
    
    // Parameter change callback (for ParameterSync)
    void setParameterChangeCallback(std::function<void(const std::string&, float)> callback) {
        parameterChangeCallback = callback;
    }

private:
    bool isValidStep(int step) const;
    bool isPatternEmpty() const;
    void notifyStepEvent(int step, float stepLength);
    void updateStepInterval();
    
    // Column configuration
    struct ColumnConfig {
        std::string parameterName;      // e.g., "position", "speed", "volume" (or "index", "length" for fixed)
        std::string displayName;        // e.g., "Position", "Speed", "Volume"
        bool isFixed;                   // true for "index" and "length" columns (cannot be deleted)
        int columnIndex;                // Position in grid (0 = first column)
        
        ColumnConfig() : parameterName(""), displayName(""), isFixed(false), columnIndex(0) {}
        ColumnConfig(const std::string& param, const std::string& display, bool fixed, int idx)
            : parameterName(param), displayName(display), isFixed(fixed), columnIndex(idx) {}
    };
    
    // Column configuration management
    void initializeDefaultColumns();
    void addColumn(const std::string& parameterName, const std::string& displayName, int position = -1);
    void removeColumn(int columnIndex);
    void reorderColumn(int fromIndex, int toIndex);
    bool isColumnFixed(int columnIndex) const;
    const ColumnConfig& getColumnConfig(int columnIndex) const;
    int getColumnCount() const;
    const std::vector<ColumnConfig>& getColumnConfiguration() const { return columnConfig; }  // GUI compatibility
    
    // Pattern interaction methods
    bool handlePatternGridClick(int x, int y);
    bool handlePatternRowClick(int step, int column); // Unused - kept for API compatibility
    
    // Parameter range conversion helpers (use actual parameter ranges, not 0-127)
    static std::pair<float, float> getParameterRange(const std::string& paramName);
    static float getParameterDefault(const std::string& paramName); // Note: Uses getAvailableParameters() which is non-static
    static ParameterType getParameterType(const std::string& paramName); // Get parameter type dynamically
    static std::string formatParameterValue(const std::string& paramName, float value); // Format based on parameter type
    
    Clock* clock;
    
    // Column configuration
    std::vector<ColumnConfig> columnConfig;
    
    // Pattern sequencer state (app-specific)
    int stepsPerBeat = 4;
    bool gatingEnabled = true;
    
    // Multi-pattern support
    std::vector<Pattern> patterns;  // Pattern bank
    int currentPatternIndex = 0;  // Currently active pattern
    std::vector<int> patternChain;  // Pattern chain for pattern chaining (sequence of pattern indices)
    std::map<int, int> patternChainRepeatCounts;  // Repeat counts for each chain entry (default: 1)
    std::map<int, bool> patternChainDisabled;  // Disabled state for each chain entry (temporary disable during playback)
    int currentChainIndex = 0;  // Current position in pattern chain
    int currentChainRepeat = 0;  // Current repeat count for current chain entry
    bool usePatternChain = true;  // If true, use pattern chain for playback; if false, use currentPatternIndex
    
    // Note: numSteps removed - step count is now per-pattern (use getCurrentPattern().getStepCount())
    int playbackStep;  // Currently playing step (for visual indicator)
    // Note: GUI state (editStep, editColumn, isEditingCell, editBufferCache) moved to TrackerSequencerGUI
    
    // Drag state for parameter cell editing (moved from static variables to avoid loop issues)
    int draggingStep;      // Step being dragged (-1 if not dragging)
    int draggingColumn;    // Column being dragged (-1 if not dragging)
    float lastDragValue;   // Last drag value (float for precision with float parameters)
    float dragStartY;      // Y position when drag started
    float dragStartX;      // X position when drag started (for horizontal dragging)
    int lastTriggeredStep;
    bool playing;  // Renamed from isPlaying to avoid conflict
    
    // Track current media playback
    int currentMediaStartStep;
    float currentMediaStepLength;
    
    // Audio-rate timing system
    double sampleAccumulator; // Sample accumulator for step timing
    float lastBpm; // Last known BPM for timing calculations
    
    // Unified timing system for step duration (works for both manual and playback triggers)
    float stepStartTime;      // When current step started (unified for manual and playback)
    float stepEndTime;        // When current step should end (calculated from duration)
    
    // Step event listeners
    std::vector<std::function<void(int, float, const PatternCell&)>> stepEventListeners;
    
    // Callback for querying external state
    IndexRangeCallback indexRangeCallback;
    
    // UI state
    bool showGUI;
    
    // Step playback tracking
    int currentPlayingStep;  // Current step that's playing (for GUI visualization)
    
    // Note: Cell focus management flags removed - these are GUI concerns managed by TrackerSequencerGUI
    
    // Parameter change callback (for ParameterSync system)
    std::function<void(const std::string&, float)> parameterChangeCallback;
    
    // Pending edit system for playback editing
    struct PendingEdit {
        int step;
        int column;
        std::string parameterName;
        float value;
        bool isIndex;
        int indexValue;
        bool isLength;
        int lengthValue;
        bool shouldRemove;
        
        PendingEdit() : step(-1), column(-1), value(0.0f), isIndex(false), indexValue(-1), 
                       isLength(false), lengthValue(1), shouldRemove(false) {}
    };
    PendingEdit pendingEdit;  // Stores edit queued for next trigger
    
    // Helper to apply pending edit
    void applyPendingEdit();
    
    // Helper to determine if edit should be queued (during playback on current step)
    // Note: GUI state parameters added - editStep and editColumn are now passed in
    bool shouldQueueEdit(int editStep, int editColumn) const;
    
    // ParameterCell adapter methods - bridge PatternCell to ParameterCell
    // Creates and configures a ParameterCell for a specific step/column
    ParameterCell createParameterCellForColumn(int step, int column);
    
    // Configures callbacks for a ParameterCell to connect to PatternCell operations
    void configureParameterCellCallbacks(ParameterCell& cell, int step, int column);
};


#include "TrackerSequencerGUI.h"
// Note: TrackerSequencer.h is already included by TrackerSequencerGUI.h
#include "ParameterCell.h"
#include "ofxImGui.h"
#include "ofLog.h"
#include <cmath>  // For std::round
#include <map>    // For paramRanges map

TrackerSequencerGUI::TrackerSequencerGUI() 
    : editStep(-1), editColumn(-1), isEditingCell(false), editBufferInitializedCache(false),
      patternDirty(true), lastNumSteps(0), lastPlaybackStep(-1), anyCellFocusedThisFrame(false), parentWidgetId(0) {
    pendingRowOutline.shouldDraw = false;
    pendingRowOutline.step = -1;
}

void TrackerSequencerGUI::clearCellFocus() {
    // Guard: Don't clear if already cleared (prevents spam and unnecessary work)
    if (editStep == -1) {
        return;
    }
    ofLogNotice("TrackerSequencerGUI") << "[FOCUS_DEBUG] clearCellFocus() - clearing editStep to -1 (was: " << editStep 
                                     << ", column: " << editColumn 
                                     << ", isEditingCell: " << isEditingCell << ")";
    
    // If we were in edit mode, restore ImGui keyboard navigation
    if (isEditingCell) {
        ImGuiIO& io = ImGui::GetIO();
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
        ofLogNotice("TrackerSequencerGUI") << "[FOCUS_DEBUG] Restored ImGui keyboard navigation (was in edit mode)";
    }
    
    editStep = -1;
    editColumn = -1;
    isEditingCell = false;
    editBufferCache.clear();
    editBufferInitializedCache = false;
}

void TrackerSequencerGUI::draw(TrackerSequencer& sequencer) {
    drawPatternChain(sequencer);
    drawTrackerStatus(sequencer);
    drawPatternGrid(sequencer);
}

void TrackerSequencerGUI::drawPatternChain(TrackerSequencer& sequencer) {
    ImGui::PushID("PatternChain");
        
    // Pattern chain toggle checkbox
    bool useChain = sequencer.getUsePatternChain();
    if (ImGui::Checkbox("##chainToggle", &useChain)) {
        sequencer.setUsePatternChain(useChain);
    }
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Enable/disable pattern chain");
    }
    ImGui::SameLine();
    // Pattern chain header with toggle
    ImGui::Text("Pattern Chain");
    ImGui::SameLine();

    
    ImGui::Spacing();
    
    // Pattern chain visual list (horizontal layout, Renoise-style)
    const auto& chain = sequencer.getPatternChain();
    int currentChainIndex = sequencer.getCurrentChainIndex();
    int currentPatternIndex = sequencer.getCurrentPatternIndex();
    bool isPlaying = sequencer.isPlaying();
    
    // Compact styling for pattern chain
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(2, 2));
    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4, 2));
    
    // Store starting Y position to align buttons with pattern cells
    const float patternCellHeight = 22.0f;
    const float buttonHeight = 16.0f;
    const float buttonsStartY = ImGui::GetCursorPosY();
    
    // Draw pattern chain entries (top row)
    for (size_t i = 0; i < chain.size(); i++) {
        int patternIdx = chain[i];
        bool isCurrentChainEntry = ((int)i == currentChainIndex);
        bool isCurrentPattern = (patternIdx == currentPatternIndex);
        bool isDisabled = sequencer.isPatternChainEntryDisabled((int)i);
        
        ImGui::PushID((int)i);
        
        // Pattern cell - clickable to select pattern (Renoise-style)
        ImVec2 cellSize(32, 22);
        
        // Color coding: blue for current pattern, gray for current chain position, dark for others, red tint if disabled
        ImU32 bgColor;
        if (isDisabled) {
            bgColor = ImGui::ColorConvertFloat4ToU32(ImVec4(0.4f, 0.2f, 0.2f, 1.0f));  // Red tint for disabled
        } else if (isCurrentPattern && isPlaying) {
            bgColor = ImGui::ColorConvertFloat4ToU32(ImVec4(0.0f, 0.9f, 0.0f, 0.6f));  // Bright green when playing
        } else if (isCurrentPattern) {
            bgColor = ImGui::ColorConvertFloat4ToU32(ImVec4(0.9f, 0.5f, 0.1f, 0.6f));  // Blue for current pattern
        } else if (isCurrentChainEntry) {
            bgColor = ImGui::ColorConvertFloat4ToU32(ImVec4(0.4f, 0.4f, 0.4f, 1.0f));  // Gray for current chain entry
        } else {
            bgColor = ImGui::ColorConvertFloat4ToU32(ImVec4(0.25f, 0.25f, 0.25f, 1.0f));  // Dark for others
        }
        
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        ImVec2 cursorPos = ImGui::GetCursorScreenPos();
        
        // Draw background
        drawList->AddRectFilled(cursorPos, ImVec2(cursorPos.x + cellSize.x, cursorPos.y + cellSize.y), bgColor);
        
        // Draw border for current chain entry
        if (isCurrentChainEntry) {
            ImU32 borderColor = ImGui::ColorConvertFloat4ToU32(ImVec4(0.8f, 0.8f, 0.8f, 1.0f));
            drawList->AddRect(cursorPos, ImVec2(cursorPos.x + cellSize.x, cursorPos.y + cellSize.y), borderColor, 0.0f, 0, 1.5f);
        }
        
        // Draw diagonal line if disabled
        if (isDisabled) {
            ImU32 lineColor = ImGui::ColorConvertFloat4ToU32(ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
            drawList->AddLine(cursorPos, ImVec2(cursorPos.x + cellSize.x, cursorPos.y + cellSize.y), lineColor, 2.0f);
        }
        
        // Pattern number text (2-digit format: 01, 02, 03, etc.)
        // Display chain position (1-based) instead of actual pattern index for sequential numbering
        char patternLabel[8];
        snprintf(patternLabel, sizeof(patternLabel), "%02d", (int)i + 1);
        ImVec2 textSize = ImGui::CalcTextSize(patternLabel);
        ImVec2 textPos(cursorPos.x + (cellSize.x - textSize.x) * 0.5f, cursorPos.y + (cellSize.y - textSize.y) * 0.5f);
        drawList->AddText(textPos, IM_COL32_WHITE, patternLabel);
        
        // Make it clickable and navigable with keyboard
        ImGui::InvisibleButton("pattern", cellSize, ImGuiButtonFlags_EnableNav);
        if (ImGui::IsItemClicked(0)) {
            if (isPlaying && useChain) {
                // During playback with chain enabled: toggle disable state
                sequencer.setPatternChainEntryDisabled((int)i, !isDisabled);
            } else {
                // Normal behavior: select pattern
                sequencer.setCurrentPatternIndex(patternIdx);
                sequencer.setCurrentChainIndex((int)i);
            }
        }
        
        if (ImGui::IsItemHovered()) {
            if (isPlaying && useChain) {
                ImGui::SetTooltip("Chain position %02d (Pattern %02d)\nLeft-click: Toggle disable\nRight-click: Remove from chain", (int)i + 1, patternIdx);
            } else {
                ImGui::SetTooltip("Chain position %02d (Pattern %02d)\nLeft-click: Select", (int)i + 1, patternIdx);
            }
        }
        
        ImGui::SameLine();
        ImGui::PopID();
    }
    
    // Small buttons for duplicate, add, and remove (same size, compact, distinct from pattern cells)
    // Note: We keep the same style vars for buttons (they're already pushed above)
    // Center buttons vertically relative to pattern cells
    const float verticalOffset = (patternCellHeight - buttonHeight) * 0.5f;
    const float buttonsY = buttonsStartY + verticalOffset;
    
    // 'D' button for duplicate current pattern
    ImGui::SetCursorPosY(buttonsY);
    if (ImGui::Button("D", ImVec2(buttonHeight, buttonHeight))) {
        int currentPattern = sequencer.getCurrentPatternIndex();
        sequencer.duplicatePattern(currentPattern);
        int newPatternIndex = sequencer.getNumPatterns() - 1;
        // Add new pattern to chain
        sequencer.addToPatternChain(newPatternIndex);
        // Switch to new pattern if not playing with pattern chaining enabled
        if (!(isPlaying && useChain)) {
            sequencer.setCurrentPatternIndex(newPatternIndex);
            sequencer.setCurrentChainIndex(sequencer.getPatternChainSize() - 1);
        }
    }
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Duplicate current pattern");
    }
    
    ImGui::SameLine();
    ImGui::SetCursorPosY(buttonsY);  // Set Y after SameLine() to ensure alignment
    
    // '+' button to add new pattern
    if (ImGui::Button("+", ImVec2(buttonHeight, buttonHeight))) {
        int newPatternIndex = sequencer.addPattern();
        sequencer.addToPatternChain(newPatternIndex);
        // Switch to new pattern if not playing with pattern chaining enabled
        if (!(isPlaying && useChain)) {
            sequencer.setCurrentPatternIndex(newPatternIndex);
            sequencer.setCurrentChainIndex(sequencer.getPatternChainSize() - 1);
        }
    }
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Add new pattern");
    }
    
    ImGui::SameLine();
    ImGui::SetCursorPosY(buttonsY);  // Set Y after SameLine() to ensure alignment
    
    // '-' button to remove currently selected pattern from chain (if chain has more than one entry)
    bool canRemove = sequencer.getPatternChainSize() > 1;
    if (!canRemove) {
        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
    }
    if (ImGui::Button("-", ImVec2(buttonHeight, buttonHeight)) && canRemove) {
        int chainSize = sequencer.getPatternChainSize();
        int currentIndex = sequencer.getCurrentChainIndex();
        if (chainSize > 1 && currentIndex >= 0 && currentIndex < chainSize) {
            // Remove the currently selected pattern
            // removeFromPatternChain will handle adjusting currentChainIndex appropriately
            sequencer.removeFromPatternChain(currentIndex);
        }
    }
    if (ImGui::IsItemHovered() && canRemove) {
        ImGui::SetTooltip("Remove currently selected pattern from chain");
    }
    if (!canRemove) {
        ImGui::PopStyleVar();  // Pop the alpha style var
    }
    
    // Pop pattern chain style vars (used for both pattern cells and buttons)
    ImGui::PopStyleVar(2);
    

    // Draw repeat count cells below pattern cells
    // Push style vars for repeat count cells
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(2, 2));
    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4, 2));
    
    for (size_t i = 0; i < chain.size(); i++) {
        ImGui::PushID((int)(i + 1000));  // Different ID range to avoid conflicts
        
        int repeatCount = sequencer.getPatternChainRepeatCount((int)i);
        bool isCurrentChainEntry = ((int)i == currentChainIndex);
        
        ImVec2 repeatCellSize(32, 18);
        ImGui::PushItemWidth(repeatCellSize.x);
        
        // Editable repeat count (small input field, similar to pattern grid cells)
        char repeatBuf[8];
        snprintf(repeatBuf, sizeof(repeatBuf), "%d", repeatCount);
        
        // Style the repeat count cell to match pattern cell
        if (isCurrentChainEntry) {
            ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
        }
        
        if (ImGui::InputText("##repeat", repeatBuf, sizeof(repeatBuf), 
                             ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_EnterReturnsTrue | 
                             ImGuiInputTextFlags_AutoSelectAll)) {
            try {
                int newRepeat = std::stoi(repeatBuf);
                newRepeat = std::max(1, std::min(99, newRepeat));
                sequencer.setPatternChainRepeatCount((int)i, newRepeat);
            } catch (...) {
                // Invalid input, ignore
            }
        }
        
        if (isCurrentChainEntry) {
            ImGui::PopStyleColor();
        }
        
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Repeat count: %d (1-99)", repeatCount);
        }
        
        ImGui::PopItemWidth();
        ImGui::SameLine();
        ImGui::PopID();
    }
    
    // Pop repeat count style vars
    ImGui::PopStyleVar(2);
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();
    
    ImGui::PopID();
}

void TrackerSequencerGUI::drawTrackerStatus(TrackerSequencer& sequencer) {


    if (ImGui::Button("Clear Pattern")) {
        sequencer.clearPattern();
    }
    // Pattern controls
    int newNumSteps = sequencer.getCurrentPattern().getStepCount();
    if (ImGui::SliderInt("Steps", &newNumSteps, 4, 64, "%d", ImGuiSliderFlags_AlwaysClamp)) {
        if (newNumSteps != sequencer.getCurrentPattern().getStepCount()) {
            sequencer.getCurrentPattern().setStepCount(newNumSteps);
        }
    }
    
    ImGui::SameLine();
    
    // 'D' button to double steps (duplicate all steps to double pattern length)
    if (ImGui::Button("D", ImVec2(20, 20))) {
        sequencer.getCurrentPattern().doubleSteps();
    }
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Double pattern length (duplicate all steps)");
    }
    
    int newStepsPerBeat = sequencer.getStepsPerBeat();
    if (ImGui::SliderInt("Steps Per Beat", &newStepsPerBeat, 1, 96, "%d", ImGuiSliderFlags_AlwaysClamp)) {
        sequencer.setStepsPerBeat(newStepsPerBeat);
    }

    ImGui::Separator();
}

void TrackerSequencerGUI::drawPatternGrid(TrackerSequencer& sequencer) {
    // Track changes for optimization
    patternDirty = false;
    lastNumSteps = sequencer.getCurrentPattern().getStepCount();
    lastPlaybackStep = sequencer.getPlaybackStepIndex();
    
    // DEBUG: Log focus state changes
    static int lastEditStep = -1;
    static int lastEditColumn = -1;
    static bool lastIsEditingCell = false;
    
    // Use GUI's own state instead of sequencer's (GUI state moved to TrackerSequencerGUI)
    int currentEditStep = editStep;
    int currentEditColumn = editColumn;
    bool currentIsEditingCell = isEditingCell;
    
    if (currentEditStep != lastEditStep || 
        currentEditColumn != lastEditColumn ||
        currentIsEditingCell != lastIsEditingCell) {
        ofLogNotice("TrackerSequencerGUI") << "[FOCUS_DEBUG] Pattern grid focus state changed - "
                                            << "editStep: " << currentEditStep
                                            << ", editColumn: " << currentEditColumn
                                            << ", isEditingCell: " << currentIsEditingCell;
        lastEditStep = currentEditStep;
        lastEditColumn = currentEditColumn;
        lastIsEditingCell = currentIsEditingCell;
    }
    
    // No parent widget - cells are directly navigable like other widgets
    // ImGui handles navigation naturally when pressing UP on first row
    
    // Compact styling
    ImGui::PushStyleVar(ImGuiStyleVar_CellPadding, ImVec2(2, 2));
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(1, 1));
    
    // Ensure column configuration is initialized
    if (sequencer.getColumnConfiguration().empty()) {
        sequencer.initializeDefaultColumns();
    }
    
    // PERFORMANCE: Cache all expensive calls ONCE per frame
    // Cache active step info ONCE per frame (not per row!)
    bool isPlaying = sequencer.isPlaying();
    int currentPlayingStep = sequencer.getCurrentPlayingStep();
    int playbackStep = sequencer.getPlaybackStepIndex();
    
    // Cache edit state to avoid repeated member access
    // Use GUI's own state instead of sequencer's (GUI state moved to TrackerSequencerGUI)
    int cachedEditStep = editStep;
    int cachedEditColumn = editColumn;
    bool cachedIsEditingCell = isEditingCell;
    
    // Cache indexRangeCallback result (expensive callback - called once instead of 16+ times)
    int maxIndex = sequencer.indexRangeCallback ? sequencer.indexRangeCallback() : 127;
    
    // Cache parameter ranges and defaults for all parameter columns (expensive lookups - called once instead of 48+ times)
    std::map<std::string, std::pair<float, float>> paramRanges;
    std::map<std::string, float> paramDefaults;
    for (const auto& col : sequencer.getColumnConfiguration()) {
        // Only cache for dynamic parameters (not fixed columns like "index" or "length")
        if (col.parameterName != "index" && col.parameterName != "length") {
            if (paramRanges.find(col.parameterName) == paramRanges.end()) {
                paramRanges[col.parameterName] = TrackerSequencer::getParameterRange(col.parameterName);
                paramDefaults[col.parameterName] = TrackerSequencer::getParameterDefault(col.parameterName);
            }
        }
    }
    
    // Table setup - match MediaPoolGUI: no ScrollY flag (creates container)
    // Cells are directly navigable like other widgets
    static ImGuiTableFlags flags = ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | 
                                   ImGuiTableFlags_Resizable |
                                   ImGuiTableFlags_SizingFixedFit;
    
    int totalColumns = 1 + (int)sequencer.getColumnConfiguration().size();
    
    if (ImGui::BeginTable("TrackerGrid", totalColumns, flags)) {
        ImGui::TableSetupColumn("##", ImGuiTableColumnFlags_WidthFixed, 30.0f);
        
        // Parameter columns: stretch to fill available space (responsive to panel size)
        // Weight determines proportional sizing:
        // - Index: widest (2.0x weight)
        // - Length: second widest (1.5x weight)
        // - Parameters: roughly half of Index (1.0x weight)
        for (const auto& col : sequencer.getColumnConfiguration()) {
            float weight;
            if (col.parameterName == "index") {
                weight = 2.0f;  // Index is the widest
            } else if (col.parameterName == "length") {
                weight = 1.5f;  // Length is second widest
            } else {
                weight = 1.0f;  // Parameters are roughly half of Index
            }
            // For WidthStretch, the 3rd parameter (init_width_or_weight) is interpreted as the weight
            ImGui::TableSetupColumn(col.displayName.c_str(), ImGuiTableColumnFlags_WidthStretch, weight);
        }
        
        ImGui::TableSetupScrollFreeze(0, 1);
        
        // Custom header row with randomization buttons
        ImGui::TableNextRow(ImGuiTableRowFlags_Headers);
        
        // Step number column header (no button)
        ImGui::TableSetColumnIndex(0);
        ImGui::TableHeader("##");
        
        // Column headers with randomization buttons
        for (size_t i = 0; i < sequencer.getColumnConfiguration().size(); i++) {
            ImGui::TableSetColumnIndex((int)i + 1);
            const auto& colConfig = sequencer.getColumnConfiguration()[i];
            
            ImGui::PushID((int)(i + 1000)); // Unique ID for header buttons
            
            // Get cell position and width before drawing header
            ImVec2 cellStartPos = ImGui::GetCursorScreenPos();
            float columnWidth = ImGui::GetColumnWidth();
            float cellMinY = cellStartPos.y;
            
            // Draw column name first (left-aligned)
            ImGui::TableHeader(colConfig.displayName.c_str());
            
            // Calculate button sizes
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 2));
            float buttonWidth = ImGui::CalcTextSize("R").x + ImGui::GetStyle().FramePadding.x * 2.0f;
            float legatoButtonWidth = 0.0f;
            if (colConfig.parameterName == "length") {
                legatoButtonWidth = ImGui::CalcTextSize("L").x + ImGui::GetStyle().FramePadding.x * 2.0f + 2.0f; // +2 for spacing
            }
            float totalButtonWidth = buttonWidth + legatoButtonWidth;
            float padding = ImGui::GetStyle().CellPadding.x;
            
            // Position buttons to the right edge of the cell
            float cellMaxX = cellStartPos.x + columnWidth;
            float buttonStartX = cellMaxX - totalButtonWidth - padding;
            ImGui::SetCursorScreenPos(ImVec2(buttonStartX, cellMinY));
            

            // Add legato button for length column
            if (colConfig.parameterName == "length") {
                if (ImGui::SmallButton("L")) {
                    sequencer.applyLegato();
                }
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Legato");
                }
                ImGui::SameLine(0.0f, 2.0f);
            }

            // Small randomization button ("R")
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(2, 0));
            if (ImGui::SmallButton("R")) {
                sequencer.randomizeColumn((int)i);
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Randomize");
            }
            
            
            ImGui::PopStyleVar(2);
            ImGui::PopID();
        }
        
        // Draw pattern rows
        pendingRowOutline.shouldDraw = false; // Reset row outline state
        anyCellFocusedThisFrame = false; // Reset focus tracking
        for (int step = 0; step < sequencer.getCurrentPattern().getStepCount(); step++) {
            drawPatternRow(sequencer, step, step == playbackStep, step == cachedEditStep, 
                          isPlaying, currentPlayingStep,
                          maxIndex, paramRanges, paramDefaults, cachedEditStep, cachedEditColumn, cachedIsEditingCell);
        }
        
        // After drawing all rows, if editStep is set but no cell was focused,
        // clear the sequencer's cell focus (focus moved to header row or elsewhere)
        // BUT: Don't clear if we just exited edit mode (shouldRefocusCurrentCell flag is set)
        // This prevents focus loss when ImGui temporarily loses focus after exiting edit mode
        // NOTE: This check happens AFTER all cells are drawn, so it won't interfere with
        // the ViewManager's empty space click handling which clears focus BEFORE drawing
        // Note: shouldRefocusCurrentCell flag removed - GUI manages its own focus state
        if (editStep >= 0 && !anyCellFocusedThisFrame && !isEditingCell) {
            ofLogNotice("TrackerSequencerGUI") << "[FOCUS_DEBUG] Clearing cell focus - no cell was focused this frame (step: " 
                                                << editStep << ", column: " << editColumn << ")";
            clearCellFocus();
        }
        
        // Draw row outline if needed (after all cells are drawn)
        // Use stored X/Y positions which were updated after all cells in the row were drawn
        // Clamp to visible table area to prevent outline from extending beyond panel bounds
        if (pendingRowOutline.shouldDraw) {
            ImDrawList* drawList = ImGui::GetWindowDrawList();
            if (drawList) {
                // Get visible window/content region bounds to clamp the outline
                ImVec2 windowPos = ImGui::GetWindowPos();
                ImVec2 contentRegionMin = ImGui::GetWindowContentRegionMin();
                ImVec2 contentRegionMax = ImGui::GetWindowContentRegionMax();
                
                // Calculate visible bounds (accounting for scrollbars, padding, etc.)
                float visibleXMin = windowPos.x + contentRegionMin.x;
                float visibleXMax = windowPos.x + contentRegionMax.x;
                
                // Clamp row outline to visible bounds
                float clampedXMin = std::max(pendingRowOutline.rowXMin, visibleXMin);
                float clampedXMax = std::min(pendingRowOutline.rowXMax, visibleXMax);
                
                // Only draw if there's a visible portion
                if (clampedXMin < clampedXMax) {
                    ImVec2 rowMin = ImVec2(clampedXMin, pendingRowOutline.rowYMin);
                    ImVec2 rowMax = ImVec2(clampedXMax, pendingRowOutline.rowYMax);
                    drawList->AddRect(rowMin, rowMax, pendingRowOutline.color, 0.0f, 0, 2.0f);
                }
            }
        }
        
        // Check hover state before EndTable (while table is still the active item)
        bool tableHovered = ImGui::IsItemHovered();
        
        ImGui::EndTable();
        
        // NOTE: Empty space click handling is now done in ViewManager::drawTrackerPanel
        // before calling trackerGUI->draw(). This prevents the focus loop issue where
        // ImGui auto-focuses a cell and then we try to clear it, causing a loop.
        // We keep this check as a fallback for clicks outside the window.
        if (editStep >= 0 && ImGui::IsMouseClicked(0)) {
            // Only clear if click is outside the window entirely
            // (Empty space clicks within the window are handled by ViewManager)
            if (!ImGui::IsWindowHovered()) {
                clearCellFocus();
            }
        }
    }
    
    // No parent widget state to update - cells are directly navigable
    
    ImGui::PopStyleVar(2);
    ImGui::Separator();
}

void TrackerSequencerGUI::drawPatternRow(TrackerSequencer& sequencer, int step, bool isPlaybackStep, bool isEditStep,
                                         bool isPlaying, int currentPlayingStep,
                                         int maxIndex, const std::map<std::string, std::pair<float, float>>& paramRanges,
                                         const std::map<std::string, float>& paramDefaults,
                                         int cachedEditStep, int cachedEditColumn, bool cachedIsEditingCell) {
    ImGui::TableNextRow();
    
    // Static cached colors for performance (calculated once at initialization)
    static ImU32 activeStepColor = ImGui::GetColorU32(ImVec4(0.0f, 0.85f, 0.0f, 0.4f));
    static ImU32 inactiveStepColor = ImGui::GetColorU32(ImVec4(0.4f, 0.8f, 0.4f, 0.3f));
    
    // Determine if this step is currently active (playing)
    // Use cached values passed as parameters instead of calling getters
    bool isCurrentPlayingStep = (currentPlayingStep == step);
    
    // Step is active ONLY if it's the current playing step
    // For length=1 steps, currentPlayingStep is cleared when they finish, so they won't show as active
    bool isStepActive = isCurrentPlayingStep;
    
    // Highlight playback step: green when active, slightly green grey when inactive
    if (isPlaybackStep) {
        if (isStepActive) {
            // Active step: bright green (using cached color)
            ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0, activeStepColor);
        } else {
            // Inactive step: slightly green grey (using cached color)
            ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0, inactiveStepColor);
        }
    }
    
    // Draw step number column (pass cached values)
    drawStepNumber(sequencer, step, isPlaybackStep, isPlaying, currentPlayingStep);
    
    // Draw dynamic columns (pass cached values for performance)
    for (size_t i = 0; i < sequencer.getColumnConfiguration().size(); i++) {
        drawParameterCell(sequencer, step, (int)i, maxIndex, paramRanges, paramDefaults,
                         cachedEditStep, cachedEditColumn, cachedIsEditingCell);
    }
    
    // After all cells in row are drawn, update row outline XMax if needed
    // This ensures the outline extends to the last cell's right edge
    if (pendingRowOutline.shouldDraw && pendingRowOutline.step == step) {
        // Get the current cell position (should be the last column after the loop)
        ImVec2 lastCellMin = ImGui::GetCursorScreenPos();
        float lastCellWidth = ImGui::GetColumnWidth();
        pendingRowOutline.rowXMax = lastCellMin.x + lastCellWidth + 1;
    }
}

// Helper to sync playback position to edit position when paused
// Uses public methods since static functions don't have friend class access
static void syncPlaybackToEditIfPaused(TrackerSequencer& sequencer, int newStep, bool stepChanged, bool forceTrigger = false) {
    // Trigger if:
    // 1. Not playing AND step changed AND it's a different step, OR
    // 2. Force trigger is true (e.g., navigating from header row back to a step)
    if (!sequencer.isPlaying() && (forceTrigger || (stepChanged && newStep != sequencer.getPlaybackStep()))) {
        sequencer.setCurrentStep(newStep);
        sequencer.triggerStep(newStep);
    }
}

void TrackerSequencerGUI::drawStepNumber(TrackerSequencer& sequencer, int step, bool isPlaybackStep,
                                         bool isPlaying, int currentPlayingStep) {
    ImGui::TableNextColumn();
    
    // Get cell rect for red outline (before drawing button)
    ImVec2 cellMin = ImGui::GetCursorScreenPos();
    float cellHeight = ImGui::GetFrameHeight();
    float cellWidth = ImGui::GetColumnWidth();
    ImVec2 cellMax = ImVec2(cellMin.x + cellWidth, cellMin.y + cellHeight);
    
    char stepBuf[8];
    snprintf(stepBuf, sizeof(stepBuf), "%02d", step + 1);
    
    // Determine if this step is currently active (playing)
    // Use cached values passed as parameters instead of calling getters
    bool isCurrentPlayingStep = (currentPlayingStep == step);
    
    // Step is active ONLY if it's the current playing step
    // For length=1 steps, currentPlayingStep is cleared when they finish, so they won't show as active
    bool isStepActive = isCurrentPlayingStep;
    
    // Apply button styling for active steps (pushed appearance with green tint)
    if (isStepActive) {
        // Use green-tinted active state for pushed appearance
        ImGui::PushStyleColor(ImGuiCol_Button, ImGui::GetColorU32(ImVec4(0.2f, 0.7f, 0.2f, 0.8f))); // Green active state
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImGui::GetColorU32(ImVec4(0.25f, 0.75f, 0.25f, 0.9f))); // Brighter green on hover
    }
    
    // CRITICAL: Prevent ImGui from auto-focusing step number cells when clicking empty space
    // This prevents the first step cell from being auto-focused when clicking empty space in the panel
    // Cells should only be focused via explicit clicks or keyboard navigation
    ImGui::PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
    
    // Note: shouldRefocusCurrentCell flag removed - GUI manages its own focus state
    // Draw button
    bool buttonClicked = ImGui::Button(stepBuf, ImVec2(-1, 0));
    
    // Pop the flag after creating the button
    ImGui::PopItemFlag();
    
    // Pop button styling if we pushed it
    if (isStepActive) {
        ImGui::PopStyleColor(2);
    }
    
    // Prevent spacebar from triggering button clicks (spacebar should only pause/play)
    // ImGui uses spacebar for button activation, but we want spacebar to be global play/pause
    // Check if spacebar is pressed - if so, ignore this button click
    bool spacebarPressed = ImGui::IsKeyPressed(ImGuiKey_Space, false);
    
    // Only set cell focus if button was actually clicked (not just hovered)
    // Verify the click is within the button bounds to prevent false positives
    bool isItemClicked = ImGui::IsItemClicked(0);
    
    if (buttonClicked && !spacebarPressed && isItemClicked) {
        sequencer.triggerStep(step);
        // Note: editStep/editColumn will be synced below when ImGui::IsItemFocused() is true
        // If focus doesn't happen immediately, we still need to set it here for immediate keyboard input
        setEditCell(step, 0);
    }
    
    // ONE-WAY SYNC: ImGui focus â†’ GUI state
    // Only sync when item was actually clicked or keyboard-navigated
    bool actuallyFocused = ImGui::IsItemFocused();
    if (actuallyFocused) {
        bool itemWasClicked = ImGui::IsItemClicked(0);
        bool keyboardNavActive = (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
        
        // Only sync if this is an intentional focus (click or keyboard nav)
        if (itemWasClicked || keyboardNavActive) {
            anyCellFocusedThisFrame = true;
            bool cellChanged = (editStep != step || editColumn != 0);
            
            // When in edit mode, prevent focus from changing to a different cell
            if (isEditingCell && cellChanged) {
                return; // Exit early - keep focus locked to editing cell
            }
            
            // Sync state to GUI
            int previousStep = editStep;
            setEditCell(step, 0);
            
            // When paused, sync playback position and trigger step (walk through)
            bool stepChanged = (step != sequencer.getPlaybackStep());
            bool fromHeaderRow = (previousStep == -1);
            if (fromHeaderRow || stepChanged) {
                syncPlaybackToEditIfPaused(sequencer, step, stepChanged, fromHeaderRow);
            }
            
            // Exit edit mode if navigating to a different cell
            if (cellChanged && isEditingCell) {
                setInEditMode(false);
                editBufferCache.clear();
                editBufferInitializedCache = false;
                // Note: ParameterCell manages its own edit buffer state
            }
        }
    }
    
    // Draw outline for selected cells only (not hover)
    // When step number cell is selected, draw outline around entire row
    // Don't draw outline if we're on header row (editStep == -1)
    bool isSelected = (editStep == step && editColumn == 0 && editStep >= 0);
    bool isFocused = ImGui::IsItemFocused();
    bool shouldShowOutline = isSelected || (isFocused && !isEditingCell && editStep >= 0);
    
    if (shouldShowOutline) {
        if (isSelected) {
            // Store row outline info to draw after all cells are drawn
            // Store Y position and first cell X position - XMax will be updated after all cells are drawn
            pendingRowOutline.shouldDraw = true;
            pendingRowOutline.step = step;
            pendingRowOutline.rowYMin = cellMin.y - 1;
            pendingRowOutline.rowYMax = cellMax.y + 1;
            pendingRowOutline.rowXMin = cellMin.x - 1; // Store first cell X position
            pendingRowOutline.rowXMax = cellMax.x + 1; // Will be updated after all cells drawn
            
            // Static cached colors for row outline (calculated once at initialization)
            static ImU32 rowOrangeOutlineColor = ImGui::GetColorU32(ImVec4(1.0f, 0.5f, 0.0f, 1.0f));
            static ImU32 rowRedOutlineColor = ImGui::GetColorU32(ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
            
            // Orange outline when in edit mode, red outline when just selected (use cached colors)
            pendingRowOutline.color = (isSelected && isEditingCell)
                ? rowOrangeOutlineColor  // Orange outline in edit mode
                : rowRedOutlineColor; // Red outline when not editing
        } else if (isFocused) {
            // Just draw outline around the step number cell itself (when focused but not selected)
            ImDrawList* drawList = ImGui::GetWindowDrawList();
            if (drawList) {
                // Static cached color for step number outline
                static ImU32 stepNumberOutlineColor = ImGui::GetColorU32(ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
                ImVec2 outlineMin = ImVec2(cellMin.x - 1, cellMin.y - 1);
                ImVec2 outlineMax = ImVec2(cellMax.x + 1, cellMax.y + 1);
                drawList->AddRect(outlineMin, outlineMax, stepNumberOutlineColor, 0.0f, 0, 2.0f); // 2px border
            }
        }
    }
}

void TrackerSequencerGUI::drawParameterCell(TrackerSequencer& sequencer, int step, int colConfigIndex,
                                            int maxIndex, const std::map<std::string, std::pair<float, float>>& paramRanges,
                                            const std::map<std::string, float>& paramDefaults,
                                            int cachedEditStep, int cachedEditColumn, bool cachedIsEditingCell) {
    if (colConfigIndex < 0 || colConfigIndex >= (int)sequencer.getColumnConfiguration().size()) {
        return;
    }
    
    const auto& colConfig = sequencer.getColumnConfiguration()[colConfigIndex];
    ImGui::TableNextColumn();
    
    int editColumnValue = colConfigIndex + 1;
    int uniqueId = step * 1000 + colConfig.columnIndex;
    
    // Create ParameterCell instance using adapter method
    ParameterCell paramCell = sequencer.createParameterCellForColumn(step, editColumnValue);
    
    // Sync state from TrackerSequencer to ParameterCell
    bool isSelected = (cachedEditStep == step && cachedEditColumn == editColumnValue);
    paramCell.isSelected = isSelected;
    paramCell.setEditing(cachedIsEditingCell && isSelected);
    // Restore edit buffer cache if editing (for persistence across frames)
    if (cachedIsEditingCell && isSelected) {
        paramCell.setEditBuffer(editBufferCache);
    }
    
    // Restore drag state if this cell is being dragged (for persistence across frames)
    bool isDraggingThis = (sequencer.draggingStep == step && sequencer.draggingColumn == editColumnValue);
    if (isDraggingThis) {
        // Restore drag state to ParameterCell using the setter method
        paramCell.setDragState(true, sequencer.dragStartY, sequencer.dragStartX, sequencer.lastDragValue);
    }
    
    // Determine focus state
    bool isFocused = (cachedEditStep == step && cachedEditColumn == editColumnValue);
    // Note: shouldFocusFirstCell and shouldRefocusCurrentCell flags removed - GUI manages its own focus state
    bool shouldFocusFirst = false;  // Can be re-implemented if needed
    bool shouldRefocusCurrentCell = false;  // Can be re-implemented if needed
    
    // Draw using ParameterCell
    ParameterCellInteraction interaction = paramCell.draw(uniqueId, isFocused, shouldFocusFirst, shouldRefocusCurrentCell);
    
    // Sync state back from ParameterCell to GUI state
    if (interaction.focusChanged) {
        // Update edit step/column if focus changed
        int previousStep = editStep;
        setEditCell(step, editColumnValue);
        anyCellFocusedThisFrame = true;
        
        // When paused, sync playback position and trigger step (walk through)
        bool stepChanged = (previousStep != step);
        bool fromHeaderRow = (previousStep == -1);
        if (fromHeaderRow || stepChanged) {
            syncPlaybackToEditIfPaused(sequencer, step, stepChanged, fromHeaderRow);
        }
    }
    
    if (interaction.clicked) {
        // Cell was clicked - focus it but don't enter edit mode yet
        setEditCell(step, editColumnValue);
        setInEditMode(false);
        // Note: ParameterCell manages its own edit buffer state
    }
    
    // Sync drag state to TrackerSequencer (for persistence across frames)
    // CRITICAL: Always check drag state if we're dragging this cell, even if mouse is outside cell
    // This ensures drag continues across entire window (Blender-style)
    // Helper lambda to sync drag state
    auto syncDragState = [&](bool isDragging) {
        if (isDragging) {
            sequencer.draggingStep = step;
            sequencer.draggingColumn = editColumnValue;
            sequencer.dragStartY = paramCell.getDragStartY();
            sequencer.dragStartX = paramCell.getDragStartX();
            sequencer.lastDragValue = paramCell.getLastDragValue(); // Keep as float for precision
        } else {
            sequencer.draggingStep = -1;
            sequencer.draggingColumn = -1;
        }
    };
    
    if (interaction.dragStarted || interaction.dragEnded || paramCell.getIsDragging() || isDraggingThis) {
        if (paramCell.getIsDragging()) {
            syncDragState(true);
        } else if (isDraggingThis && !paramCell.getIsDragging()) {
            // Drag ended - clear drag state
            syncDragState(false);
        }
    }
    
    // Sync edit mode state and edit buffer cache if editing
    if (paramCell.isEditingMode()) {
        setInEditMode(true);
        // Cache edit buffer for persistence across frames (ParameterCell owns the logic)
        editBufferCache = paramCell.getEditBuffer();
        setEditBufferInitializedCache(paramCell.isEditBufferInitialized());
    } else if (cachedIsEditingCell && isSelected && !paramCell.isEditingMode()) {
        // Exited edit mode
        setInEditMode(false);
        editBufferCache.clear();
        editBufferInitializedCache = false;
    }
    
    // Early exit if requested (prevents further processing for this cell)
    if (interaction.shouldExitEarly) {
        return;
    }
}


// Sync edit state from ImGui focus - called from InputRouter when keys are pressed
bool TrackerSequencerGUI::syncEditStateFromImGuiFocus() {
    // Check if editStep/editColumn are already valid (GUI sync already happened)
    // This method is called from InputRouter before processing keys to ensure state is synced
    // The actual syncing from ImGui focus happens in the draw methods
    // This method just checks if state is already set
    if (editStep >= 0 && editColumn >= 0) {
        return true; // Already synced
    }
    
    // GUI draw sync should handle this every frame
    // If not set, handleKeyPress will default gracefully
    return false;
}

#pragma once

#include "TrackerSequencer.h"
#include "Pattern.h"

// Forward declarations for ImGui types
typedef unsigned int ImGuiID;
typedef unsigned int ImU32;

class TrackerSequencerGUI {
public:
    TrackerSequencerGUI();
    void draw(TrackerSequencer& sequencer);
    
    // Sync edit state from ImGui focus - called from InputRouter when keys are pressed
    // Note: This is now an instance method since GUI state is managed by TrackerSequencerGUI
    bool syncEditStateFromImGuiFocus();
    
    // GUI state accessors (moved from TrackerSequencer)
    int getEditStep() const { return editStep; }
    int getEditColumn() const { return editColumn; }
    bool getIsEditingCell() const { return isEditingCell; }
    const std::string& getEditBufferCache() const { return editBufferCache; }
    std::string& getEditBufferCache() { return editBufferCache; }
    bool getEditBufferInitializedCache() const { return editBufferInitializedCache; }
    
    // GUI state setters
    void setEditCell(int step, int column) { 
        editStep = step; 
        editColumn = column; 
    }
    void setInEditMode(bool editing) { isEditingCell = editing; }
    void setEditBufferInitializedCache(bool init) { editBufferInitializedCache = init; }
    void clearCellFocus();
    
    // Check if keyboard input should be routed to sequencer
    bool isKeyboardFocused() const { return (editStep >= 0 && editColumn >= 0); }
    
private:
    // GUI state (moved from TrackerSequencer)
    int editStep = -1;      // Currently selected row for editing (-1 = none)
    int editColumn = -1;    // Currently selected column for editing (-1 = none, 0 = step number, 1+ = column index)
    bool isEditingCell = false; // True when in edit mode (typing numeric value)
    std::string editBufferCache; // Cache for edit buffer to persist across frames
    bool editBufferInitializedCache = false; // Cache for edit buffer initialized state
    
    // Performance optimization: dirty flag to avoid expensive string formatting every frame
    bool patternDirty;
    int lastNumSteps;
    int lastPlaybackStep;
    
    // Track if any cell is focused during drawing (to detect header row focus)
    bool anyCellFocusedThisFrame;
    
    // Store parent widget ID for navigation (widget created before table)
    ImGuiID parentWidgetId;
    
    // Row outline tracking for step number hover
    struct RowOutlineState {
        int step;
        float rowYMin;
        float rowYMax;
        float rowXMin;  // Store X positions from first cell
        float rowXMax;  // Store X positions from last cell (calculated after all cells drawn)
        bool shouldDraw;
        ImU32 color;
    };
    RowOutlineState pendingRowOutline;
    
    // Drawing methods
    void drawPatternChain(TrackerSequencer& sequencer);
    void drawTrackerStatus(TrackerSequencer& sequencer);
    void drawPatternGrid(TrackerSequencer& sequencer);
    void drawPatternRow(TrackerSequencer& sequencer, int step, bool isPlaybackStep, bool isEditStep,
                       bool isPlaying, int currentPlayingStep,
                       int maxIndex, const std::map<std::string, std::pair<float, float>>& paramRanges,
                       const std::map<std::string, float>& paramDefaults,
                       int cachedEditStep, int cachedEditColumn, bool cachedIsEditingCell);
    void drawStepNumber(TrackerSequencer& sequencer, int step, bool isPlaybackStep,
                       bool isPlaying, int currentPlayingStep);
    void drawParameterCell(TrackerSequencer& sequencer, int step, int colConfigIndex,
                          int maxIndex, const std::map<std::string, std::pair<float, float>>& paramRanges,
                          const std::map<std::string, float>& paramDefaults,
                          int cachedEditStep, int cachedEditColumn, bool cachedIsEditingCell);
};

#include "MenuBar.h"
#include "ofLog.h"

MenuBar::MenuBar() {
}

void MenuBar::setup(
    std::function<void()> onSavePattern_fn,
    std::function<void()> onLoadPattern_fn,
    std::function<void()> onSaveLayout_fn,
    std::function<void()> onLoadLayout_fn
) {
    onSavePattern = onSavePattern_fn;
    onLoadPattern = onLoadPattern_fn;
    onSaveLayout = onSaveLayout_fn;
    onLoadLayout = onLoadLayout_fn;

    ofLogNotice("MenuBar") << "Setup complete";
}

void MenuBar::draw() {
    if (ImGui::BeginMainMenuBar()) {
        drawFileMenu();
        drawLayoutMenu();
        drawHelpMenu();
        ImGui::EndMainMenuBar();
    }

    // Help popup - draw every frame if open
    // Note: OpenPopup must be called before BeginPopupModal in the same frame
    // So we check if the flag was set and open it, then show the modal
    if (showControlsHelp && ImGui::BeginPopupModal("Controls Help", &showControlsHelp, 
                                    ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Controls");
        ImGui::Text("SPACE: Play/Stop");
        ImGui::Text("R: Reset");
        ImGui::Text("G: Toggle GUI");
        ImGui::Text("N: Next media");
        ImGui::Text("M: Previous media");
        ImGui::Text("S: Save pattern");
        ImGui::Separator();
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Pattern Editing");
        ImGui::Text("Click cells to edit");
        ImGui::Text("Drag to set values");
        ImGui::Text("Right-click for options");
        ImGui::Separator();
        if (ImGui::Button("Close")) {
            showControlsHelp = false;
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }
}

void MenuBar::drawFileMenu() {
    if (ImGui::BeginMenu("File")) {
        if (ImGui::MenuItem("Save Pattern")) {
            if (onSavePattern) onSavePattern();
        }
        if (ImGui::MenuItem("Load Pattern")) {
            if (onLoadPattern) onLoadPattern();
        }
        ImGui::EndMenu();
    }
}

void MenuBar::drawLayoutMenu() {
    if (ImGui::BeginMenu("Layout")) {
        if (ImGui::MenuItem("Save Layout as Default")) {
            if (onSaveLayout) onSaveLayout();
        }
        if (ImGui::MenuItem("Load Default Layout")) {
            if (onLoadLayout) onLoadLayout();
        }
        ImGui::EndMenu();
    }
}

void MenuBar::drawHelpMenu() {
    if (ImGui::BeginMenu("Help")) {
        if (ImGui::MenuItem("Controls")) {
            showControlsHelp = true;
            // OpenPopup must be called in the same frame as BeginPopupModal
            // We'll open it immediately here, then BeginPopupModal will be called in draw()
            ImGui::OpenPopup("Controls Help");
        }
        ImGui::EndMenu();
    }
}

#pragma once
#include "ofMain.h"
#include "ofxImGui.h"
#include <functional>
#include <string>

class MenuBar {
public:
    MenuBar();
    ~MenuBar() = default;

    // Setup with callback functions
    void setup(
        std::function<void()> onSavePattern,
        std::function<void()> onLoadPattern,
        std::function<void()> onSaveLayout,
        std::function<void()> onLoadLayout
    );

    // Called every frame in ofApp::draw()
    // Returns true if menu bar is active (prevents input below)
    void draw();

    // Accessor for help popup state (optional, for external management)
    bool isHelpPopupOpen() const { return showControlsHelp; }
    void closeHelpPopup() { showControlsHelp = false; }

private:
    // Callback functions
    std::function<void()> onSavePattern;
    std::function<void()> onLoadPattern;
    std::function<void()> onSaveLayout;
    std::function<void()> onLoadLayout;

    // UI state
    bool showControlsHelp = false;

    // Private helper methods for each menu section
    void drawFileMenu();
    void drawLayoutMenu();
    void drawHelpMenu();
};

#include "ViewManager.h"
#include "Clock.h"
#include "ClockGUI.h"
#include "MediaPool.h"
#include "MediaPoolGUI.h"
#include "TrackerSequencer.h"
#include "TrackerSequencerGUI.h"
#include "ofxSoundObjects.h"
#include "ofxImGui.h"
#include "ofSoundStream.h"
#include "ofLog.h"

ViewManager::ViewManager() {
}

void ViewManager::setup(
    Clock* clock_,
    ClockGUI* clockGUI_,
    ofxSoundOutput* audioOutput_,
    TrackerSequencer* tracker_,
    TrackerSequencerGUI* trackerGUI_,
    MediaPool* mediaPool_,
    MediaPoolGUI* mediaPoolGUI_,
    ofSoundStream* soundStream_
) {
    clock = clock_;
    clockGUI = clockGUI_;
    audioOutput = audioOutput_;
    tracker = tracker_;
    trackerGUI = trackerGUI_;
    mediaPool = mediaPool_;
    mediaPoolGUI = mediaPoolGUI_;
    soundStream = soundStream_;
    
    // Initialize audio devices
    if (soundStream) {
        audioDevices = soundStream->getDeviceList();
        
        // Find default output device
        for (size_t i = 0; i < audioDevices.size(); i++) {
            if (audioDevices[i].isDefaultOutput) {
                selectedAudioDevice = i;
                break;
            }
        }
        
        // Store listener for future device changes (will be set by ofApp after setup)
        // Initial setup will be done by ofApp after setting listener
    }

    ofLogNotice("ViewManager") << "Setup complete with " 
                               << PANEL_NAMES.size() << " panels";
}

// setAudioDeviceState() removed - audio state is now owned by ViewManager

void ViewManager::navigateToPanel(Panel panel) {
    if (panel < Panel::COUNT) {
        currentPanel = panel;
        ofLogNotice("ViewManager") << "Navigated to: " 
                                   << PANEL_NAMES[static_cast<int>(panel)];
    }
}

void ViewManager::nextPanel() {
    int next = (static_cast<int>(currentPanel) + 1) % static_cast<int>(Panel::COUNT);
    navigateToPanel(static_cast<Panel>(next));
}

void ViewManager::previousPanel() {
    int prev = (static_cast<int>(currentPanel) - 1 + static_cast<int>(Panel::COUNT)) 
             % static_cast<int>(Panel::COUNT);
    navigateToPanel(static_cast<Panel>(prev));
}

void ViewManager::handleMouseClick(int x, int y) {
    // This could be enhanced to detect which panel was clicked
    // For now, ImGui handles this automatically
}

const char* ViewManager::getCurrentPanelName() const {
    int idx = static_cast<int>(currentPanel);
    if (idx >= 0 && idx < PANEL_NAMES.size()) {
        return PANEL_NAMES[idx];
    }
    return "Unknown";
}

void ViewManager::draw() {
    // Draw panels - each panel will set focus if needed (before Begin())
    // We need to track panel changes, but update lastPanel AFTER drawing
    // so each panel can check if it should set focus
    Panel previousPanel = lastPanel;
    
    drawClockPanel(previousPanel);
    drawAudioOutputPanel(previousPanel);
    drawTrackerPanel(previousPanel);
    drawMediaPoolPanel(previousPanel);
    
    // Update lastPanel after drawing (so next frame can detect changes)
    lastPanel = currentPanel;
}

void ViewManager::setFocusIfChanged() {
    // This method is no longer needed - focus setting is handled in draw()
    // Keeping it for compatibility but it does nothing
}

void ViewManager::drawClockPanel(Panel previousPanel) {
    if (clockGUI && clock) {
        // Set focus only when panel changed and this is the current panel
        // Must be called BEFORE Begin() for it to work
        if (currentPanel == Panel::CLOCK && currentPanel != previousPanel) {
            ImGui::SetNextWindowFocus();
        }
        
        if (ImGui::Begin("Clock ")) {
            // Detect mouse click on panel background (not on widgets) to switch focus
            // Only switch if clicking on the window background, not on interactive widgets
            if (ImGui::IsWindowHovered() && ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered()) {
                navigateToPanel(Panel::CLOCK);
            }
            
            // Clock controls
            clockGUI->draw(*clock);
            ImGui::End();
        }
    }
}

void ViewManager::drawAudioOutputPanel(Panel previousPanel) {
    // Set focus only when panel changed and this is the current panel
    // Must be called BEFORE Begin() for it to work
    if (currentPanel == Panel::AUDIO_OUTPUT && currentPanel != previousPanel) {
        ImGui::SetNextWindowFocus();
    }
    
    if (ImGui::Begin("Audio Output")) {
        // Detect mouse click on panel background (not on widgets) to switch focus
        // Only switch if clicking on the window background, not on interactive widgets
        if (ImGui::IsWindowHovered() && ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered()) {
            navigateToPanel(Panel::AUDIO_OUTPUT);
        }
        
        // Audio device selection
        if (!audioDevices.empty()) {
            if (ImGui::Combo("Device", &selectedAudioDevice, [](void* data, int idx, const char** out_text) {
                auto* devices = static_cast<std::vector<ofSoundDevice>*>(data);
                if (idx >= 0 && idx < devices->size()) {
                    *out_text = (*devices)[idx].name.c_str();
                    return true;
                }
                return false;
            }, &audioDevices, audioDevices.size())) {
                audioDeviceChanged = true;
            }
            
            if (audioDeviceChanged && soundStream) {
                // Re-setup audio stream with new device, preserving listener
                setupAudioStream();
                audioDeviceChanged = false;
            }
        }
        
        // Volume control
        ImGui::SliderFloat("Volume", &globalVolume, 0.0f, 1.0f, "%.2f");
        
        // Audio level visualization
            ImGui::PushStyleColor(ImGuiCol_PlotHistogram, ImVec4(0.0f, 1.0f, 0.0f, 1.0f));
        ImGui::ProgressBar(currentAudioLevel, ImVec2(-1, 0), "");
            ImGui::PopStyleColor();
        ImGui::Text("Level: %.3f", currentAudioLevel);
        ImGui::End();
    }
}

void ViewManager::drawTrackerPanel(Panel previousPanel) {
    if (trackerGUI && tracker) {
        // Set focus only when panel changed and this is the current panel
        // Must be called BEFORE Begin() for it to work
        if (currentPanel == Panel::TRACKER && currentPanel != previousPanel) {
            ImGui::SetNextWindowFocus();
        }
        
        if (ImGui::Begin("Tracker Sequencer")) {
            // Detect mouse click on panel background (not on widgets) to switch focus
            // Only switch if clicking on the window background, not on interactive widgets
            // This allows clicking on tracker cells to work regardless of which panel is "current"
            if (ImGui::IsWindowHovered() && ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered()) {
                navigateToPanel(Panel::TRACKER);
            }
            
            trackerGUI->draw(*tracker);
            ImGui::End();
        }
    }
}

void ViewManager::drawMediaPoolPanel(Panel previousPanel) {
    if (mediaPoolGUI && mediaPool) {
        // Set focus only when panel changed and this is the current panel
        // Must be called BEFORE Begin() for it to work
        if (currentPanel == Panel::MEDIA_POOL && currentPanel != previousPanel) {
            ImGui::SetNextWindowFocus();
        }
        
        if (ImGui::Begin("Media Pool")) {
            // Detect mouse click on panel background (not on widgets) to switch focus
            // Only switch if clicking on the window background, not on interactive widgets
            // This allows clicking on media pool items to work regardless of which panel is "current"
            if (ImGui::IsWindowHovered() && ImGui::IsMouseClicked(0) && !ImGui::IsAnyItemHovered()) {
                navigateToPanel(Panel::MEDIA_POOL);
            }
            
            mediaPoolGUI->draw();  // Delegate to separate GUI
            ImGui::End();
        }
    }
}

void ViewManager::setupAudioStream(ofBaseApp* listener) {
    if (!soundStream || audioDevices.empty()) {
        ofLogError("ViewManager") << "Cannot setup audio stream: no soundStream or devices";
        return;
    }
    
    // Use provided listener or stored listener
    ofBaseApp* listenerToUse = listener ? listener : audioListener;
    
    // Close existing stream if open
    soundStream->close();
    
    // Setup audio stream with selected device
    ofSoundStreamSettings settings;
    if (listenerToUse) {
        settings.setOutListener(listenerToUse);
    }
    settings.sampleRate = 44100;
    settings.numOutputChannels = 2;
    settings.numInputChannels = 0;
    settings.bufferSize = 512;
    
    if (selectedAudioDevice >= 0 && selectedAudioDevice < (int)audioDevices.size()) {
        settings.setOutDevice(audioDevices[selectedAudioDevice]);
    }
    
    soundStream->setup(settings);
    ofLogNotice("ViewManager") << "Audio stream setup with device: " 
                               << (selectedAudioDevice < (int)audioDevices.size() 
                                   ? audioDevices[selectedAudioDevice].name 
                                   : "default");
}

#pragma once
#include "ofMain.h"
#include <array>
#include <string>

class Clock;
class ClockGUI;
class MediaPool;
class MediaPoolGUI;
class TrackerSequencer;
class TrackerSequencerGUI;
class ofxSoundOutput;
class ofSoundStream;

// Panel identifiers
enum class Panel {
    CLOCK = 0,
    AUDIO_OUTPUT = 1,
    TRACKER = 2,
    MEDIA_POOL = 3,
    COUNT = 4
};

class ViewManager {
public:
    ViewManager();
    ~ViewManager() = default;

    // Setup - pass all GUI objects and domains
    void setup(
        Clock* clock,
        ClockGUI* clockGUI,
        ofxSoundOutput* audioOutput,
        TrackerSequencer* tracker,
        TrackerSequencerGUI* trackerGUI,
        MediaPool* mediaPool,
        MediaPoolGUI* mediaPoolGUI,
        ofSoundStream* soundStream  // For audio device management
    );

    // Panel navigation
    void navigateToPanel(Panel panel);
    void nextPanel();
    void previousPanel();
    Panel getCurrentPanel() const { return currentPanel; }

    // Mouse click detection and panel switching
    void handleMouseClick(int x, int y);

    // Main draw function - delegates to appropriate panels
    void draw();

    // Getters for current state
    int getCurrentPanelIndex() const { return static_cast<int>(currentPanel); }
    const char* getCurrentPanelName() const;

    // Audio state access (for ofApp to update currentAudioLevel and set listener)
    void setCurrentAudioLevel(float level) { currentAudioLevel = level; }
    float getGlobalVolume() const { return globalVolume; }
    void setAudioListener(ofBaseApp* listener) { audioListener = listener; }
    
    // Audio device management (public for ofApp to call after setting listener)
    void setupAudioStream(ofBaseApp* audioListener = nullptr);

private:
    // Panel references
    Clock* clock = nullptr;
    ClockGUI* clockGUI = nullptr;
    ofxSoundOutput* audioOutput = nullptr;
    TrackerSequencer* tracker = nullptr;
    TrackerSequencerGUI* trackerGUI = nullptr;
    MediaPool* mediaPool = nullptr;
    MediaPoolGUI* mediaPoolGUI = nullptr;
    ofSoundStream* soundStream = nullptr;  // For audio device management

    // Audio Output panel state (owned by ViewManager)
    std::vector<ofSoundDevice> audioDevices;
    int selectedAudioDevice = 0;
    bool audioDeviceChanged = false;
    float globalVolume = 1.0f;
    float currentAudioLevel = 0.0f;
    ofBaseApp* audioListener = nullptr;  // Store listener for device changes

    // State
    Panel currentPanel = Panel::CLOCK;
    Panel lastPanel = Panel::COUNT;  // Invalid, triggers focus on first draw

    // Panel names for debugging/logging
    static constexpr std::array<const char*, 4> PANEL_NAMES = {{
        "Clock ",
        "Audio Output",
        "Tracker Sequencer",
        "Media Pool"
    }};

    // Private draw methods for each panel
    void drawClockPanel(Panel previousPanel);
    void drawAudioOutputPanel(Panel previousPanel);
    void drawTrackerPanel(Panel previousPanel);
    void drawMediaPoolPanel(Panel previousPanel);

    // Helper to set focus when panel changes (not every frame)
    void setFocusIfChanged();
};

// MIT License

// Copyright (c) 2023 Evan Pezent

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// ImPlot v0.17

/*

API BREAKING CHANGES
====================
Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
When you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all implot files.
You can read releases logs https://github.com/epezent/implot/releases for more details.

- 2023/08/20 (0.17) - ImPlotFlags_NoChild was removed as child windows are no longer needed to capture scroll. You can safely remove this flag if you were using it.
- 2023/06/26 (0.15) - Various build fixes related to updates in Dear ImGui internals.
- 2022/11/25 (0.15) - Make PlotText honor ImPlotItemFlags_NoFit.
- 2022/06/19 (0.14) - The signature of ColormapScale has changed to accommodate a new ImPlotColormapScaleFlags parameter
- 2022/06/17 (0.14) - **IMPORTANT** All PlotX functions now take an ImPlotX_Flags `flags` parameter. Where applicable, it is located before the existing `offset` and `stride` parameters.
                      If you were providing offset and stride values, you will need to update your function call to include a `flags` value. If you fail to do this, you will likely see
                      unexpected results or crashes without a compiler warning since these three are all default args. We apologize for the inconvenience, but this was a necessary evil.
                    - PlotBarsH has been removed; use PlotBars + ImPlotBarsFlags_Horizontal instead
                    - PlotErrorBarsH has been removed; use PlotErrorBars + ImPlotErrorBarsFlags_Horizontal
                    - PlotHistogram/PlotHistogram2D signatures changed; `cumulative`, `density`, and `outliers` options now specified via ImPlotHistogramFlags
                    - PlotPieChart signature changed; `normalize` option now specified via ImPlotPieChartFlags
                    - PlotText signature changes; `vertical` option now specified via `ImPlotTextFlags_Vertical`
                    - `PlotVLines` and `PlotHLines` replaced with `PlotInfLines` (+ ImPlotInfLinesFlags_Horizontal )
                    - arguments of ImPlotGetter have been reversed to be consistent with other API callbacks
                    - SetupAxisScale + ImPlotScale have replaced ImPlotAxisFlags_LogScale and ImPlotAxisFlags_Time flags
                    - ImPlotFormatters should now return an int indicating the size written
                    - the signature of ImPlotGetter has been reversed so that void* user_data is the last argument and consistent with other callbacks
- 2021/10/19 (0.13) - MAJOR API OVERHAUL! See #168 and #272
                    - TRIVIAL RENAME:
                      - ImPlotLimits                              -> ImPlotRect
                      - ImPlotYAxis_                              -> ImAxis_
                      - SetPlotYAxis                              -> SetAxis
                      - BeginDragDropTarget                       -> BeginDragDropTargetPlot
                      - BeginDragDropSource                       -> BeginDragDropSourcePlot
                      - ImPlotFlags_NoMousePos                    -> ImPlotFlags_NoMouseText
                      - SetNextPlotLimits                         -> SetNextAxesLimits
                      - SetMouseTextLocation                      -> SetupMouseText
                    - SIGNATURE MODIFIED:
                      - PixelsToPlot/PlotToPixels                 -> added optional X-Axis arg
                      - GetPlotMousePos                           -> added optional X-Axis arg
                      - GetPlotLimits                             -> added optional X-Axis arg
                      - GetPlotSelection                          -> added optional X-Axis arg
                      - DragLineX/Y/DragPoint                     -> now takes int id; removed labels (render with Annotation/Tag instead)
                    - REPLACED:
                      - IsPlotXAxisHovered/IsPlotXYAxisHovered    -> IsAxisHovered(ImAxis)
                      - BeginDragDropTargetX/BeginDragDropTargetY -> BeginDragDropTargetAxis(ImAxis)
                      - BeginDragDropSourceX/BeginDragDropSourceY -> BeginDragDropSourceAxis(ImAxis)
                      - ImPlotCol_XAxis, ImPlotCol_YAxis1, etc.   -> ImPlotCol_AxisText (push/pop this around SetupAxis to style individual axes)
                      - ImPlotCol_XAxisGrid, ImPlotCol_Y1AxisGrid -> ImPlotCol_AxisGrid (push/pop this around SetupAxis to style individual axes)
                      - SetNextPlotLimitsX/Y                      -> SetNextAxisLimits(ImAxis)
                      - LinkNextPlotLimits                        -> SetNextAxisLinks(ImAxis)
                      - FitNextPlotAxes                           -> SetNextAxisToFit(ImAxis)/SetNextAxesToFit
                      - SetLegendLocation                         -> SetupLegend
                      - ImPlotFlags_NoHighlight                   -> ImPlotLegendFlags_NoHighlight
                      - ImPlotOrientation                         -> ImPlotLegendFlags_Horizontal
                      - Annotate                                  -> Annotation
                    - REMOVED:
                      - GetPlotQuery, SetPlotQuery, IsPlotQueried -> use DragRect
                      - SetNextPlotTicksX, SetNextPlotTicksY      -> use SetupAxisTicks
                      - SetNextPlotFormatX, SetNextPlotFormatY    -> use SetupAxisFormat
                      - AnnotateClamped                           -> use Annotation(bool clamp = true)
                    - OBSOLETED:
                      - BeginPlot (original signature)            -> use simplified signature + Setup API
- 2021/07/30 (0.12) - The offset argument of `PlotXG` functions was been removed. Implement offsetting in your getter callback instead.
- 2021/03/08 (0.9)  - SetColormap and PushColormap(ImVec4*) were removed. Use AddColormap for custom colormap support. LerpColormap was changed to SampleColormap.
                      ShowColormapScale was changed to ColormapScale and requires additional arguments.
- 2021/03/07 (0.9)  - The signature of ShowColormapScale was modified to accept a ImVec2 size.
- 2021/02/28 (0.9)  - BeginLegendDragDropSource was changed to BeginDragDropSourceItem with a number of other drag and drop improvements.
- 2021/01/18 (0.9)  - The default behavior for opening context menus was change from double right-click to single right-click. ImPlotInputMap and related functions were moved
                      to implot_internal.h due to its immaturity.
- 2020/10/16 (0.8)  - ImPlotStyleVar_InfoPadding was changed to ImPlotStyleVar_MousePosPadding
- 2020/09/10 (0.8)  - The single array versions of PlotLine, PlotScatter, PlotStems, and PlotShaded were given additional arguments for x-scale and x0.
- 2020/09/07 (0.8)  - Plotting functions which accept a custom getter function pointer have been post-fixed with a G (e.g. PlotLineG)
- 2020/09/06 (0.7)  - Several flags under ImPlotFlags and ImPlotAxisFlags were inverted (e.g. ImPlotFlags_Legend -> ImPlotFlags_NoLegend) so that the default flagset
                      is simply 0. This more closely matches ImGui's style and makes it easier to enable non-default but commonly used flags (e.g. ImPlotAxisFlags_Time).
- 2020/08/28 (0.5)  - ImPlotMarker_ can no longer be combined with bitwise OR, |. This features caused unecessary slow-down, and almost no one used it.
- 2020/08/25 (0.5)  - ImPlotAxisFlags_Scientific was removed. Logarithmic axes automatically uses scientific notation.
- 2020/08/17 (0.5)  - PlotText was changed so that text is centered horizontally and vertically about the desired point.
- 2020/08/16 (0.5)  - An ImPlotContext must be explicitly created and destroyed now with `CreateContext` and `DestroyContext`. Previously, the context was statically initialized in this source file.
- 2020/06/13 (0.4)  - The flags `ImPlotAxisFlag_Adaptive` and `ImPlotFlags_Cull` were removed. Both are now done internally by default.
- 2020/06/03 (0.3)  - The signature and behavior of PlotPieChart was changed so that data with sum less than 1 can optionally be normalized. The label format can now be specified as well.
- 2020/06/01 (0.3)  - SetPalette was changed to `SetColormap` for consistency with other plotting libraries. `RestorePalette` was removed. Use `SetColormap(ImPlotColormap_Default)`.
- 2020/05/31 (0.3)  - Plot functions taking custom ImVec2* getters were removed. Use the ImPlotPoint* getter versions instead.
- 2020/05/29 (0.3)  - The signature of ImPlotLimits::Contains was changed to take two doubles instead of ImVec2
- 2020/05/16 (0.2)  - All plotting functions were reverted to being prefixed with "Plot" to maintain a consistent VerbNoun style. `Plot` was split into `PlotLine`
                      and `PlotScatter` (however, `PlotLine` can still be used to plot scatter points as `Plot` did before.). `Bar` is not `PlotBars`, to indicate
                      that multiple bars will be plotted.
- 2020/05/13 (0.2)  - `ImMarker` was change to `ImPlotMarker` and `ImAxisFlags` was changed to `ImPlotAxisFlags`.
- 2020/05/11 (0.2)  - `ImPlotFlags_Selection` was changed to `ImPlotFlags_BoxSelect`
- 2020/05/11 (0.2)  - The namespace ImGui:: was replaced with ImPlot::. As a result, the following additional changes were made:
                      - Functions that were prefixed or decorated with the word "Plot" have been truncated. E.g., `ImGui::PlotBars` is now just `ImPlot::Bar`.
                        It should be fairly obvious what was what.
                      - Some functions have been given names that would have otherwise collided with the ImGui namespace. This has been done to maintain a consistent
                        style with ImGui. E.g., 'ImGui::PushPlotStyleVar` is now 'ImPlot::PushStyleVar'.
- 2020/05/10 (0.2)  - The following function/struct names were changes:
                     - ImPlotRange       -> ImPlotLimits
                     - GetPlotRange()    -> GetPlotLimits()
                     - SetNextPlotRange  -> SetNextPlotLimits
                     - SetNextPlotRangeX -> SetNextPlotLimitsX
                     - SetNextPlotRangeY -> SetNextPlotLimitsY
- 2020/05/10 (0.2)  - Plot queries are pixel based by default. Query rects that maintain relative plot position have been removed. This was done to support multi-y-axis.

*/

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "implot.h"
#ifndef IMGUI_DISABLE
#include "implot_internal.h"

#include <stdlib.h>

// Support for pre-1.82 versions. Users on 1.82+ can use 0 (default) flags to mean "all corners" but in order to support older versions we are more explicit.
#if (IMGUI_VERSION_NUM < 18102) && !defined(ImDrawFlags_RoundCornersAll)
#define ImDrawFlags_RoundCornersAll ImDrawCornerFlags_All
#endif

// Support for pre-1.89.7 versions.
#if (IMGUI_VERSION_NUM < 18966)
#define ImGuiButtonFlags_AllowOverlap ImGuiButtonFlags_AllowItemOverlap
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic ignored "-Wformat-nonliteral"  // warning: format string is not a string literal
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wformat-nonliteral"    // warning: format not a string literal, format string not checked
#endif

// Global plot context
#ifndef GImPlot
ImPlotContext* GImPlot = nullptr;
#endif

//-----------------------------------------------------------------------------
// Struct Implementations
//-----------------------------------------------------------------------------

ImPlotInputMap::ImPlotInputMap() {
    ImPlot::MapInputDefault(this);
}

ImPlotStyle::ImPlotStyle() {

    LineWeight         = 1;
    Marker             = ImPlotMarker_None;
    MarkerSize         = 4;
    MarkerWeight       = 1;
    FillAlpha          = 1;
    ErrorBarSize       = 5;
    ErrorBarWeight     = 1.5f;
    DigitalBitHeight   = 8;
    DigitalBitGap      = 4;

    PlotBorderSize     = 1;
    MinorAlpha         = 0.25f;
    MajorTickLen       = ImVec2(10,10);
    MinorTickLen       = ImVec2(5,5);
    MajorTickSize      = ImVec2(1,1);
    MinorTickSize      = ImVec2(1,1);
    MajorGridSize      = ImVec2(1,1);
    MinorGridSize      = ImVec2(1,1);
    PlotPadding        = ImVec2(10,10);
    LabelPadding       = ImVec2(5,5);
    LegendPadding      = ImVec2(10,10);
    LegendInnerPadding = ImVec2(5,5);
    LegendSpacing      = ImVec2(5,0);
    MousePosPadding    = ImVec2(10,10);
    AnnotationPadding  = ImVec2(2,2);
    FitPadding         = ImVec2(0,0);
    PlotDefaultSize    = ImVec2(400,300);
    PlotMinSize        = ImVec2(200,150);

    ImPlot::StyleColorsAuto(this);

    Colormap = ImPlotColormap_Deep;

    UseLocalTime     = false;
    Use24HourClock   = false;
    UseISO8601       = false;
}

//-----------------------------------------------------------------------------
// Style
//-----------------------------------------------------------------------------

namespace ImPlot {

const char* GetStyleColorName(ImPlotCol col) {
    static const char* col_names[ImPlotCol_COUNT] = {
        "Line",
        "Fill",
        "MarkerOutline",
        "MarkerFill",
        "ErrorBar",
        "FrameBg",
        "PlotBg",
        "PlotBorder",
        "LegendBg",
        "LegendBorder",
        "LegendText",
        "TitleText",
        "InlayText",
        "AxisText",
        "AxisGrid",
        "AxisTick",
        "AxisBg",
        "AxisBgHovered",
        "AxisBgActive",
        "Selection",
        "Crosshairs"
    };
    return col_names[col];
}

const char* GetMarkerName(ImPlotMarker marker) {
    switch (marker) {
        case ImPlotMarker_None:     return "None";
        case ImPlotMarker_Circle:   return "Circle";
        case ImPlotMarker_Square:   return "Square";
        case ImPlotMarker_Diamond:  return "Diamond";
        case ImPlotMarker_Up:       return "Up";
        case ImPlotMarker_Down:     return "Down";
        case ImPlotMarker_Left:     return "Left";
        case ImPlotMarker_Right:    return "Right";
        case ImPlotMarker_Cross:    return "Cross";
        case ImPlotMarker_Plus:     return "Plus";
        case ImPlotMarker_Asterisk: return "Asterisk";
        default:                    return "";
    }
}

ImVec4 GetAutoColor(ImPlotCol idx) {
    ImVec4 col(0,0,0,1);
    switch(idx) {
        case ImPlotCol_Line:          return col; // these are plot dependent!
        case ImPlotCol_Fill:          return col; // these are plot dependent!
        case ImPlotCol_MarkerOutline: return col; // these are plot dependent!
        case ImPlotCol_MarkerFill:    return col; // these are plot dependent!
        case ImPlotCol_ErrorBar:      return ImGui::GetStyleColorVec4(ImGuiCol_Text);
        case ImPlotCol_FrameBg:       return ImGui::GetStyleColorVec4(ImGuiCol_FrameBg);
        case ImPlotCol_PlotBg:        return ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);
        case ImPlotCol_PlotBorder:    return ImGui::GetStyleColorVec4(ImGuiCol_Border);
        case ImPlotCol_LegendBg:      return ImGui::GetStyleColorVec4(ImGuiCol_PopupBg);
        case ImPlotCol_LegendBorder:  return GetStyleColorVec4(ImPlotCol_PlotBorder);
        case ImPlotCol_LegendText:    return GetStyleColorVec4(ImPlotCol_InlayText);
        case ImPlotCol_TitleText:     return ImGui::GetStyleColorVec4(ImGuiCol_Text);
        case ImPlotCol_InlayText:     return ImGui::GetStyleColorVec4(ImGuiCol_Text);
        case ImPlotCol_AxisText:      return ImGui::GetStyleColorVec4(ImGuiCol_Text);
        case ImPlotCol_AxisGrid:      return GetStyleColorVec4(ImPlotCol_AxisText) * ImVec4(1,1,1,0.25f);
        case ImPlotCol_AxisTick:      return GetStyleColorVec4(ImPlotCol_AxisGrid);
        case ImPlotCol_AxisBg:        return ImVec4(0,0,0,0);
        case ImPlotCol_AxisBgHovered: return ImGui::GetStyleColorVec4(ImGuiCol_ButtonHovered);
        case ImPlotCol_AxisBgActive:  return ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive);
        case ImPlotCol_Selection:     return ImVec4(1,1,0,1);
        case ImPlotCol_Crosshairs:    return GetStyleColorVec4(ImPlotCol_PlotBorder);
        default: return col;
    }
}

struct ImPlotStyleVarInfo {
    ImGuiDataType   Type;
    ImU32           Count;
    ImU32           Offset;
    void*           GetVarPtr(ImPlotStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const ImPlotStyleVarInfo GPlotStyleVarInfo[] =
{
    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, LineWeight)         }, // ImPlotStyleVar_LineWeight
    { ImGuiDataType_S32,   1, (ImU32)offsetof(ImPlotStyle, Marker)             }, // ImPlotStyleVar_Marker
    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, MarkerSize)         }, // ImPlotStyleVar_MarkerSize
    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, MarkerWeight)       }, // ImPlotStyleVar_MarkerWeight
    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, FillAlpha)          }, // ImPlotStyleVar_FillAlpha
    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, ErrorBarSize)       }, // ImPlotStyleVar_ErrorBarSize
    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, ErrorBarWeight)     }, // ImPlotStyleVar_ErrorBarWeight
    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, DigitalBitHeight)   }, // ImPlotStyleVar_DigitalBitHeight
    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, DigitalBitGap)      }, // ImPlotStyleVar_DigitalBitGap

    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, PlotBorderSize)     }, // ImPlotStyleVar_PlotBorderSize
    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImPlotStyle, MinorAlpha)         }, // ImPlotStyleVar_MinorAlpha
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MajorTickLen)       }, // ImPlotStyleVar_MajorTickLen
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MinorTickLen)       }, // ImPlotStyleVar_MinorTickLen
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MajorTickSize)      }, // ImPlotStyleVar_MajorTickSize
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MinorTickSize)      }, // ImPlotStyleVar_MinorTickSize
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MajorGridSize)      }, // ImPlotStyleVar_MajorGridSize
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MinorGridSize)      }, // ImPlotStyleVar_MinorGridSize
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, PlotPadding)        }, // ImPlotStyleVar_PlotPadding
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, LabelPadding)       }, // ImPlotStyleVar_LabelPaddine
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, LegendPadding)      }, // ImPlotStyleVar_LegendPadding
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, LegendInnerPadding) }, // ImPlotStyleVar_LegendInnerPadding
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, LegendSpacing)      }, // ImPlotStyleVar_LegendSpacing

    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, MousePosPadding)    }, // ImPlotStyleVar_MousePosPadding
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, AnnotationPadding)  }, // ImPlotStyleVar_AnnotationPadding
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, FitPadding)         }, // ImPlotStyleVar_FitPadding
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, PlotDefaultSize)    }, // ImPlotStyleVar_PlotDefaultSize
    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImPlotStyle, PlotMinSize)        }  // ImPlotStyleVar_PlotMinSize
};

static const ImPlotStyleVarInfo* GetPlotStyleVarInfo(ImPlotStyleVar idx) {
    IM_ASSERT(idx >= 0 && idx < ImPlotStyleVar_COUNT);
    IM_ASSERT(IM_ARRAYSIZE(GPlotStyleVarInfo) == ImPlotStyleVar_COUNT);
    return &GPlotStyleVarInfo[idx];
}

//-----------------------------------------------------------------------------
// Generic Helpers
//-----------------------------------------------------------------------------

void AddTextVertical(ImDrawList *DrawList, ImVec2 pos, ImU32 col, const char *text_begin, const char* text_end) {
    // the code below is based loosely on ImFont::RenderText
    if (!text_end)
        text_end = text_begin + strlen(text_begin);
    ImGuiContext& g = *GImGui;
#ifdef IMGUI_HAS_TEXTURES
    ImFontBaked* font = g.Font->GetFontBaked(g.FontSize);
    const float scale = g.FontSize / font->Size;
#else
    ImFont* font = g.Font;
    const float scale = g.FontSize / font->FontSize;
#endif
    // Align to be pixel perfect
    pos.x = ImFloor(pos.x);
    pos.y = ImFloor(pos.y);
    const char* s = text_begin;
    int chars_exp = (int)(text_end - s);
    int chars_rnd = 0;
    const int vtx_count_max = chars_exp * 4;
    const int idx_count_max = chars_exp * 6;
    DrawList->PrimReserve(idx_count_max, vtx_count_max);
    while (s < text_end) {
        unsigned int c = (unsigned int)*s;
        if (c < 0x80) {
            s += 1;
        }
        else {
            s += ImTextCharFromUtf8(&c, s, text_end);
            if (c == 0) // Malformed UTF-8?
                break;
        }
        const ImFontGlyph * glyph = font->FindGlyph((ImWchar)c);
        if (glyph == nullptr) {
            continue;
        }
        DrawList->PrimQuadUV(pos + ImVec2(glyph->Y0, -glyph->X0) * scale, pos + ImVec2(glyph->Y0, -glyph->X1) * scale,
                             pos + ImVec2(glyph->Y1, -glyph->X1) * scale, pos + ImVec2(glyph->Y1, -glyph->X0) * scale,
                             ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V0),
                             ImVec2(glyph->U1, glyph->V1), ImVec2(glyph->U0, glyph->V1),
                             col);
        pos.y -= glyph->AdvanceX * scale;
        chars_rnd++;
    }
    // Give back unused vertices
    int chars_skp = chars_exp-chars_rnd;
    DrawList->PrimUnreserve(chars_skp*6, chars_skp*4);
}

void AddTextCentered(ImDrawList* DrawList, ImVec2 top_center, ImU32 col, const char* text_begin, const char* text_end) {
    float txt_ht = ImGui::GetTextLineHeight();
    const char* title_end = ImGui::FindRenderedTextEnd(text_begin, text_end);
    ImVec2 text_size;
    float  y = 0;
    while (const char* tmp = (const char*)memchr(text_begin, '\n', title_end-text_begin)) {
        text_size = ImGui::CalcTextSize(text_begin,tmp,true);
        DrawList->AddText(ImVec2(top_center.x - text_size.x * 0.5f, top_center.y+y),col,text_begin,tmp);
        text_begin = tmp + 1;
        y += txt_ht;
    }
    text_size = ImGui::CalcTextSize(text_begin,title_end,true);
    DrawList->AddText(ImVec2(top_center.x - text_size.x * 0.5f, top_center.y+y),col,text_begin,title_end);
}

double NiceNum(double x, bool round) {
    double f;
    double nf;
    int expv = (int)floor(ImLog10(x));
    f = x / ImPow(10.0, (double)expv);
    if (round)
        if (f < 1.5)
            nf = 1;
        else if (f < 3)
            nf = 2;
        else if (f < 7)
            nf = 5;
        else
            nf = 10;
    else if (f <= 1)
        nf = 1;
    else if (f <= 2)
        nf = 2;
    else if (f <= 5)
        nf = 5;
    else
        nf = 10;
    return nf * ImPow(10.0, expv);
}

//-----------------------------------------------------------------------------
// Context Utils
//-----------------------------------------------------------------------------

void SetImGuiContext(ImGuiContext* ctx) {
    ImGui::SetCurrentContext(ctx);
}

ImPlotContext* CreateContext() {
    ImPlotContext* ctx = IM_NEW(ImPlotContext)();
    Initialize(ctx);
    if (GImPlot == nullptr)
        SetCurrentContext(ctx);
    return ctx;
}

void DestroyContext(ImPlotContext* ctx) {
    if (ctx == nullptr)
        ctx = GImPlot;
    if (GImPlot == ctx)
        SetCurrentContext(nullptr);
    IM_DELETE(ctx);
}

ImPlotContext* GetCurrentContext() {
    return GImPlot;
}

void SetCurrentContext(ImPlotContext* ctx) {
    GImPlot = ctx;
}

#define IMPLOT_APPEND_CMAP(name, qual) ctx->ColormapData.Append(#name, name, sizeof(name)/sizeof(ImU32), qual)
#define IM_RGB(r,g,b) IM_COL32(r,g,b,255)

void Initialize(ImPlotContext* ctx) {
    ResetCtxForNextPlot(ctx);
    ResetCtxForNextAlignedPlots(ctx);
    ResetCtxForNextSubplot(ctx);

    const ImU32 Deep[]     = {4289753676, 4283598045, 4285048917, 4283584196, 4289950337, 4284512403, 4291005402, 4287401100, 4285839820, 4291671396                        };
    const ImU32 Dark[]     = {4280031972, 4290281015, 4283084621, 4288892568, 4278222847, 4281597951, 4280833702, 4290740727, 4288256409                                    };
    const ImU32 Pastel[]   = {4289639675, 4293119411, 4291161036, 4293184478, 4289124862, 4291624959, 4290631909, 4293712637, 4294111986                                    };
    const ImU32 Paired[]   = {4293119554, 4290017311, 4287291314, 4281114675, 4288256763, 4280031971, 4285513725, 4278222847, 4292260554, 4288298346, 4288282623, 4280834481};
    const ImU32 Viridis[]  = {4283695428, 4285867080, 4287054913, 4287455029, 4287526954, 4287402273, 4286883874, 4285579076, 4283552122, 4280737725, 4280674301            };
    const ImU32 Plasma[]   = {4287039501, 4288480321, 4289200234, 4288941455, 4287638193, 4286072780, 4284638433, 4283139314, 4281771772, 4280667900, 4280416752            };
    const ImU32 Hot[]      = {4278190144, 4278190208, 4278190271, 4278190335, 4278206719, 4278223103, 4278239231, 4278255615, 4283826175, 4289396735, 4294967295            };
    const ImU32 Cool[]     = {4294967040, 4294960666, 4294954035, 4294947661, 4294941030, 4294934656, 4294928025, 4294921651, 4294915020, 4294908646, 4294902015            };
    const ImU32 Pink[]     = {4278190154, 4282532475, 4284308894, 4285690554, 4286879686, 4287870160, 4288794330, 4289651940, 4291685869, 4293392118, 4294967295            };
    const ImU32 Jet[]      = {4289331200, 4294901760, 4294923520, 4294945280, 4294967040, 4289396565, 4283826090, 4278255615, 4278233855, 4278212095, 4278190335            };
    const ImU32 Twilight[] = {IM_RGB(226,217,226),IM_RGB(166,191,202),IM_RGB(109,144,192),IM_RGB(95,88,176),IM_RGB(83,30,124),IM_RGB(47,20,54),IM_RGB(100,25,75),IM_RGB(159,60,80),IM_RGB(192,117,94),IM_RGB(208,179,158),IM_RGB(226,217,226)};
    const ImU32 RdBu[]     = {IM_RGB(103,0,31),IM_RGB(178,24,43),IM_RGB(214,96,77),IM_RGB(244,165,130),IM_RGB(253,219,199),IM_RGB(247,247,247),IM_RGB(209,229,240),IM_RGB(146,197,222),IM_RGB(67,147,195),IM_RGB(33,102,172),IM_RGB(5,48,97)};
    const ImU32 BrBG[]     = {IM_RGB(84,48,5),IM_RGB(140,81,10),IM_RGB(191,129,45),IM_RGB(223,194,125),IM_RGB(246,232,195),IM_RGB(245,245,245),IM_RGB(199,234,229),IM_RGB(128,205,193),IM_RGB(53,151,143),IM_RGB(1,102,94),IM_RGB(0,60,48)};
    const ImU32 PiYG[]     = {IM_RGB(142,1,82),IM_RGB(197,27,125),IM_RGB(222,119,174),IM_RGB(241,182,218),IM_RGB(253,224,239),IM_RGB(247,247,247),IM_RGB(230,245,208),IM_RGB(184,225,134),IM_RGB(127,188,65),IM_RGB(77,146,33),IM_RGB(39,100,25)};
    const ImU32 Spectral[] = {IM_RGB(158,1,66),IM_RGB(213,62,79),IM_RGB(244,109,67),IM_RGB(253,174,97),IM_RGB(254,224,139),IM_RGB(255,255,191),IM_RGB(230,245,152),IM_RGB(171,221,164),IM_RGB(102,194,165),IM_RGB(50,136,189),IM_RGB(94,79,162)};
    const ImU32 Greys[]    = {IM_COL32_WHITE, IM_COL32_BLACK                                                                                                                };

    IMPLOT_APPEND_CMAP(Deep, true);
    IMPLOT_APPEND_CMAP(Dark, true);
    IMPLOT_APPEND_CMAP(Pastel, true);
    IMPLOT_APPEND_CMAP(Paired, true);
    IMPLOT_APPEND_CMAP(Viridis, false);
    IMPLOT_APPEND_CMAP(Plasma, false);
    IMPLOT_APPEND_CMAP(Hot, false);
    IMPLOT_APPEND_CMAP(Cool, false);
    IMPLOT_APPEND_CMAP(Pink, false);
    IMPLOT_APPEND_CMAP(Jet, false);
    IMPLOT_APPEND_CMAP(Twilight, false);
    IMPLOT_APPEND_CMAP(RdBu, false);
    IMPLOT_APPEND_CMAP(BrBG, false);
    IMPLOT_APPEND_CMAP(PiYG, false);
    IMPLOT_APPEND_CMAP(Spectral, false);
    IMPLOT_APPEND_CMAP(Greys, false);
}

void ResetCtxForNextPlot(ImPlotContext* ctx) {
    // reset the next plot/item data
    ctx->NextPlotData.Reset();
    ctx->NextItemData.Reset();
    // reset labels
    ctx->Annotations.Reset();
    ctx->Tags.Reset();
    // reset extents/fit
    ctx->OpenContextThisFrame = false;
    // reset digital plot items count
    ctx->DigitalPlotItemCnt = 0;
    ctx->DigitalPlotOffset = 0;
    // nullify plot
    ctx->CurrentPlot  = nullptr;
    ctx->CurrentItem  = nullptr;
    ctx->PreviousItem = nullptr;
}

void ResetCtxForNextAlignedPlots(ImPlotContext* ctx) {
    ctx->CurrentAlignmentH = nullptr;
    ctx->CurrentAlignmentV = nullptr;
}

void ResetCtxForNextSubplot(ImPlotContext* ctx) {
    ctx->CurrentSubplot      = nullptr;
    ctx->CurrentAlignmentH   = nullptr;
    ctx->CurrentAlignmentV   = nullptr;
}

//-----------------------------------------------------------------------------
// Plot Utils
//-----------------------------------------------------------------------------

ImPlotPlot* GetPlot(const char* title) {
    ImGuiWindow*   Window = GImGui->CurrentWindow;
    const ImGuiID  ID     = Window->GetID(title);
    return GImPlot->Plots.GetByKey(ID);
}

ImPlotPlot* GetCurrentPlot() {
    return GImPlot->CurrentPlot;
}

void BustPlotCache() {
    ImPlotContext& gp = *GImPlot;
    gp.Plots.Clear();
    gp.Subplots.Clear();
}

//-----------------------------------------------------------------------------
// Legend Utils
//-----------------------------------------------------------------------------

ImVec2 GetLocationPos(const ImRect& outer_rect, const ImVec2& inner_size, ImPlotLocation loc, const ImVec2& pad) {
    ImVec2 pos;
    if (ImHasFlag(loc, ImPlotLocation_West) && !ImHasFlag(loc, ImPlotLocation_East))
        pos.x = outer_rect.Min.x + pad.x;
    else if (!ImHasFlag(loc, ImPlotLocation_West) && ImHasFlag(loc, ImPlotLocation_East))
        pos.x = outer_rect.Max.x - pad.x - inner_size.x;
    else
        pos.x = outer_rect.GetCenter().x - inner_size.x * 0.5f;
    // legend reference point y
    if (ImHasFlag(loc, ImPlotLocation_North) && !ImHasFlag(loc, ImPlotLocation_South))
        pos.y = outer_rect.Min.y + pad.y;
    else if (!ImHasFlag(loc, ImPlotLocation_North) && ImHasFlag(loc, ImPlotLocation_South))
        pos.y = outer_rect.Max.y - pad.y - inner_size.y;
    else
        pos.y = outer_rect.GetCenter().y - inner_size.y * 0.5f;
    pos.x = IM_ROUND(pos.x);
    pos.y = IM_ROUND(pos.y);
    return pos;
}

ImVec2 CalcLegendSize(ImPlotItemGroup& items, const ImVec2& pad, const ImVec2& spacing, bool vertical) {
    // vars
    const int   nItems      = items.GetLegendCount();
    const float txt_ht      = ImGui::GetTextLineHeight();
    const float icon_size   = txt_ht;
    // get label max width
    float max_label_width = 0;
    float sum_label_width = 0;
    for (int i = 0; i < nItems; ++i) {
        const char* label       = items.GetLegendLabel(i);
        const float label_width = ImGui::CalcTextSize(label, nullptr, true).x;
        max_label_width         = label_width > max_label_width ? label_width : max_label_width;
        sum_label_width        += label_width;
    }
    // calc legend size
    const ImVec2 legend_size = vertical ?
                               ImVec2(pad.x * 2 + icon_size + max_label_width, pad.y * 2 + nItems * txt_ht + (nItems - 1) * spacing.y) :
                               ImVec2(pad.x * 2 + icon_size * nItems + sum_label_width + (nItems - 1) * spacing.x, pad.y * 2 + txt_ht);
    return legend_size;
}

bool ClampLegendRect(ImRect& legend_rect, const ImRect& outer_rect, const ImVec2& pad) {
    bool clamped = false;
    ImRect outer_rect_pad(outer_rect.Min + pad, outer_rect.Max - pad);
    if (legend_rect.Min.x < outer_rect_pad.Min.x) {
        legend_rect.Min.x = outer_rect_pad.Min.x;
        clamped = true;
    }
    if (legend_rect.Min.y < outer_rect_pad.Min.y) {
        legend_rect.Min.y = outer_rect_pad.Min.y;
        clamped = true;
    }
    if (legend_rect.Max.x > outer_rect_pad.Max.x) {
        legend_rect.Max.x = outer_rect_pad.Max.x;
        clamped = true;
    }
    if (legend_rect.Max.y > outer_rect_pad.Max.y) {
        legend_rect.Max.y = outer_rect_pad.Max.y;
        clamped = true;
    }
    return clamped;
}

int LegendSortingComp(const void* _a, const void* _b) {
    ImPlotItemGroup* items = GImPlot->SortItems;
    const int a = *(const int*)_a;
    const int b = *(const int*)_b;
    const char* label_a = items->GetLegendLabel(a);
    const char* label_b = items->GetLegendLabel(b);
    return strcmp(label_a,label_b);
}

bool ShowLegendEntries(ImPlotItemGroup& items, const ImRect& legend_bb, bool hovered, const ImVec2& pad, const ImVec2& spacing, bool vertical, ImDrawList& DrawList) {
    // vars
    const float txt_ht      = ImGui::GetTextLineHeight();
    const float icon_size   = txt_ht;
    const float icon_shrink = 2;
    ImU32 col_txt           = GetStyleColorU32(ImPlotCol_LegendText);
    ImU32 col_txt_dis       = ImAlphaU32(col_txt, 0.25f);
    // render each legend item
    float sum_label_width = 0;
    bool any_item_hovered = false;

    const int num_items = items.GetLegendCount();
    if (num_items < 1)
        return hovered;
    // build render order
    ImPlotContext& gp = *GImPlot;
    ImVector<int>& indices = gp.TempInt1;
    indices.resize(num_items);
    for (int i = 0; i < num_items; ++i)
        indices[i] = i;
    if (ImHasFlag(items.Legend.Flags, ImPlotLegendFlags_Sort) && num_items > 1) {
        gp.SortItems = &items;
        qsort(indices.Data, num_items, sizeof(int), LegendSortingComp);
    }
    // render
    for (int i = 0; i < num_items; ++i) {
        const int idx           = indices[i];
        ImPlotItem* item        = items.GetLegendItem(idx);
        const char* label       = items.GetLegendLabel(idx);
        const float label_width = ImGui::CalcTextSize(label, nullptr, true).x;
        const ImVec2 top_left   = vertical ?
                                  legend_bb.Min + pad + ImVec2(0, i * (txt_ht + spacing.y)) :
                                  legend_bb.Min + pad + ImVec2(i * (icon_size + spacing.x) + sum_label_width, 0);
        sum_label_width        += label_width;
        ImRect icon_bb;
        icon_bb.Min = top_left + ImVec2(icon_shrink,icon_shrink);
        icon_bb.Max = top_left + ImVec2(icon_size - icon_shrink, icon_size - icon_shrink);
        ImRect label_bb;
        label_bb.Min = top_left;
        label_bb.Max = top_left + ImVec2(label_width + icon_size, icon_size);
        ImU32 col_txt_hl;
        ImU32 col_item = ImAlphaU32(item->Color,1);

        ImRect button_bb(icon_bb.Min, label_bb.Max);

        ImGui::KeepAliveID(item->ID);

        bool item_hov = false;
        bool item_hld = false;
        bool item_clk = ImHasFlag(items.Legend.Flags, ImPlotLegendFlags_NoButtons)
                      ? false
                      : ImGui::ButtonBehavior(button_bb, item->ID, &item_hov, &item_hld);

        if (item_clk)
            item->Show = !item->Show;


        const bool can_hover = (item_hov)
                             && (!ImHasFlag(items.Legend.Flags, ImPlotLegendFlags_NoHighlightItem)
                             || !ImHasFlag(items.Legend.Flags, ImPlotLegendFlags_NoHighlightAxis));

        if (can_hover) {
            item->LegendHoverRect.Min = icon_bb.Min;
            item->LegendHoverRect.Max = label_bb.Max;
            item->LegendHovered = true;
            col_txt_hl = ImMixU32(col_txt, col_item, 64);
            any_item_hovered = true;
        }
        else {
            col_txt_hl = ImGui::GetColorU32(col_txt);
        }
        ImU32 col_icon;
        if (item_hld)
            col_icon = item->Show ? ImAlphaU32(col_item,0.5f) : ImGui::GetColorU32(ImGuiCol_TextDisabled, 0.5f);
        else if (item_hov)
            col_icon = item->Show ? ImAlphaU32(col_item,0.75f) : ImGui::GetColorU32(ImGuiCol_TextDisabled, 0.75f);
        else
            col_icon = item->Show ? col_item : col_txt_dis;

        DrawList.AddRectFilled(icon_bb.Min, icon_bb.Max, col_icon);
        const char* text_display_end = ImGui::FindRenderedTextEnd(label, nullptr);
        if (label != text_display_end)
            DrawList.AddText(top_left + ImVec2(icon_size, 0), item->Show ? col_txt_hl  : col_txt_dis, label, text_display_end);
    }
    return hovered && !any_item_hovered;
}

//-----------------------------------------------------------------------------
// Locators
//-----------------------------------------------------------------------------

static const float TICK_FILL_X = 0.8f;
static const float TICK_FILL_Y = 1.0f;

void Locator_Default(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data) {
    if (range.Min == range.Max)
        return;
    const int nMinor        = 10;
    const int nMajor        = ImMax(2, (int)IM_ROUND(pixels / (vertical ? 300.0f : 400.0f)));
    const double nice_range = NiceNum(range.Size() * 0.99, false);
    const double interval   = NiceNum(nice_range / (nMajor - 1), true);
    const double graphmin   = floor(range.Min / interval) * interval;
    const double graphmax   = ceil(range.Max / interval) * interval;
    bool first_major_set    = false;
    int  first_major_idx    = 0;
    const int idx0 = ticker.TickCount(); // ticker may have user custom ticks
    ImVec2 total_size(0,0);
    for (double major = graphmin; major < graphmax + 0.5 * interval; major += interval) {
        // is this zero? combat zero formatting issues
        if (major-interval < 0 && major+interval > 0)
            major = 0;
        if (range.Contains(major)) {
            if (!first_major_set) {
                first_major_idx = ticker.TickCount();
                first_major_set = true;
            }
            total_size += ticker.AddTick(major, true, 0, true, formatter, formatter_data).LabelSize;
        }
        for (int i = 1; i < nMinor; ++i) {
            double minor = major + i * interval / nMinor;
            if (range.Contains(minor)) {
                total_size += ticker.AddTick(minor, false, 0, true, formatter, formatter_data).LabelSize;
            }
        }
    }
    // prune if necessary
    if ((!vertical && total_size.x > pixels*TICK_FILL_X) || (vertical && total_size.y > pixels*TICK_FILL_Y)) {
        for (int i = first_major_idx-1; i >= idx0; i -= 2)
            ticker.Ticks[i].ShowLabel = false;
        for (int i = first_major_idx+1; i < ticker.TickCount(); i += 2)
            ticker.Ticks[i].ShowLabel = false;
    }
}

bool CalcLogarithmicExponents(const ImPlotRange& range, float pix, bool vertical, int& exp_min, int& exp_max, int& exp_step) {
    if (range.Min * range.Max > 0) {
        const int nMajor = vertical ? ImMax(2, (int)IM_ROUND(pix * 0.02f)) : ImMax(2, (int)IM_ROUND(pix * 0.01f)); // TODO: magic numbers
        double log_min = ImLog10(ImAbs(range.Min));
        double log_max = ImLog10(ImAbs(range.Max));
        double log_a = ImMin(log_min,log_max);
        double log_b = ImMax(log_min,log_max);
        exp_step  = ImMax(1,(int)(log_b - log_a) / nMajor);
        exp_min   = (int)log_a;
        exp_max   = (int)log_b;
        if (exp_step != 1) {
            while(exp_step % 3 != 0)       exp_step++; // make step size multiple of three
            while(exp_min % exp_step != 0) exp_min--;  // decrease exp_min until exp_min + N * exp_step will be 0
        }
        return true;
    }
    return false;
}

void AddTicksLogarithmic(const ImPlotRange& range, int exp_min, int exp_max, int exp_step, ImPlotTicker& ticker, ImPlotFormatter formatter, void* data) {
    const double sign = ImSign(range.Max);
    for (int e = exp_min - exp_step; e < (exp_max + exp_step); e += exp_step) {
        double major1 = sign*ImPow(10, (double)(e));
        double major2 = sign*ImPow(10, (double)(e + 1));
        double interval = (major2 - major1) / 9;
        if (major1 >= (range.Min - DBL_EPSILON) && major1 <= (range.Max + DBL_EPSILON))
            ticker.AddTick(major1, true, 0, true, formatter, data);
        for (int j = 0; j < exp_step; ++j) {
            major1 = sign*ImPow(10, (double)(e+j));
            major2 = sign*ImPow(10, (double)(e+j+1));
            interval = (major2 - major1) / 9;
            for (int i = 1; i < (9 + (int)(j < (exp_step - 1))); ++i) {
                double minor = major1 + i * interval;
                if (minor >= (range.Min - DBL_EPSILON) && minor <= (range.Max + DBL_EPSILON))
                    ticker.AddTick(minor, false, 0, false, formatter, data);
            }
        }
    }
}

void Locator_Log10(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data) {
    int exp_min, exp_max, exp_step;
    if (CalcLogarithmicExponents(range, pixels, vertical, exp_min, exp_max, exp_step))
        AddTicksLogarithmic(range, exp_min, exp_max, exp_step, ticker, formatter, formatter_data);
}

float CalcSymLogPixel(double plt, const ImPlotRange& range, float pixels) {
    double scaleToPixels = pixels / range.Size();
    double scaleMin      = TransformForward_SymLog(range.Min,nullptr);
    double scaleMax      = TransformForward_SymLog(range.Max,nullptr);
    double s             = TransformForward_SymLog(plt, nullptr);
    double t             = (s - scaleMin) / (scaleMax - scaleMin);
    plt                  = range.Min + range.Size() * t;

    return (float)(0 + scaleToPixels * (plt - range.Min));
}

void Locator_SymLog(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data) {
    if (range.Min >= -1 && range.Max <= 1) {
        Locator_Default(ticker, range, pixels, vertical, formatter, formatter_data);
    }
    else if (range.Min * range.Max < 0) { // cross zero
        const float pix_min = 0;
        const float pix_max = pixels;
        const float pix_p1  = CalcSymLogPixel(1, range, pixels);
        const float pix_n1  = CalcSymLogPixel(-1, range, pixels);
        int exp_min_p, exp_max_p, exp_step_p;
        int exp_min_n, exp_max_n, exp_step_n;
        CalcLogarithmicExponents(ImPlotRange(1,range.Max), ImAbs(pix_max-pix_p1),vertical,exp_min_p,exp_max_p,exp_step_p);
        CalcLogarithmicExponents(ImPlotRange(range.Min,-1),ImAbs(pix_n1-pix_min),vertical,exp_min_n,exp_max_n,exp_step_n);
        int exp_step = ImMax(exp_step_n, exp_step_p);
        ticker.AddTick(0,true,0,true,formatter,formatter_data);
        AddTicksLogarithmic(ImPlotRange(1,range.Max), exp_min_p,exp_max_p,exp_step,ticker,formatter,formatter_data);
        AddTicksLogarithmic(ImPlotRange(range.Min,-1),exp_min_n,exp_max_n,exp_step,ticker,formatter,formatter_data);
    }
    else {
        Locator_Log10(ticker, range, pixels, vertical, formatter, formatter_data);
    }
}

void AddTicksCustom(const double* values, const char* const labels[], int n, ImPlotTicker& ticker, ImPlotFormatter formatter, void* data) {
    for (int i = 0; i < n; ++i) {
        if (labels != nullptr)
            ticker.AddTick(values[i], false, 0, true, labels[i]);
        else
            ticker.AddTick(values[i], false, 0, true, formatter, data);
    }
}

//-----------------------------------------------------------------------------
// Time Ticks and Utils
//-----------------------------------------------------------------------------

// this may not be thread safe?
static const double TimeUnitSpans[ImPlotTimeUnit_COUNT] = {
    0.000001,
    0.001,
    1,
    60,
    3600,
    86400,
    2629800,
    31557600
};

inline ImPlotTimeUnit GetUnitForRange(double range) {
    static double cutoffs[ImPlotTimeUnit_COUNT] = {0.001, 1, 60, 3600, 86400, 2629800, 31557600, IMPLOT_MAX_TIME};
    for (int i = 0; i < ImPlotTimeUnit_COUNT; ++i) {
        if (range <= cutoffs[i])
            return (ImPlotTimeUnit)i;
    }
    return ImPlotTimeUnit_Yr;
}

inline int LowerBoundStep(int max_divs, const int* divs, const int* step, int size) {
    if (max_divs < divs[0])
        return 0;
    for (int i = 1; i < size; ++i) {
        if (max_divs < divs[i])
            return step[i-1];
    }
    return step[size-1];
}

inline int GetTimeStep(int max_divs, ImPlotTimeUnit unit) {
    if (unit == ImPlotTimeUnit_Ms || unit == ImPlotTimeUnit_Us) {
        static const int step[] = {500,250,200,100,50,25,20,10,5,2,1};
        static const int divs[] = {2,4,5,10,20,40,50,100,200,500,1000};
        return LowerBoundStep(max_divs, divs, step, 11);
    }
    if (unit == ImPlotTimeUnit_S || unit == ImPlotTimeUnit_Min) {
        static const int step[] = {30,15,10,5,1};
        static const int divs[] = {2,4,6,12,60};
        return LowerBoundStep(max_divs, divs, step, 5);
    }
    else if (unit == ImPlotTimeUnit_Hr) {
        static const int step[] = {12,6,3,2,1};
        static const int divs[] = {2,4,8,12,24};
        return LowerBoundStep(max_divs, divs, step, 5);
    }
    else if (unit == ImPlotTimeUnit_Day) {
        static const int step[] = {14,7,2,1};
        static const int divs[] = {2,4,14,28};
        return LowerBoundStep(max_divs, divs, step, 4);
    }
    else if (unit == ImPlotTimeUnit_Mo) {
        static const int step[] = {6,3,2,1};
        static const int divs[] = {2,4,6,12};
        return LowerBoundStep(max_divs, divs, step, 4);
    }
    return 0;
}

ImPlotTime MkGmtTime(struct tm *ptm) {
    ImPlotTime t;
#ifdef _WIN32
    t.S = _mkgmtime(ptm);
#else
    t.S = timegm(ptm);
#endif
    if (t.S < 0)
        t.S = 0;
    return t;
}

tm* GetGmtTime(const ImPlotTime& t, tm* ptm)
{
#ifdef _WIN32
  if (gmtime_s(ptm, &t.S) == 0)
    return ptm;
  else
    return nullptr;
#else
  return gmtime_r(&t.S, ptm);
#endif
}

ImPlotTime MkLocTime(struct tm *ptm) {
    ImPlotTime t;
    t.S = mktime(ptm);
    if (t.S < 0)
        t.S = 0;
    return t;
}

tm* GetLocTime(const ImPlotTime& t, tm* ptm) {
#ifdef _WIN32
  if (localtime_s(ptm, &t.S) == 0)
    return ptm;
  else
    return nullptr;
#else
    return localtime_r(&t.S, ptm);
#endif
}

ImPlotTime MakeTime(int year, int month, int day, int hour, int min, int sec, int us) {
    tm& Tm = GImPlot->Tm;

    int yr = year - 1900;
    if (yr < 0)
        yr = 0;

    sec  = sec + us / 1000000;
    us   = us % 1000000;

    Tm.tm_sec  = sec;
    Tm.tm_min  = min;
    Tm.tm_hour = hour;
    Tm.tm_mday = day;
    Tm.tm_mon  = month;
    Tm.tm_year = yr;

    ImPlotTime t = MkTime(&Tm);

    t.Us = us;
    return t;
}

int GetYear(const ImPlotTime& t) {
    tm& Tm = GImPlot->Tm;
    GetTime(t, &Tm);
    return Tm.tm_year + 1900;
}

int GetMonth(const ImPlotTime& t) {
    tm& Tm = GImPlot->Tm;
    ImPlot::GetTime(t, &Tm);
    return Tm.tm_mon;
}

ImPlotTime AddTime(const ImPlotTime& t, ImPlotTimeUnit unit, int count) {
    tm& Tm = GImPlot->Tm;
    ImPlotTime t_out = t;
    switch(unit) {
        case ImPlotTimeUnit_Us:  t_out.Us += count;         break;
        case ImPlotTimeUnit_Ms:  t_out.Us += count * 1000;  break;
        case ImPlotTimeUnit_S:   t_out.S  += count;         break;
        case ImPlotTimeUnit_Min: t_out.S  += count * 60;    break;
        case ImPlotTimeUnit_Hr:  t_out.S  += count * 3600;  break;
        case ImPlotTimeUnit_Day: t_out.S  += count * 86400; break;
        case ImPlotTimeUnit_Mo:  for (int i = 0; i < abs(count); ++i) {
                                     GetTime(t_out, &Tm);
                                     if (count > 0)
                                        t_out.S += 86400 * GetDaysInMonth(Tm.tm_year + 1900, Tm.tm_mon);
                                     else if (count < 0)
                                        t_out.S -= 86400 * GetDaysInMonth(Tm.tm_year + 1900 - (Tm.tm_mon == 0 ? 1 : 0), Tm.tm_mon == 0 ? 11 : Tm.tm_mon - 1); // NOT WORKING
                                 }
                                 break;
        case ImPlotTimeUnit_Yr:  for (int i = 0; i < abs(count); ++i) {
                                    if (count > 0)
                                        t_out.S += 86400 * (365 + (int)IsLeapYear(GetYear(t_out)));
                                    else if (count < 0)
                                        t_out.S -= 86400 * (365 + (int)IsLeapYear(GetYear(t_out) - 1));
                                    // this is incorrect if leap year and we are past Feb 28
                                 }
                                 break;
        default:                 break;
    }
    t_out.RollOver();
    return t_out;
}

ImPlotTime FloorTime(const ImPlotTime& t, ImPlotTimeUnit unit) {
    ImPlotContext& gp = *GImPlot;
    GetTime(t, &gp.Tm);
    switch (unit) {
        case ImPlotTimeUnit_S:   return ImPlotTime(t.S, 0);
        case ImPlotTimeUnit_Ms:  return ImPlotTime(t.S, (t.Us / 1000) * 1000);
        case ImPlotTimeUnit_Us:  return t;
        case ImPlotTimeUnit_Yr:  gp.Tm.tm_mon  = 0; // fall-through
        case ImPlotTimeUnit_Mo:  gp.Tm.tm_mday = 1; // fall-through
        case ImPlotTimeUnit_Day: gp.Tm.tm_hour = 0; // fall-through
        case ImPlotTimeUnit_Hr:  gp.Tm.tm_min  = 0; // fall-through
        case ImPlotTimeUnit_Min: gp.Tm.tm_sec  = 0; break;
        default:                 return t;
    }
    return MkTime(&gp.Tm);
}

ImPlotTime CeilTime(const ImPlotTime& t, ImPlotTimeUnit unit) {
    return AddTime(FloorTime(t, unit), unit, 1);
}

ImPlotTime RoundTime(const ImPlotTime& t, ImPlotTimeUnit unit) {
    ImPlotTime t1 = FloorTime(t, unit);
    ImPlotTime t2 = AddTime(t1,unit,1);
    if (t1.S == t2.S)
        return t.Us - t1.Us < t2.Us - t.Us ? t1 : t2;
    return t.S - t1.S < t2.S - t.S ? t1 : t2;
}

ImPlotTime CombineDateTime(const ImPlotTime& date_part, const ImPlotTime& tod_part) {
    ImPlotContext& gp = *GImPlot;
    tm& Tm = gp.Tm;
    GetTime(date_part, &gp.Tm);
    int y = Tm.tm_year;
    int m = Tm.tm_mon;
    int d = Tm.tm_mday;
    GetTime(tod_part, &gp.Tm);
    Tm.tm_year = y;
    Tm.tm_mon  = m;
    Tm.tm_mday = d;
    ImPlotTime t = MkTime(&Tm);
    t.Us = tod_part.Us;
    return t;
}

// TODO: allow users to define these
static const char* MONTH_NAMES[]  = {"January","February","March","April","May","June","July","August","September","October","November","December"};
static const char* WD_ABRVS[]     = {"Su","Mo","Tu","We","Th","Fr","Sa"};
static const char* MONTH_ABRVS[]  = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};

int FormatTime(const ImPlotTime& t, char* buffer, int size, ImPlotTimeFmt fmt, bool use_24_hr_clk) {
    tm& Tm = GImPlot->Tm;
    GetTime(t, &Tm);
    const int us   = t.Us % 1000;
    const int ms   = t.Us / 1000;
    const int sec  = Tm.tm_sec;
    const int min  = Tm.tm_min;
    if (use_24_hr_clk) {
        const int hr   = Tm.tm_hour;
        switch(fmt) {
            case ImPlotTimeFmt_Us:        return ImFormatString(buffer, size, ".%03d %03d", ms, us);
            case ImPlotTimeFmt_SUs:       return ImFormatString(buffer, size, ":%02d.%03d %03d", sec, ms, us);
            case ImPlotTimeFmt_SMs:       return ImFormatString(buffer, size, ":%02d.%03d", sec, ms);
            case ImPlotTimeFmt_S:         return ImFormatString(buffer, size, ":%02d", sec);
            case ImPlotTimeFmt_MinSMs:    return ImFormatString(buffer, size, ":%02d:%02d.%03d", min, sec, ms);
            case ImPlotTimeFmt_HrMinSMs:  return ImFormatString(buffer, size, "%02d:%02d:%02d.%03d", hr, min, sec, ms);
            case ImPlotTimeFmt_HrMinS:    return ImFormatString(buffer, size, "%02d:%02d:%02d", hr, min, sec);
            case ImPlotTimeFmt_HrMin:     return ImFormatString(buffer, size, "%02d:%02d", hr, min);
            case ImPlotTimeFmt_Hr:        return ImFormatString(buffer, size, "%02d:00", hr);
            default:                      return 0;
        }
    }
    else {
        const char* ap = Tm.tm_hour < 12 ? "am" : "pm";
        const int hr   = (Tm.tm_hour == 0 || Tm.tm_hour == 12) ? 12 : Tm.tm_hour % 12;
        switch(fmt) {
            case ImPlotTimeFmt_Us:        return ImFormatString(buffer, size, ".%03d %03d", ms, us);
            case ImPlotTimeFmt_SUs:       return ImFormatString(buffer, size, ":%02d.%03d %03d", sec, ms, us);
            case ImPlotTimeFmt_SMs:       return ImFormatString(buffer, size, ":%02d.%03d", sec, ms);
            case ImPlotTimeFmt_S:         return ImFormatString(buffer, size, ":%02d", sec);
            case ImPlotTimeFmt_MinSMs:    return ImFormatString(buffer, size, ":%02d:%02d.%03d", min, sec, ms);
            case ImPlotTimeFmt_HrMinSMs:  return ImFormatString(buffer, size, "%d:%02d:%02d.%03d%s", hr, min, sec, ms, ap);
            case ImPlotTimeFmt_HrMinS:    return ImFormatString(buffer, size, "%d:%02d:%02d%s", hr, min, sec, ap);
            case ImPlotTimeFmt_HrMin:     return ImFormatString(buffer, size, "%d:%02d%s", hr, min, ap);
            case ImPlotTimeFmt_Hr:        return ImFormatString(buffer, size, "%d%s", hr, ap);
            default:                      return 0;
        }
    }
}

int FormatDate(const ImPlotTime& t, char* buffer, int size, ImPlotDateFmt fmt, bool use_iso_8601) {
    tm& Tm = GImPlot->Tm;
    GetTime(t, &Tm);
    const int day  = Tm.tm_mday;
    const int mon  = Tm.tm_mon + 1;
    const int year = Tm.tm_year + 1900;
    const int yr   = year % 100;
    if (use_iso_8601) {
        switch (fmt) {
            case ImPlotDateFmt_DayMo:   return ImFormatString(buffer, size, "--%02d-%02d", mon, day);
            case ImPlotDateFmt_DayMoYr: return ImFormatString(buffer, size, "%d-%02d-%02d", year, mon, day);
            case ImPlotDateFmt_MoYr:    return ImFormatString(buffer, size, "%d-%02d", year, mon);
            case ImPlotDateFmt_Mo:      return ImFormatString(buffer, size, "--%02d", mon);
            case ImPlotDateFmt_Yr:      return ImFormatString(buffer, size, "%d", year);
            default:                    return 0;
        }
    }
    else {
        switch (fmt) {
            case ImPlotDateFmt_DayMo:   return ImFormatString(buffer, size, "%d/%d", mon, day);
            case ImPlotDateFmt_DayMoYr: return ImFormatString(buffer, size, "%d/%d/%02d", mon, day, yr);
            case ImPlotDateFmt_MoYr:    return ImFormatString(buffer, size, "%s %d", MONTH_ABRVS[Tm.tm_mon], year);
            case ImPlotDateFmt_Mo:      return ImFormatString(buffer, size, "%s", MONTH_ABRVS[Tm.tm_mon]);
            case ImPlotDateFmt_Yr:      return ImFormatString(buffer, size, "%d", year);
            default:                    return 0;
        }
    }
 }

int FormatDateTime(const ImPlotTime& t, char* buffer, int size, ImPlotDateTimeSpec fmt) {
    int written = 0;
    if (fmt.Date != ImPlotDateFmt_None)
        written += FormatDate(t, buffer, size, fmt.Date, fmt.UseISO8601);
    if (fmt.Time != ImPlotTimeFmt_None) {
        if (fmt.Date != ImPlotDateFmt_None)
            buffer[written++] = ' ';
        written += FormatTime(t, &buffer[written], size - written, fmt.Time, fmt.Use24HourClock);
    }
    return written;
}

inline float GetDateTimeWidth(ImPlotDateTimeSpec fmt) {
    static const ImPlotTime t_max_width = MakeTime(2888, 12, 22, 12, 58, 58, 888888); // best guess at time that maximizes pixel width
    char buffer[32];
    FormatDateTime(t_max_width, buffer, 32, fmt);
    return ImGui::CalcTextSize(buffer).x;
}

inline bool TimeLabelSame(const char* l1, const char* l2) {
    size_t len1 = strlen(l1);
    size_t len2 = strlen(l2);
    size_t n  = len1 < len2 ? len1 : len2;
    return strcmp(l1 + len1 - n, l2 + len2 - n) == 0;
}

static const ImPlotDateTimeSpec TimeFormatLevel0[ImPlotTimeUnit_COUNT] = {
    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_Us),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_SMs),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_S),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_HrMin),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,  ImPlotTimeFmt_Hr),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMo, ImPlotTimeFmt_None),
    ImPlotDateTimeSpec(ImPlotDateFmt_Mo,    ImPlotTimeFmt_None),
    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,    ImPlotTimeFmt_None)
};

static const ImPlotDateTimeSpec TimeFormatLevel1[ImPlotTimeUnit_COUNT] = {
    ImPlotDateTimeSpec(ImPlotDateFmt_None,    ImPlotTimeFmt_HrMin),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,    ImPlotTimeFmt_HrMinS),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,    ImPlotTimeFmt_HrMin),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,    ImPlotTimeFmt_HrMin),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_None),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_None),
    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,      ImPlotTimeFmt_None),
    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,      ImPlotTimeFmt_None)
};

static const ImPlotDateTimeSpec TimeFormatLevel1First[ImPlotTimeUnit_COUNT] = {
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_HrMinS),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_HrMinS),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_HrMin),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_HrMin),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_None),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr, ImPlotTimeFmt_None),
    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,      ImPlotTimeFmt_None),
    ImPlotDateTimeSpec(ImPlotDateFmt_Yr,      ImPlotTimeFmt_None)
};

static const ImPlotDateTimeSpec TimeFormatMouseCursor[ImPlotTimeUnit_COUNT] = {
    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_Us),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_SUs),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_SMs),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_HrMinS),
    ImPlotDateTimeSpec(ImPlotDateFmt_None,     ImPlotTimeFmt_HrMin),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMo,    ImPlotTimeFmt_Hr),
    ImPlotDateTimeSpec(ImPlotDateFmt_DayMoYr,  ImPlotTimeFmt_None),
    ImPlotDateTimeSpec(ImPlotDateFmt_MoYr,     ImPlotTimeFmt_None)
};

inline ImPlotDateTimeSpec GetDateTimeFmt(const ImPlotDateTimeSpec* ctx, ImPlotTimeUnit idx) {
    ImPlotStyle& style     = GetStyle();
    ImPlotDateTimeSpec fmt  = ctx[idx];
    fmt.UseISO8601         = style.UseISO8601;
    fmt.Use24HourClock     = style.Use24HourClock;
    return fmt;
}

void Locator_Time(ImPlotTicker& ticker, const ImPlotRange& range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatter_data) {
    IM_ASSERT_USER_ERROR(vertical == false, "Cannot locate Time ticks on vertical axis!");
    (void)vertical;
    // get units for level 0 and level 1 labels
    const ImPlotTimeUnit unit0 = GetUnitForRange(range.Size() / (pixels / 100)); // level = 0 (top)
    const ImPlotTimeUnit unit1 = ImClamp(unit0 + 1, 0, ImPlotTimeUnit_COUNT-1);  // level = 1 (bottom)
    // get time format specs
    const ImPlotDateTimeSpec fmt0 = GetDateTimeFmt(TimeFormatLevel0, unit0);
    const ImPlotDateTimeSpec fmt1 = GetDateTimeFmt(TimeFormatLevel1, unit1);
    const ImPlotDateTimeSpec fmtf = GetDateTimeFmt(TimeFormatLevel1First, unit1);
    // min max times
    const ImPlotTime t_min = ImPlotTime::FromDouble(range.Min);
    const ImPlotTime t_max = ImPlotTime::FromDouble(range.Max);
    // maximum allowable density of labels
    const float max_density = 0.5f;
    // book keeping
    int last_major_offset = -1;
    // formatter data
    Formatter_Time_Data ftd;
    ftd.UserFormatter = formatter;
    ftd.UserFormatterData = formatter_data;
    if (unit0 != ImPlotTimeUnit_Yr) {
        // pixels per major (level 1) division
        const float pix_per_major_div = pixels / (float)(range.Size() / TimeUnitSpans[unit1]);
        // nominal pixels taken up by labels
        const float fmt0_width = GetDateTimeWidth(fmt0);
        const float fmt1_width = GetDateTimeWidth(fmt1);
        const float fmtf_width = GetDateTimeWidth(fmtf);
        // the maximum number of minor (level 0) labels that can fit between major (level 1) divisions
        const int   minor_per_major   = (int)(max_density * pix_per_major_div / fmt0_width);
        // the minor step size (level 0)
        const int step = GetTimeStep(minor_per_major, unit0);
        // generate ticks
        ImPlotTime t1 = FloorTime(ImPlotTime::FromDouble(range.Min), unit1);
        while (t1 < t_max) {
            // get next major
            const ImPlotTime t2 = AddTime(t1, unit1, 1);
            // add major tick
            if (t1 >= t_min && t1 <= t_max) {
                // minor level 0 tick
                ftd.Time = t1; ftd.Spec = fmt0;
                ticker.AddTick(t1.ToDouble(), true, 0, true, Formatter_Time, &ftd);
                // major level 1 tick
                ftd.Time = t1; ftd.Spec = last_major_offset < 0 ? fmtf : fmt1;
                ImPlotTick& tick_maj = ticker.AddTick(t1.ToDouble(), true, 1, true, Formatter_Time, &ftd);
                const char* this_major = ticker.GetText(tick_maj);
                if (last_major_offset >= 0 && TimeLabelSame(ticker.TextBuffer.Buf.Data + last_major_offset, this_major))
                    tick_maj.ShowLabel = false;
                last_major_offset = tick_maj.TextOffset;
            }
            // add minor ticks up until next major
            if (minor_per_major > 1 && (t_min <= t2 && t1 <= t_max)) {
                ImPlotTime t12 = AddTime(t1, unit0, step);
                while (t12 < t2) {
                    float px_to_t2 = (float)((t2 - t12).ToDouble()/range.Size()) * pixels;
                    if (t12 >= t_min && t12 <= t_max) {
                        ftd.Time = t12; ftd.Spec = fmt0;
                        ticker.AddTick(t12.ToDouble(), false, 0, px_to_t2 >= fmt0_width, Formatter_Time, &ftd);
                        if (last_major_offset < 0 && px_to_t2 >= fmt0_width && px_to_t2 >= (fmt1_width + fmtf_width) / 2) {
                            ftd.Time = t12; ftd.Spec = fmtf;
                            ImPlotTick& tick_maj = ticker.AddTick(t12.ToDouble(), true, 1, true, Formatter_Time, &ftd);
                            last_major_offset = tick_maj.TextOffset;
                        }
                    }
                    t12 = AddTime(t12, unit0, step);
                }
            }
            t1 = t2;
        }
    }
    else {
        const ImPlotDateTimeSpec fmty = GetDateTimeFmt(TimeFormatLevel0, ImPlotTimeUnit_Yr);
        const float label_width = GetDateTimeWidth(fmty);
        const int   max_labels  = (int)(max_density * pixels / label_width);
        const int year_min      = GetYear(t_min);
        const int year_max      = GetYear(CeilTime(t_max, ImPlotTimeUnit_Yr));
        const double nice_range = NiceNum((year_max - year_min)*0.99,false);
        const double interval   = NiceNum(nice_range / (max_labels - 1), true);
        const int graphmin      = (int)(floor(year_min / interval) * interval);
        const int graphmax      = (int)(ceil(year_max  / interval) * interval);
        const int step          = (int)interval <= 0 ? 1 : (int)interval;

        for (int y = graphmin; y < graphmax; y += step) {
            ImPlotTime t = MakeTime(y);
            if (t >= t_min && t <= t_max) {
                ftd.Time = t; ftd.Spec = fmty;
                ticker.AddTick(t.ToDouble(), true, 0, true, Formatter_Time, &ftd);
            }
        }
    }
}

//-----------------------------------------------------------------------------
// Context Menu
//-----------------------------------------------------------------------------

template <typename F>
bool DragFloat(const char*, F*, float, F, F) {
    return false;
}

template <>
bool DragFloat<double>(const char* label, double* v, float v_speed, double v_min, double v_max) {
    return ImGui::DragScalar(label, ImGuiDataType_Double, v, v_speed, &v_min, &v_max, "%.3g", 1);
}

template <>
bool DragFloat<float>(const char* label, float* v, float v_speed, float v_min, float v_max) {
    return ImGui::DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, "%.3g", 1);
}

inline void BeginDisabledControls(bool cond) {
    if (cond) {
        ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.25f);
    }
}

inline void EndDisabledControls(bool cond) {
    if (cond) {
        ImGui::PopItemFlag();
        ImGui::PopStyleVar();
    }
}

void ShowAxisContextMenu(ImPlotAxis& axis, ImPlotAxis* equal_axis, bool /*time_allowed*/) {

    ImGui::PushItemWidth(75);
    bool always_locked   = axis.IsRangeLocked() || axis.IsAutoFitting();
    bool label           = axis.HasLabel();
    bool grid            = axis.HasGridLines();
    bool ticks           = axis.HasTickMarks();
    bool labels          = axis.HasTickLabels();
    double drag_speed    = (axis.Range.Size() <= DBL_EPSILON) ? DBL_EPSILON * 1.0e+13 : 0.01 * axis.Range.Size(); // recover from almost equal axis limits.

    if (axis.Scale == ImPlotScale_Time) {
        ImPlotTime tmin = ImPlotTime::FromDouble(axis.Range.Min);
        ImPlotTime tmax = ImPlotTime::FromDouble(axis.Range.Max);

        BeginDisabledControls(always_locked);
        ImGui::CheckboxFlags("##LockMin", (unsigned int*)&axis.Flags, ImPlotAxisFlags_LockMin);
        EndDisabledControls(always_locked);
        ImGui::SameLine();
        BeginDisabledControls(axis.IsLockedMin() || always_locked);
        if (ImGui::BeginMenu("Min Time")) {
            if (ShowTimePicker("mintime", &tmin)) {
                if (tmin >= tmax)
                    tmax = AddTime(tmin, ImPlotTimeUnit_S, 1);
                axis.SetRange(tmin.ToDouble(),tmax.ToDouble());
            }
            ImGui::Separator();
            if (ShowDatePicker("mindate",&axis.PickerLevel,&axis.PickerTimeMin,&tmin,&tmax)) {
                tmin = CombineDateTime(axis.PickerTimeMin, tmin);
                if (tmin >= tmax)
                    tmax = AddTime(tmin, ImPlotTimeUnit_S, 1);
                axis.SetRange(tmin.ToDouble(), tmax.ToDouble());
            }
            ImGui::EndMenu();
        }
        EndDisabledControls(axis.IsLockedMin() || always_locked);

        BeginDisabledControls(always_locked);
        ImGui::CheckboxFlags("##LockMax", (unsigned int*)&axis.Flags, ImPlotAxisFlags_LockMax);
        EndDisabledControls(always_locked);
        ImGui::SameLine();
        BeginDisabledControls(axis.IsLockedMax() || always_locked);
        if (ImGui::BeginMenu("Max Time")) {
            if (ShowTimePicker("maxtime", &tmax)) {
                if (tmax <= tmin)
                    tmin = AddTime(tmax, ImPlotTimeUnit_S, -1);
                axis.SetRange(tmin.ToDouble(),tmax.ToDouble());
            }
            ImGui::Separator();
            if (ShowDatePicker("maxdate",&axis.PickerLevel,&axis.PickerTimeMax,&tmin,&tmax)) {
                tmax = CombineDateTime(axis.PickerTimeMax, tmax);
                if (tmax <= tmin)
                    tmin = AddTime(tmax, ImPlotTimeUnit_S, -1);
                axis.SetRange(tmin.ToDouble(), tmax.ToDouble());
            }
            ImGui::EndMenu();
        }
        EndDisabledControls(axis.IsLockedMax() || always_locked);
    }
    else {
        BeginDisabledControls(always_locked);
        ImGui::CheckboxFlags("##LockMin", (unsigned int*)&axis.Flags, ImPlotAxisFlags_LockMin);
        EndDisabledControls(always_locked);
        ImGui::SameLine();
        BeginDisabledControls(axis.IsLockedMin() || always_locked);
        double temp_min = axis.Range.Min;
        if (DragFloat("Min", &temp_min, (float)drag_speed, -HUGE_VAL, axis.Range.Max - DBL_EPSILON)) {
            axis.SetMin(temp_min,true);
            if (equal_axis != nullptr)
                equal_axis->SetAspect(axis.GetAspect());
        }
        EndDisabledControls(axis.IsLockedMin() || always_locked);

        BeginDisabledControls(always_locked);
        ImGui::CheckboxFlags("##LockMax", (unsigned int*)&axis.Flags, ImPlotAxisFlags_LockMax);
        EndDisabledControls(always_locked);
        ImGui::SameLine();
        BeginDisabledControls(axis.IsLockedMax() || always_locked);
        double temp_max = axis.Range.Max;
        if (DragFloat("Max", &temp_max, (float)drag_speed, axis.Range.Min + DBL_EPSILON, HUGE_VAL)) {
            axis.SetMax(temp_max,true);
            if (equal_axis != nullptr)
                equal_axis->SetAspect(axis.GetAspect());
        }
        EndDisabledControls(axis.IsLockedMax() || always_locked);
    }

    ImGui::Separator();

    ImGui::CheckboxFlags("Auto-Fit",(unsigned int*)&axis.Flags, ImPlotAxisFlags_AutoFit);
    // TODO
    // BeginDisabledControls(axis.IsTime() && time_allowed);
    // ImGui::CheckboxFlags("Log Scale",(unsigned int*)&axis.Flags, ImPlotAxisFlags_LogScale);
    // EndDisabledControls(axis.IsTime() && time_allowed);
    // if (time_allowed) {
    //     BeginDisabledControls(axis.IsLog() || axis.IsSymLog());
    //     ImGui::CheckboxFlags("Time",(unsigned int*)&axis.Flags, ImPlotAxisFlags_Time);
    //     EndDisabledControls(axis.IsLog() || axis.IsSymLog());
    // }
    ImGui::Separator();
    ImGui::CheckboxFlags("Invert",(unsigned int*)&axis.Flags, ImPlotAxisFlags_Invert);
    ImGui::CheckboxFlags("Opposite",(unsigned int*)&axis.Flags, ImPlotAxisFlags_Opposite);
    ImGui::Separator();
    BeginDisabledControls(axis.LabelOffset == -1);
    if (ImGui::Checkbox("Label", &label))
        ImFlipFlag(axis.Flags, ImPlotAxisFlags_NoLabel);
    EndDisabledControls(axis.LabelOffset == -1);
    if (ImGui::Checkbox("Grid Lines", &grid))
        ImFlipFlag(axis.Flags, ImPlotAxisFlags_NoGridLines);
    if (ImGui::Checkbox("Tick Marks", &ticks))
        ImFlipFlag(axis.Flags, ImPlotAxisFlags_NoTickMarks);
    if (ImGui::Checkbox("Tick Labels", &labels))
        ImFlipFlag(axis.Flags, ImPlotAxisFlags_NoTickLabels);

}

bool ShowLegendContextMenu(ImPlotLegend& legend, bool visible) {
    const float s = ImGui::GetFrameHeight();
    bool ret = false;
    if (ImGui::Checkbox("Show",&visible))
        ret = true;
    if (legend.CanGoInside)
        ImGui::CheckboxFlags("Outside",(unsigned int*)&legend.Flags, ImPlotLegendFlags_Outside);
    if (ImGui::RadioButton("H", ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal)))
        legend.Flags |= ImPlotLegendFlags_Horizontal;
    ImGui::SameLine();
    if (ImGui::RadioButton("V", !ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal)))
        legend.Flags &= ~ImPlotLegendFlags_Horizontal;
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(2,2));
    if (ImGui::Button("NW",ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_NorthWest; } ImGui::SameLine();
    if (ImGui::Button("N", ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_North;     } ImGui::SameLine();
    if (ImGui::Button("NE",ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_NorthEast; }
    if (ImGui::Button("W", ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_West;      } ImGui::SameLine();
    if (ImGui::InvisibleButton("C", ImVec2(1.5f*s,s))) {     } ImGui::SameLine();
    if (ImGui::Button("E", ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_East;      }
    if (ImGui::Button("SW",ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_SouthWest; } ImGui::SameLine();
    if (ImGui::Button("S", ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_South;     } ImGui::SameLine();
    if (ImGui::Button("SE",ImVec2(1.5f*s,s))) { legend.Location = ImPlotLocation_SouthEast; }
    ImGui::PopStyleVar();
    return ret;
}

void ShowSubplotsContextMenu(ImPlotSubplot& subplot) {
    if ((ImGui::BeginMenu("Linking"))) {
        if (ImGui::MenuItem("Link Rows",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkRows)))
            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_LinkRows);
        if (ImGui::MenuItem("Link Cols",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkCols)))
            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_LinkCols);
        if (ImGui::MenuItem("Link All X",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllX)))
            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllX);
        if (ImGui::MenuItem("Link All Y",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllY)))
            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllY);
        ImGui::EndMenu();
    }
    if ((ImGui::BeginMenu("Settings"))) {
        BeginDisabledControls(!subplot.HasTitle);
        if (ImGui::MenuItem("Title",nullptr,subplot.HasTitle && !ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoTitle)))
            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_NoTitle);
        EndDisabledControls(!subplot.HasTitle);
        if (ImGui::MenuItem("Resizable",nullptr,!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoResize)))
            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_NoResize);
        if (ImGui::MenuItem("Align",nullptr,!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoAlign)))
            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_NoAlign);
        if (ImGui::MenuItem("Share Items",nullptr,ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ShareItems)))
            ImFlipFlag(subplot.Flags, ImPlotSubplotFlags_ShareItems);
        ImGui::EndMenu();
    }
}

void ShowPlotContextMenu(ImPlotPlot& plot) {
    ImPlotContext& gp = *GImPlot;
    const bool owns_legend = gp.CurrentItems == &plot.Items;
    const bool equal = ImHasFlag(plot.Flags, ImPlotFlags_Equal);

    char buf[16] = {};

    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
        ImPlotAxis& x_axis = plot.XAxis(i);
        if (!x_axis.Enabled || !x_axis.HasMenus())
            continue;
        ImGui::PushID(i);
        ImFormatString(buf, sizeof(buf) - 1, i == 0 ? "X-Axis" : "X-Axis %d", i + 1);
        if (ImGui::BeginMenu(x_axis.HasLabel() ? plot.GetAxisLabel(x_axis) : buf)) {
            ShowAxisContextMenu(x_axis, equal ? x_axis.OrthoAxis : nullptr, false);
            ImGui::EndMenu();
        }
        ImGui::PopID();
    }

    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
        ImPlotAxis& y_axis = plot.YAxis(i);
        if (!y_axis.Enabled || !y_axis.HasMenus())
            continue;
        ImGui::PushID(i);
        ImFormatString(buf, sizeof(buf) - 1, i == 0 ? "Y-Axis" : "Y-Axis %d", i + 1);
        if (ImGui::BeginMenu(y_axis.HasLabel() ? plot.GetAxisLabel(y_axis) : buf)) {
            ShowAxisContextMenu(y_axis, equal ? y_axis.OrthoAxis : nullptr, false);
            ImGui::EndMenu();
        }
        ImGui::PopID();
    }

    ImGui::Separator();
    if (!ImHasFlag(gp.CurrentItems->Legend.Flags, ImPlotLegendFlags_NoMenus)) {
        if ((ImGui::BeginMenu("Legend"))) {
            if (owns_legend) {
                if (ShowLegendContextMenu(plot.Items.Legend, !ImHasFlag(plot.Flags, ImPlotFlags_NoLegend)))
                    ImFlipFlag(plot.Flags, ImPlotFlags_NoLegend);
            }
            else if (gp.CurrentSubplot != nullptr) {
                if (ShowLegendContextMenu(gp.CurrentSubplot->Items.Legend, !ImHasFlag(gp.CurrentSubplot->Flags, ImPlotSubplotFlags_NoLegend)))
                    ImFlipFlag(gp.CurrentSubplot->Flags, ImPlotSubplotFlags_NoLegend);
            }
            ImGui::EndMenu();
        }
    }
    if ((ImGui::BeginMenu("Settings"))) {
        if (ImGui::MenuItem("Equal", nullptr, ImHasFlag(plot.Flags, ImPlotFlags_Equal)))
            ImFlipFlag(plot.Flags, ImPlotFlags_Equal);
        if (ImGui::MenuItem("Box Select",nullptr,!ImHasFlag(plot.Flags, ImPlotFlags_NoBoxSelect)))
            ImFlipFlag(plot.Flags, ImPlotFlags_NoBoxSelect);
        BeginDisabledControls(plot.TitleOffset == -1);
        if (ImGui::MenuItem("Title",nullptr,plot.HasTitle()))
            ImFlipFlag(plot.Flags, ImPlotFlags_NoTitle);
        EndDisabledControls(plot.TitleOffset == -1);
        if (ImGui::MenuItem("Mouse Position",nullptr,!ImHasFlag(plot.Flags, ImPlotFlags_NoMouseText)))
            ImFlipFlag(plot.Flags, ImPlotFlags_NoMouseText);
        if (ImGui::MenuItem("Crosshairs",nullptr,ImHasFlag(plot.Flags, ImPlotFlags_Crosshairs)))
            ImFlipFlag(plot.Flags, ImPlotFlags_Crosshairs);
        ImGui::EndMenu();
    }
    if (gp.CurrentSubplot != nullptr && !ImHasFlag(gp.CurrentSubplot->Flags, ImPlotSubplotFlags_NoMenus)) {
        ImGui::Separator();
        if ((ImGui::BeginMenu("Subplots"))) {
            ShowSubplotsContextMenu(*gp.CurrentSubplot);
            ImGui::EndMenu();
        }
    }
}

//-----------------------------------------------------------------------------
// Axis Utils
//-----------------------------------------------------------------------------

static inline int AxisPrecision(const ImPlotAxis& axis) {
    const double range = axis.Ticker.TickCount() > 1 ? (axis.Ticker.Ticks[1].PlotPos - axis.Ticker.Ticks[0].PlotPos) : axis.Range.Size();
    return Precision(range);
}

static inline double RoundAxisValue(const ImPlotAxis& axis, double value) {
    return RoundTo(value, AxisPrecision(axis));
}

void LabelAxisValue(const ImPlotAxis& axis, double value, char* buff, int size, bool round) {
    ImPlotContext& gp = *GImPlot;
    // TODO: We shouldn't explicitly check that the axis is Time here. Ideally,
    // Formatter_Time would handle the formatting for us, but the code below
    // needs additional arguments which are not currently available in ImPlotFormatter
    if (axis.Locator == Locator_Time) {
        ImPlotTimeUnit unit = axis.Vertical
                            ? GetUnitForRange(axis.Range.Size() / (gp.CurrentPlot->PlotRect.GetHeight() / 100)) // TODO: magic value!
                            : GetUnitForRange(axis.Range.Size() / (gp.CurrentPlot->PlotRect.GetWidth() / 100)); // TODO: magic value!
        FormatDateTime(ImPlotTime::FromDouble(value), buff, size, GetDateTimeFmt(TimeFormatMouseCursor, unit));
    }
    else {
        if (round)
            value = RoundAxisValue(axis, value);
        axis.Formatter(value, buff, size, axis.FormatterData);
    }
}

void UpdateAxisColors(ImPlotAxis& axis) {
    const ImVec4 col_grid = GetStyleColorVec4(ImPlotCol_AxisGrid);
    axis.ColorMaj         = ImGui::GetColorU32(col_grid);
    axis.ColorMin         = ImGui::GetColorU32(col_grid*ImVec4(1,1,1,GImPlot->Style.MinorAlpha));
    axis.ColorTick        = GetStyleColorU32(ImPlotCol_AxisTick);
    axis.ColorTxt         = GetStyleColorU32(ImPlotCol_AxisText);
    axis.ColorBg          = GetStyleColorU32(ImPlotCol_AxisBg);
    axis.ColorHov         = GetStyleColorU32(ImPlotCol_AxisBgHovered);
    axis.ColorAct         = GetStyleColorU32(ImPlotCol_AxisBgActive);
    // axis.ColorHiLi     = IM_COL32_BLACK_TRANS;
}

void PadAndDatumAxesX(ImPlotPlot& plot, float& pad_T, float& pad_B, ImPlotAlignmentData* align) {

    ImPlotContext& gp = *GImPlot;

    const float T = ImGui::GetTextLineHeight();
    const float P = gp.Style.LabelPadding.y;
    const float K = gp.Style.MinorTickLen.x;

    int   count_T = 0;
    int   count_B = 0;
    float last_T  = plot.AxesRect.Min.y;
    float last_B  = plot.AxesRect.Max.y;

    for (int i = IMPLOT_NUM_X_AXES; i-- > 0;) { // FYI: can iterate forward
        ImPlotAxis& axis = plot.XAxis(i);
        if (!axis.Enabled)
            continue;
        const bool label = axis.HasLabel();
        const bool ticks = axis.HasTickLabels();
        const bool opp   = axis.IsOpposite();
        const bool time  = axis.Scale == ImPlotScale_Time;
        if (opp) {
            if (count_T++ > 0)
                pad_T += K + P;
            if (label)
                pad_T += T + P;
            if (ticks)
                pad_T += ImMax(T, axis.Ticker.MaxSize.y) + P + (time ? T + P : 0);
            axis.Datum1 = plot.CanvasRect.Min.y + pad_T;
            axis.Datum2 = last_T;
            last_T = axis.Datum1;
        }
        else {
            if (count_B++ > 0)
                pad_B += K + P;
            if (label)
                pad_B += T + P;
            if (ticks)
                pad_B += ImMax(T, axis.Ticker.MaxSize.y) + P + (time ? T + P : 0);
            axis.Datum1 = plot.CanvasRect.Max.y - pad_B;
            axis.Datum2 = last_B;
            last_B = axis.Datum1;
        }
    }

    if (align) {
        count_T = count_B = 0;
        float delta_T, delta_B;
        align->Update(pad_T,pad_B,delta_T,delta_B);
        for (int i = IMPLOT_NUM_X_AXES; i-- > 0;) {
            ImPlotAxis& axis = plot.XAxis(i);
            if (!axis.Enabled)
                continue;
            if (axis.IsOpposite()) {
                axis.Datum1 += delta_T;
                axis.Datum2 += count_T++ > 1 ? delta_T : 0;
            }
            else {
                axis.Datum1 -= delta_B;
                axis.Datum2 -= count_B++ > 1 ? delta_B : 0;
            }
        }
    }
}

void PadAndDatumAxesY(ImPlotPlot& plot, float& pad_L, float& pad_R, ImPlotAlignmentData* align) {

    //   [   pad_L   ]                 [   pad_R   ]
    //   .................CanvasRect................
    //   :TPWPK.PTPWP _____PlotRect____ PWPTP.KPWPT:
    //   :A # |- A # |-               -| # A -| # A:
    //   :X   |  X   |                 |   X  |   x:
    //   :I # |- I # |-               -| # I -| # I:
    //   :S   |  S   |                 |   S  |   S:
    //   :3 # |- 0 # |-_______________-| # 1 -| # 2:
    //   :.........................................:
    //
    //   T = text height
    //   P = label padding
    //   K = minor tick length
    //   W = label width

    ImPlotContext& gp = *GImPlot;

    const float T = ImGui::GetTextLineHeight();
    const float P = gp.Style.LabelPadding.x;
    const float K = gp.Style.MinorTickLen.y;

    int   count_L = 0;
    int   count_R = 0;
    float last_L  = plot.AxesRect.Min.x;
    float last_R  = plot.AxesRect.Max.x;

    for (int i = IMPLOT_NUM_Y_AXES; i-- > 0;) { // FYI: can iterate forward
        ImPlotAxis& axis = plot.YAxis(i);
        if (!axis.Enabled)
            continue;
        const bool label = axis.HasLabel();
        const bool ticks = axis.HasTickLabels();
        const bool opp   = axis.IsOpposite();
        if (opp) {
            if (count_R++ > 0)
                pad_R += K + P;
            if (label)
                pad_R += T + P;
            if (ticks)
                pad_R += axis.Ticker.MaxSize.x + P;
            axis.Datum1 = plot.CanvasRect.Max.x - pad_R;
            axis.Datum2 = last_R;
            last_R = axis.Datum1;
        }
        else {
            if (count_L++ > 0)
                pad_L += K + P;
            if (label)
                pad_L += T + P;
            if (ticks)
                pad_L += axis.Ticker.MaxSize.x + P;
            axis.Datum1 = plot.CanvasRect.Min.x + pad_L;
            axis.Datum2 = last_L;
            last_L = axis.Datum1;
        }
    }

    plot.PlotRect.Min.x = plot.CanvasRect.Min.x + pad_L;
    plot.PlotRect.Max.x = plot.CanvasRect.Max.x - pad_R;

    if (align) {
        count_L = count_R = 0;
        float delta_L, delta_R;
        align->Update(pad_L,pad_R,delta_L,delta_R);
        for (int i = IMPLOT_NUM_Y_AXES; i-- > 0;) {
            ImPlotAxis& axis = plot.YAxis(i);
            if (!axis.Enabled)
                continue;
            if (axis.IsOpposite()) {
                axis.Datum1 -= delta_R;
                axis.Datum2 -= count_R++ > 1 ? delta_R : 0;
            }
            else {
                axis.Datum1 += delta_L;
                axis.Datum2 += count_L++ > 1 ? delta_L : 0;
            }
        }
    }
}

//-----------------------------------------------------------------------------
// RENDERING
//-----------------------------------------------------------------------------

static inline void RenderGridLinesX(ImDrawList& DrawList, const ImPlotTicker& ticker, const ImRect& rect, ImU32 col_maj, ImU32 col_min, float size_maj, float size_min) {
    const float density   = ticker.TickCount() / rect.GetWidth();
    ImVec4 col_min4  = ImGui::ColorConvertU32ToFloat4(col_min);
    col_min4.w      *= ImClamp(ImRemap(density, 0.1f, 0.2f, 1.0f, 0.0f), 0.0f, 1.0f);
    col_min = ImGui::ColorConvertFloat4ToU32(col_min4);
    for (int t = 0; t < ticker.TickCount(); t++) {
        const ImPlotTick& xt = ticker.Ticks[t];
        if (xt.PixelPos < rect.Min.x || xt.PixelPos > rect.Max.x)
            continue;
        if (xt.Level == 0) {
            if (xt.Major)
                DrawList.AddLine(ImVec2(xt.PixelPos, rect.Min.y), ImVec2(xt.PixelPos, rect.Max.y), col_maj, size_maj);
            else if (density < 0.2f)
                DrawList.AddLine(ImVec2(xt.PixelPos, rect.Min.y), ImVec2(xt.PixelPos, rect.Max.y), col_min, size_min);
        }
    }
}

static inline void RenderGridLinesY(ImDrawList& DrawList, const ImPlotTicker& ticker, const ImRect& rect, ImU32 col_maj, ImU32 col_min, float size_maj, float size_min) {
    const float density   = ticker.TickCount() / rect.GetHeight();
    ImVec4 col_min4  = ImGui::ColorConvertU32ToFloat4(col_min);
    col_min4.w      *= ImClamp(ImRemap(density, 0.1f, 0.2f, 1.0f, 0.0f), 0.0f, 1.0f);
    col_min = ImGui::ColorConvertFloat4ToU32(col_min4);
    for (int t = 0; t < ticker.TickCount(); t++) {
        const ImPlotTick& yt = ticker.Ticks[t];
        if (yt.PixelPos < rect.Min.y || yt.PixelPos > rect.Max.y)
            continue;
        if (yt.Major)
            DrawList.AddLine(ImVec2(rect.Min.x, yt.PixelPos), ImVec2(rect.Max.x, yt.PixelPos), col_maj, size_maj);
        else if (density < 0.2f)
            DrawList.AddLine(ImVec2(rect.Min.x, yt.PixelPos), ImVec2(rect.Max.x, yt.PixelPos), col_min, size_min);
    }
}

static inline void RenderSelectionRect(ImDrawList& DrawList, const ImVec2& p_min, const ImVec2& p_max, const ImVec4& col) {
    const ImU32 col_bg = ImGui::GetColorU32(col * ImVec4(1,1,1,0.25f));
    const ImU32 col_bd = ImGui::GetColorU32(col);
    DrawList.AddRectFilled(p_min, p_max, col_bg);
    DrawList.AddRect(p_min, p_max, col_bd);
}

//-----------------------------------------------------------------------------
// Input Handling
//-----------------------------------------------------------------------------

static const float MOUSE_CURSOR_DRAG_THRESHOLD = 5.0f;
static const float BOX_SELECT_DRAG_THRESHOLD   = 4.0f;

bool UpdateInput(ImPlotPlot& plot) {

    bool changed = false;

    ImPlotContext& gp = *GImPlot;
    ImGuiIO& IO = ImGui::GetIO();

    // BUTTON STATE -----------------------------------------------------------

    const ImGuiButtonFlags plot_button_flags = ImGuiButtonFlags_AllowOverlap
                                             | ImGuiButtonFlags_PressedOnClick
                                             | ImGuiButtonFlags_PressedOnDoubleClick
                                             | ImGuiButtonFlags_MouseButtonLeft
                                             | ImGuiButtonFlags_MouseButtonRight
                                             | ImGuiButtonFlags_MouseButtonMiddle;
    const ImGuiButtonFlags axis_button_flags = ImGuiButtonFlags_FlattenChildren
                                             | plot_button_flags;

    const bool plot_clicked = ImGui::ButtonBehavior(plot.PlotRect,plot.ID,&plot.Hovered,&plot.Held,plot_button_flags);
#if (IMGUI_VERSION_NUM < 18966)
    ImGui::SetItemAllowOverlap(); // Handled by ButtonBehavior()
#endif

    if (plot_clicked) {
        if (!ImHasFlag(plot.Flags, ImPlotFlags_NoBoxSelect) && IO.MouseClicked[gp.InputMap.Select] && ImHasFlag(IO.KeyMods, gp.InputMap.SelectMod)) {
            plot.Selecting   = true;
            plot.SelectStart = IO.MousePos;
            plot.SelectRect  = ImRect(0,0,0,0);
        }
        if (IO.MouseDoubleClicked[gp.InputMap.Fit]) {
            plot.FitThisFrame = true;
            for (int i = 0; i < ImAxis_COUNT; ++i)
                plot.Axes[i].FitThisFrame = true;
        }
    }

    const bool can_pan = IO.MouseDown[gp.InputMap.Pan] && ImHasFlag(IO.KeyMods, gp.InputMap.PanMod);

    plot.Held = plot.Held && can_pan;

    bool x_click[IMPLOT_NUM_X_AXES] = {false};
    bool x_held[IMPLOT_NUM_X_AXES]  = {false};
    bool x_hov[IMPLOT_NUM_X_AXES]   = {false};

    bool y_click[IMPLOT_NUM_Y_AXES] = {false};
    bool y_held[IMPLOT_NUM_Y_AXES]  = {false};
    bool y_hov[IMPLOT_NUM_Y_AXES]   = {false};

    for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {
        ImPlotAxis& xax = plot.XAxis(i);
        if (xax.Enabled) {
            ImGui::KeepAliveID(xax.ID);
            x_click[i]  = ImGui::ButtonBehavior(xax.HoverRect,xax.ID,&xax.Hovered,&xax.Held,axis_button_flags);
            if (x_click[i] && IO.MouseDoubleClicked[gp.InputMap.Fit])
                plot.FitThisFrame = xax.FitThisFrame = true;
            xax.Held  = xax.Held && can_pan;
            x_hov[i]  = xax.Hovered || plot.Hovered;
            x_held[i] = xax.Held    || plot.Held;
        }
    }

    for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {
        ImPlotAxis& yax = plot.YAxis(i);
        if (yax.Enabled) {
            ImGui::KeepAliveID(yax.ID);
            y_click[i]  = ImGui::ButtonBehavior(yax.HoverRect,yax.ID,&yax.Hovered,&yax.Held,axis_button_flags);
            if (y_click[i] && IO.MouseDoubleClicked[gp.InputMap.Fit])
                plot.FitThisFrame = yax.FitThisFrame = true;
            yax.Held  = yax.Held && can_pan;
            y_hov[i]  = yax.Hovered || plot.Hovered;
            y_held[i] = yax.Held    || plot.Held;
        }
    }

    // cancel due to DND activity
    if (GImGui->DragDropActive || (IO.KeyMods == gp.InputMap.OverrideMod && gp.InputMap.OverrideMod != 0))
        return false;

    // STATE -------------------------------------------------------------------

    const bool axis_equal      = ImHasFlag(plot.Flags, ImPlotFlags_Equal);

    const bool any_x_hov       = plot.Hovered || AnyAxesHovered(&plot.Axes[ImAxis_X1], IMPLOT_NUM_X_AXES);
    const bool any_x_held      = plot.Held    || AnyAxesHeld(&plot.Axes[ImAxis_X1], IMPLOT_NUM_X_AXES);
    const bool any_y_hov       = plot.Hovered || AnyAxesHovered(&plot.Axes[ImAxis_Y1], IMPLOT_NUM_Y_AXES);
    const bool any_y_held      = plot.Held    || AnyAxesHeld(&plot.Axes[ImAxis_Y1], IMPLOT_NUM_Y_AXES);
    const bool any_hov         = any_x_hov    || any_y_hov;
    const bool any_held        = any_x_held   || any_y_held;

    const ImVec2 select_drag   = ImGui::GetMouseDragDelta(gp.InputMap.Select);
    const ImVec2 pan_drag      = ImGui::GetMouseDragDelta(gp.InputMap.Pan);
    const float select_drag_sq = ImLengthSqr(select_drag);
    const float pan_drag_sq    = ImLengthSqr(pan_drag);
    const bool selecting       = plot.Selecting && select_drag_sq > MOUSE_CURSOR_DRAG_THRESHOLD;
    const bool panning         = any_held       && pan_drag_sq    > MOUSE_CURSOR_DRAG_THRESHOLD;

    // CONTEXT MENU -----------------------------------------------------------

    if (IO.MouseReleased[gp.InputMap.Menu] && !plot.ContextLocked)
        gp.OpenContextThisFrame = true;

    if (selecting || panning)
        plot.ContextLocked = true;
    else if (!(IO.MouseDown[gp.InputMap.Menu] || IO.MouseReleased[gp.InputMap.Menu]))
        plot.ContextLocked = false;

    // DRAG INPUT -------------------------------------------------------------

    if (any_held && !plot.Selecting) {
        int drag_direction = 0;
        for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
            ImPlotAxis& x_axis = plot.XAxis(i);
            if (x_held[i] && !x_axis.IsInputLocked()) {
                drag_direction |= (1 << 1);
                bool increasing = x_axis.IsInverted() ? IO.MouseDelta.x > 0 : IO.MouseDelta.x < 0;
                if (IO.MouseDelta.x != 0 && !x_axis.IsPanLocked(increasing)) {
                    const double plot_l = x_axis.PixelsToPlot(plot.PlotRect.Min.x - IO.MouseDelta.x);
                    const double plot_r = x_axis.PixelsToPlot(plot.PlotRect.Max.x - IO.MouseDelta.x);
                    x_axis.SetMin(x_axis.IsInverted() ? plot_r : plot_l);
                    x_axis.SetMax(x_axis.IsInverted() ? plot_l : plot_r);
                    if (axis_equal && x_axis.OrthoAxis != nullptr)
                        x_axis.OrthoAxis->SetAspect(x_axis.GetAspect());
                    changed = true;
                }
            }
        }
        for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
            ImPlotAxis& y_axis = plot.YAxis(i);
            if (y_held[i] && !y_axis.IsInputLocked()) {
                drag_direction |= (1 << 2);
                bool increasing = y_axis.IsInverted() ? IO.MouseDelta.y < 0 : IO.MouseDelta.y > 0;
                if (IO.MouseDelta.y != 0 && !y_axis.IsPanLocked(increasing)) {
                    const double plot_t = y_axis.PixelsToPlot(plot.PlotRect.Min.y - IO.MouseDelta.y);
                    const double plot_b = y_axis.PixelsToPlot(plot.PlotRect.Max.y - IO.MouseDelta.y);
                    y_axis.SetMin(y_axis.IsInverted() ? plot_t : plot_b);
                    y_axis.SetMax(y_axis.IsInverted() ? plot_b : plot_t);
                    if (axis_equal && y_axis.OrthoAxis != nullptr)
                        y_axis.OrthoAxis->SetAspect(y_axis.GetAspect());
                    changed = true;
                }
            }
        }
        if (IO.MouseDragMaxDistanceSqr[gp.InputMap.Pan] > MOUSE_CURSOR_DRAG_THRESHOLD) {
            switch (drag_direction) {
                case 0        : ImGui::SetMouseCursor(ImGuiMouseCursor_NotAllowed); break;
                case (1 << 1) : ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);   break;
                case (1 << 2) : ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS);   break;
                default       : ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeAll);  break;
            }
        }
    }

    // SCROLL INPUT -----------------------------------------------------------

    if (any_hov && ImHasFlag(IO.KeyMods, gp.InputMap.ZoomMod)) {

        float zoom_rate = gp.InputMap.ZoomRate;
        if (IO.MouseWheel == 0.0f)
            zoom_rate = 0;
        else if (IO.MouseWheel > 0)
            zoom_rate = (-zoom_rate) / (1.0f + (2.0f * zoom_rate));
        ImVec2 rect_size = plot.PlotRect.GetSize();
        float tx = ImRemap(IO.MousePos.x, plot.PlotRect.Min.x, plot.PlotRect.Max.x, 0.0f, 1.0f);
        float ty = ImRemap(IO.MousePos.y, plot.PlotRect.Min.y, plot.PlotRect.Max.y, 0.0f, 1.0f);

        for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
            ImPlotAxis& x_axis = plot.XAxis(i);
            const bool equal_zoom   = axis_equal && x_axis.OrthoAxis != nullptr;
            const bool equal_locked = (equal_zoom != false) && x_axis.OrthoAxis->IsInputLocked();
            if (x_hov[i] && !x_axis.IsInputLocked() && !equal_locked) {
                ImGui::SetKeyOwner(ImGuiKey_MouseWheelY, plot.ID);
                if (zoom_rate != 0.0f) {
                    float correction = (plot.Hovered && equal_zoom) ? 0.5f : 1.0f;
                    const double plot_l = x_axis.PixelsToPlot(plot.PlotRect.Min.x - rect_size.x * tx * zoom_rate * correction);
                    const double plot_r = x_axis.PixelsToPlot(plot.PlotRect.Max.x + rect_size.x * (1 - tx) * zoom_rate * correction);
                    x_axis.SetMin(x_axis.IsInverted() ? plot_r : plot_l);
                    x_axis.SetMax(x_axis.IsInverted() ? plot_l : plot_r);
                    if (axis_equal && x_axis.OrthoAxis != nullptr)
                        x_axis.OrthoAxis->SetAspect(x_axis.GetAspect());
                    changed = true;
                }
            }
        }
        for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
            ImPlotAxis& y_axis = plot.YAxis(i);
            const bool equal_zoom   = axis_equal && y_axis.OrthoAxis != nullptr;
            const bool equal_locked = equal_zoom && y_axis.OrthoAxis->IsInputLocked();
            if (y_hov[i] && !y_axis.IsInputLocked() && !equal_locked) {
                ImGui::SetKeyOwner(ImGuiKey_MouseWheelY, plot.ID);
                if (zoom_rate != 0.0f) {
                    float correction = (plot.Hovered && equal_zoom) ? 0.5f : 1.0f;
                    const double plot_t = y_axis.PixelsToPlot(plot.PlotRect.Min.y - rect_size.y * ty * zoom_rate * correction);
                    const double plot_b = y_axis.PixelsToPlot(plot.PlotRect.Max.y + rect_size.y * (1 - ty) * zoom_rate * correction);
                    y_axis.SetMin(y_axis.IsInverted() ? plot_t : plot_b);
                    y_axis.SetMax(y_axis.IsInverted() ? plot_b : plot_t);
                    if (axis_equal && y_axis.OrthoAxis != nullptr)
                        y_axis.OrthoAxis->SetAspect(y_axis.GetAspect());
                    changed = true;
                }
            }
        }
    }

    // BOX-SELECTION ----------------------------------------------------------

    if (plot.Selecting) {
        const ImVec2 d = plot.SelectStart - IO.MousePos;
        const bool x_can_change = !ImHasFlag(IO.KeyMods,gp.InputMap.SelectHorzMod) && ImFabs(d.x) > 2;
        const bool y_can_change = !ImHasFlag(IO.KeyMods,gp.InputMap.SelectVertMod) && ImFabs(d.y) > 2;
        // confirm
        if (IO.MouseReleased[gp.InputMap.Select]) {
            for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
                ImPlotAxis& x_axis = plot.XAxis(i);
                if (!x_axis.IsInputLocked() && x_can_change) {
                    const double p1 = x_axis.PixelsToPlot(plot.SelectStart.x);
                    const double p2 = x_axis.PixelsToPlot(IO.MousePos.x);
                    x_axis.SetMin(ImMin(p1, p2));
                    x_axis.SetMax(ImMax(p1, p2));
                    changed = true;
                }
            }
            for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
                ImPlotAxis& y_axis = plot.YAxis(i);
                if (!y_axis.IsInputLocked() && y_can_change) {
                    const double p1 = y_axis.PixelsToPlot(plot.SelectStart.y);
                    const double p2 = y_axis.PixelsToPlot(IO.MousePos.y);
                    y_axis.SetMin(ImMin(p1, p2));
                    y_axis.SetMax(ImMax(p1, p2));
                    changed = true;
                }
            }
            if (x_can_change || y_can_change || (ImHasFlag(IO.KeyMods,gp.InputMap.SelectHorzMod) && ImHasFlag(IO.KeyMods,gp.InputMap.SelectVertMod)))
                gp.OpenContextThisFrame = false;
            plot.Selected = plot.Selecting = false;
        }
        // cancel
        else if (IO.MouseReleased[gp.InputMap.SelectCancel]) {
            plot.Selected = plot.Selecting = false;
            gp.OpenContextThisFrame = false;
        }
        else if (ImLengthSqr(d) > BOX_SELECT_DRAG_THRESHOLD) {
            // bad selection
            if (plot.IsInputLocked()) {
                ImGui::SetMouseCursor(ImGuiMouseCursor_NotAllowed);
                gp.OpenContextThisFrame = false;
                plot.Selected      = false;
            }
            else {
                // TODO: Handle only min or max locked cases
                const bool full_width  = ImHasFlag(IO.KeyMods, gp.InputMap.SelectHorzMod) || AllAxesInputLocked(&plot.Axes[ImAxis_X1], IMPLOT_NUM_X_AXES);
                const bool full_height = ImHasFlag(IO.KeyMods, gp.InputMap.SelectVertMod) || AllAxesInputLocked(&plot.Axes[ImAxis_Y1], IMPLOT_NUM_Y_AXES);
                plot.SelectRect.Min.x = full_width  ? plot.PlotRect.Min.x : ImMin(plot.SelectStart.x, IO.MousePos.x);
                plot.SelectRect.Max.x = full_width  ? plot.PlotRect.Max.x : ImMax(plot.SelectStart.x, IO.MousePos.x);
                plot.SelectRect.Min.y = full_height ? plot.PlotRect.Min.y : ImMin(plot.SelectStart.y, IO.MousePos.y);
                plot.SelectRect.Max.y = full_height ? plot.PlotRect.Max.y : ImMax(plot.SelectStart.y, IO.MousePos.y);
                plot.SelectRect.Min  -= plot.PlotRect.Min;
                plot.SelectRect.Max  -= plot.PlotRect.Min;
                plot.Selected = true;
            }
        }
        else {
            plot.Selected = false;
        }
    }
    return changed;
}

//-----------------------------------------------------------------------------
// Next Plot Data (Legacy)
//-----------------------------------------------------------------------------

void ApplyNextPlotData(ImAxis idx) {
    ImPlotContext& gp = *GImPlot;
    ImPlotPlot& plot  = *gp.CurrentPlot;
    ImPlotAxis& axis  = plot.Axes[idx];
    if (!axis.Enabled)
        return;
    double*     npd_lmin = gp.NextPlotData.LinkedMin[idx];
    double*     npd_lmax = gp.NextPlotData.LinkedMax[idx];
    bool        npd_rngh = gp.NextPlotData.HasRange[idx];
    ImPlotCond  npd_rngc = gp.NextPlotData.RangeCond[idx];
    ImPlotRange     npd_rngv = gp.NextPlotData.Range[idx];
    axis.LinkedMin = npd_lmin;
    axis.LinkedMax = npd_lmax;
    axis.PullLinks();
    if (npd_rngh) {
        if (!plot.Initialized || npd_rngc == ImPlotCond_Always)
            axis.SetRange(npd_rngv);
    }
    axis.HasRange         = npd_rngh;
    axis.RangeCond        = npd_rngc;
}

//-----------------------------------------------------------------------------
// Setup
//-----------------------------------------------------------------------------

void SetupAxis(ImAxis idx, const char* label, ImPlotAxisFlags flags) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                         "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    // get plot and axis
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    // set ID
    axis.ID = plot.ID + idx + 1;
    // check and set flags
    if (plot.JustCreated || flags != axis.PreviousFlags)
        axis.Flags = flags;
    axis.PreviousFlags = flags;
    // enable axis
    axis.Enabled = true;
    // set label
    plot.SetAxisLabel(axis,label);
    // cache colors
    UpdateAxisColors(axis);
}

void SetupAxisLimits(ImAxis idx, double min_lim, double max_lim, ImPlotCond cond) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                         "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");    // get plot and axis
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    IM_ASSERT_USER_ERROR(axis.Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    if (!plot.Initialized || cond == ImPlotCond_Always)
        axis.SetRange(min_lim, max_lim);
    axis.HasRange  = true;
    axis.RangeCond = cond;
}

void SetupAxisFormat(ImAxis idx, const char* fmt) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                         "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    IM_ASSERT_USER_ERROR(axis.Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    axis.HasFormatSpec = fmt != nullptr;
    if (fmt != nullptr)
        ImStrncpy(axis.FormatSpec,fmt,sizeof(axis.FormatSpec));
}

void SetupAxisLinks(ImAxis idx, double* min_lnk, double* max_lnk) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                         "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    IM_ASSERT_USER_ERROR(axis.Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    axis.LinkedMin = min_lnk;
    axis.LinkedMax = max_lnk;
    axis.PullLinks();
}

void SetupAxisFormat(ImAxis idx, ImPlotFormatter formatter, void* data) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                         "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    IM_ASSERT_USER_ERROR(axis.Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    axis.Formatter = formatter;
    axis.FormatterData = data;
}

void SetupAxisTicks(ImAxis idx, const double* values, int n_ticks, const char* const labels[], bool show_default) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                        "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    IM_ASSERT_USER_ERROR(axis.Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    axis.ShowDefaultTicks = show_default;
    AddTicksCustom(values,
                  labels,
                  n_ticks,
                  axis.Ticker,
                  axis.Formatter ? axis.Formatter : Formatter_Default,
                  (axis.Formatter && axis.FormatterData) ? axis.FormatterData : axis.HasFormatSpec ? axis.FormatSpec : (void*)IMPLOT_LABEL_FORMAT);
}

void SetupAxisTicks(ImAxis idx, double v_min, double v_max, int n_ticks, const char* const labels[], bool show_default) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                         "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    n_ticks = n_ticks < 2 ? 2 : n_ticks;
    FillRange(gp.TempDouble1, n_ticks, v_min, v_max);
    SetupAxisTicks(idx, gp.TempDouble1.Data, n_ticks, labels, show_default);
}

void SetupAxisScale(ImAxis idx, ImPlotScale scale) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                        "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    IM_ASSERT_USER_ERROR(axis.Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    axis.Scale = scale;
    switch (scale)
    {
    case ImPlotScale_Time:
        axis.TransformForward = nullptr;
        axis.TransformInverse = nullptr;
        axis.TransformData    = nullptr;
        axis.Locator          = Locator_Time;
        axis.ConstraintRange  = ImPlotRange(IMPLOT_MIN_TIME, IMPLOT_MAX_TIME);
        axis.Ticker.Levels    = 2;
        break;
    case ImPlotScale_Log10:
        axis.TransformForward = TransformForward_Log10;
        axis.TransformInverse = TransformInverse_Log10;
        axis.TransformData    = nullptr;
        axis.Locator          = Locator_Log10;
        axis.ConstraintRange  = ImPlotRange(DBL_MIN, INFINITY);
        break;
    case ImPlotScale_SymLog:
        axis.TransformForward = TransformForward_SymLog;
        axis.TransformInverse = TransformInverse_SymLog;
        axis.TransformData    = nullptr;
        axis.Locator          = Locator_SymLog;
        axis.ConstraintRange  = ImPlotRange(-INFINITY, INFINITY);
        break;
    default:
        axis.TransformForward = nullptr;
        axis.TransformInverse = nullptr;
        axis.TransformData    = nullptr;
        axis.Locator          = nullptr;
        axis.ConstraintRange  = ImPlotRange(-INFINITY, INFINITY);
        break;
    }
}

void SetupAxisScale(ImAxis idx, ImPlotTransform fwd, ImPlotTransform inv, void* data) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                        "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    IM_ASSERT_USER_ERROR(axis.Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    axis.Scale = IMPLOT_AUTO;
    axis.TransformForward = fwd;
    axis.TransformInverse = inv;
    axis.TransformData = data;
}

void SetupAxisLimitsConstraints(ImAxis idx, double v_min, double v_max) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                        "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    IM_ASSERT_USER_ERROR(axis.Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    axis.ConstraintRange.Min = v_min;
    axis.ConstraintRange.Max = v_max;
}

void SetupAxisZoomConstraints(ImAxis idx, double z_min, double z_max) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                        "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& axis = plot.Axes[idx];
    IM_ASSERT_USER_ERROR(axis.Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    axis.ConstraintZoom.Min = z_min;
    axis.ConstraintZoom.Max = z_max;
}

void SetupAxes(const char* x_label, const char* y_label, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags) {
    SetupAxis(ImAxis_X1, x_label, x_flags);
    SetupAxis(ImAxis_Y1, y_label, y_flags);
}

void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond) {
    SetupAxisLimits(ImAxis_X1, x_min, x_max, cond);
    SetupAxisLimits(ImAxis_Y1, y_min, y_max, cond);
}

void SetupLegend(ImPlotLocation location, ImPlotLegendFlags flags) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR((gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked) || (gp.CurrentSubplot != nullptr && gp.CurrentPlot == nullptr),
                         "Setup needs to be called after BeginPlot or BeginSubplots and before any setup locking functions (e.g. PlotX)!");
    if (gp.CurrentItems) {
        ImPlotLegend& legend = gp.CurrentItems->Legend;
        // check and set location
        if (location != legend.PreviousLocation)
            legend.Location = location;
        legend.PreviousLocation = location;
        // check and set flags
        if (flags != legend.PreviousFlags)
            legend.Flags = flags;
        legend.PreviousFlags = flags;
    }
}

void SetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr && !gp.CurrentPlot->SetupLocked,
                         "Setup needs to be called after BeginPlot and before any setup locking functions (e.g. PlotX)!");
    gp.CurrentPlot->MouseTextLocation = location;
    gp.CurrentPlot->MouseTextFlags = flags;
}

//-----------------------------------------------------------------------------
// SetNext
//-----------------------------------------------------------------------------

void SetNextAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot == nullptr, "SetNextAxisLimits() needs to be called before BeginPlot()!");
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    gp.NextPlotData.HasRange[axis]  = true;
    gp.NextPlotData.RangeCond[axis] = cond;
    gp.NextPlotData.Range[axis].Min = v_min;
    gp.NextPlotData.Range[axis].Max = v_max;
}

void SetNextAxisLinks(ImAxis axis, double* link_min, double* link_max) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot == nullptr, "SetNextAxisLinks() needs to be called before BeginPlot()!");
    gp.NextPlotData.LinkedMin[axis] = link_min;
    gp.NextPlotData.LinkedMax[axis] = link_max;
}

void SetNextAxisToFit(ImAxis axis) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot == nullptr, "SetNextAxisToFit() needs to be called before BeginPlot()!");
    gp.NextPlotData.Fit[axis] = true;
}

void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond) {
    SetNextAxisLimits(ImAxis_X1, x_min, x_max, cond);
    SetNextAxisLimits(ImAxis_Y1, y_min, y_max, cond);
}

void SetNextAxesToFit() {
    for (int i = 0; i < ImAxis_COUNT; ++i)
        SetNextAxisToFit(i);
}

//-----------------------------------------------------------------------------
// BeginPlot
//-----------------------------------------------------------------------------

bool BeginPlot(const char* title_id, const ImVec2& size, ImPlotFlags flags) {
    IM_ASSERT_USER_ERROR(GImPlot != nullptr, "No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?");
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot == nullptr, "Mismatched BeginPlot()/EndPlot()!");

    // FRONT MATTER -----------------------------------------------------------

    if (gp.CurrentSubplot != nullptr)
        ImGui::PushID(gp.CurrentSubplot->CurrentIdx);

    // get globals
    ImGuiContext &G          = *GImGui;
    ImGuiWindow* Window      = G.CurrentWindow;

    // skip if needed
    if (Window->SkipItems && !gp.CurrentSubplot) {
        ResetCtxForNextPlot(GImPlot);
        return false;
    }

    // ID and age (TODO: keep track of plot age in frames)
    const ImGuiID ID         = Window->GetID(title_id);
    const bool just_created  = gp.Plots.GetByKey(ID) == nullptr;
    gp.CurrentPlot           = gp.Plots.GetOrAddByKey(ID);

    ImPlotPlot &plot         = *gp.CurrentPlot;
    plot.ID                  = ID;
    plot.Items.ID            = ID - 1;
    plot.JustCreated         = just_created;
    plot.SetupLocked         = false;

    // check flags
    if (plot.JustCreated)
        plot.Flags = flags;
    else if (flags != plot.PreviousFlags)
        plot.Flags = flags;
    plot.PreviousFlags = flags;

    // setup default axes
    if (plot.JustCreated) {
        SetupAxis(ImAxis_X1);
        SetupAxis(ImAxis_Y1);
    }

    // reset axes
    for (int i = 0; i < ImAxis_COUNT; ++i) {
        plot.Axes[i].Reset();
        UpdateAxisColors(plot.Axes[i]);
    }
    // ensure first axes enabled
    plot.Axes[ImAxis_X1].Enabled = true;
    plot.Axes[ImAxis_Y1].Enabled = true;
    // set initial axes
    plot.CurrentX = ImAxis_X1;
    plot.CurrentY = ImAxis_Y1;

    // process next plot data (legacy)
    for (int i = 0; i < ImAxis_COUNT; ++i)
        ApplyNextPlotData(i);

    // clear text buffers
    plot.ClearTextBuffer();
    plot.SetTitle(title_id);

    // set frame size
    ImVec2 frame_size;
    if (gp.CurrentSubplot != nullptr)
        frame_size = gp.CurrentSubplot->CellSize;
    else
        frame_size = ImGui::CalcItemSize(size, gp.Style.PlotDefaultSize.x, gp.Style.PlotDefaultSize.y);

    if (frame_size.x < gp.Style.PlotMinSize.x && (size.x < 0.0f || gp.CurrentSubplot != nullptr))
        frame_size.x = gp.Style.PlotMinSize.x;
    if (frame_size.y < gp.Style.PlotMinSize.y && (size.y < 0.0f || gp.CurrentSubplot != nullptr))
        frame_size.y = gp.Style.PlotMinSize.y;

    plot.FrameRect = ImRect(Window->DC.CursorPos, Window->DC.CursorPos + frame_size);
    ImGui::ItemSize(plot.FrameRect);
    if (!ImGui::ItemAdd(plot.FrameRect, plot.ID, &plot.FrameRect) && !gp.CurrentSubplot) {
        ResetCtxForNextPlot(GImPlot);
        return false;
    }

    // setup items (or dont)
    if (gp.CurrentItems == nullptr)
        gp.CurrentItems = &plot.Items;

    return true;
}

//-----------------------------------------------------------------------------
// SetupFinish
//-----------------------------------------------------------------------------

void SetupFinish() {
    IM_ASSERT_USER_ERROR(GImPlot != nullptr, "No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?");
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "SetupFinish needs to be called after BeginPlot!");

    ImGuiContext& G         = *GImGui;
    ImDrawList& DrawList    = *G.CurrentWindow->DrawList;
    const ImGuiStyle& Style = G.Style;

    ImPlotPlot &plot  = *gp.CurrentPlot;

    // lock setup
    plot.SetupLocked = true;

    // finalize axes and set default formatter/locator
    for (int i = 0; i < ImAxis_COUNT; ++i) {
        ImPlotAxis& axis = plot.Axes[i];
        if (axis.Enabled) {
            axis.Constrain();
            if (!plot.Initialized && axis.CanInitFit())
                plot.FitThisFrame = axis.FitThisFrame = true;
        }
        if (axis.Formatter == nullptr) {
            axis.Formatter = Formatter_Default;
            if (axis.HasFormatSpec)
                axis.FormatterData = axis.FormatSpec;
            else
                axis.FormatterData = (void*)IMPLOT_LABEL_FORMAT;
        }
        if (axis.Locator == nullptr) {
            axis.Locator = Locator_Default;
        }
    }

    // setup nullptr orthogonal axes
    const bool axis_equal = ImHasFlag(plot.Flags, ImPlotFlags_Equal);
    for (int ix = ImAxis_X1, iy = ImAxis_Y1; ix < ImAxis_Y1 || iy < ImAxis_COUNT; ++ix, ++iy) {
        ImPlotAxis& x_axis = plot.Axes[ix];
        ImPlotAxis& y_axis = plot.Axes[iy];
        if (x_axis.Enabled && y_axis.Enabled) {
            if (x_axis.OrthoAxis == nullptr)
                x_axis.OrthoAxis = &y_axis;
            if (y_axis.OrthoAxis == nullptr)
                y_axis.OrthoAxis = &x_axis;
        }
        else if (x_axis.Enabled)
        {
            if (x_axis.OrthoAxis == nullptr && !axis_equal)
                x_axis.OrthoAxis = &plot.Axes[ImAxis_Y1];
        }
        else if (y_axis.Enabled) {
            if (y_axis.OrthoAxis == nullptr && !axis_equal)
                y_axis.OrthoAxis = &plot.Axes[ImAxis_X1];
        }
    }

    // canvas/axes bb
    plot.CanvasRect = ImRect(plot.FrameRect.Min + gp.Style.PlotPadding, plot.FrameRect.Max - gp.Style.PlotPadding);
    plot.AxesRect   = plot.FrameRect;

    // outside legend adjustments
    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoLegend) && plot.Items.GetLegendCount() > 0 && ImHasFlag(plot.Items.Legend.Flags, ImPlotLegendFlags_Outside)) {
        ImPlotLegend& legend = plot.Items.Legend;
        const bool horz = ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal);
        const ImVec2 legend_size = CalcLegendSize(plot.Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !horz);
        const bool west = ImHasFlag(legend.Location, ImPlotLocation_West) && !ImHasFlag(legend.Location, ImPlotLocation_East);
        const bool east = ImHasFlag(legend.Location, ImPlotLocation_East) && !ImHasFlag(legend.Location, ImPlotLocation_West);
        const bool north = ImHasFlag(legend.Location, ImPlotLocation_North) && !ImHasFlag(legend.Location, ImPlotLocation_South);
        const bool south = ImHasFlag(legend.Location, ImPlotLocation_South) && !ImHasFlag(legend.Location, ImPlotLocation_North);
        if ((west && !horz) || (west && horz && !north && !south)) {
            plot.CanvasRect.Min.x += (legend_size.x + gp.Style.LegendPadding.x);
            plot.AxesRect.Min.x   += (legend_size.x + gp.Style.PlotPadding.x);
        }
        if ((east && !horz) || (east && horz && !north && !south)) {
            plot.CanvasRect.Max.x -= (legend_size.x + gp.Style.LegendPadding.x);
            plot.AxesRect.Max.x   -= (legend_size.x + gp.Style.PlotPadding.x);
        }
        if ((north && horz) || (north && !horz && !west && !east)) {
            plot.CanvasRect.Min.y += (legend_size.y + gp.Style.LegendPadding.y);
            plot.AxesRect.Min.y   += (legend_size.y + gp.Style.PlotPadding.y);
        }
        if ((south && horz) || (south && !horz && !west && !east)) {
            plot.CanvasRect.Max.y -= (legend_size.y + gp.Style.LegendPadding.y);
            plot.AxesRect.Max.y   -= (legend_size.y + gp.Style.PlotPadding.y);
        }
    }

    // plot bb
    float pad_top = 0, pad_bot = 0, pad_left = 0, pad_right = 0;

    // (0) calc top padding form title
    ImVec2 title_size(0.0f, 0.0f);
    if (plot.HasTitle())
         title_size = ImGui::CalcTextSize(plot.GetTitle(), nullptr, true);
    if (title_size.x > 0) {
        pad_top += title_size.y + gp.Style.LabelPadding.y;
        plot.AxesRect.Min.y += gp.Style.PlotPadding.y + pad_top;
    }

    // (1) calc addition top padding and bot padding
    PadAndDatumAxesX(plot,pad_top,pad_bot,gp.CurrentAlignmentH);

    const float plot_height = plot.CanvasRect.GetHeight() - pad_top - pad_bot;

    // (2) get y tick labels (needed for left/right pad)
    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
        ImPlotAxis& axis = plot.YAxis(i);
        if (axis.WillRender() && axis.ShowDefaultTicks && plot_height > 0) {
            axis.Locator(axis.Ticker, axis.Range, plot_height, true, axis.Formatter, axis.FormatterData);
        }
    }

    // (3) calc left/right pad
    PadAndDatumAxesY(plot,pad_left,pad_right,gp.CurrentAlignmentV);

    const float plot_width = plot.CanvasRect.GetWidth() - pad_left - pad_right;

    // (4) get x ticks
    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
        ImPlotAxis& axis = plot.XAxis(i);
        if (axis.WillRender() && axis.ShowDefaultTicks && plot_width > 0) {
            axis.Locator(axis.Ticker, axis.Range, plot_width, false, axis.Formatter, axis.FormatterData);
        }
    }

    // (5) calc plot bb
    plot.PlotRect = ImRect(plot.CanvasRect.Min + ImVec2(pad_left, pad_top), plot.CanvasRect.Max - ImVec2(pad_right, pad_bot));

    // HOVER------------------------------------------------------------

    // axes hover rect, pixel ranges
    for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {
        ImPlotAxis& xax = plot.XAxis(i);
        xax.HoverRect   = ImRect(ImVec2(plot.PlotRect.Min.x, ImMin(xax.Datum1,xax.Datum2)),
                                 ImVec2(plot.PlotRect.Max.x, ImMax(xax.Datum1,xax.Datum2)));
        xax.PixelMin    = xax.IsInverted() ? plot.PlotRect.Max.x : plot.PlotRect.Min.x;
        xax.PixelMax    = xax.IsInverted() ? plot.PlotRect.Min.x : plot.PlotRect.Max.x;
        xax.UpdateTransformCache();
    }

    for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {
        ImPlotAxis& yax = plot.YAxis(i);
        yax.HoverRect   = ImRect(ImVec2(ImMin(yax.Datum1,yax.Datum2),plot.PlotRect.Min.y),
                                 ImVec2(ImMax(yax.Datum1,yax.Datum2),plot.PlotRect.Max.y));
        yax.PixelMin    = yax.IsInverted() ? plot.PlotRect.Min.y : plot.PlotRect.Max.y;
        yax.PixelMax    = yax.IsInverted() ? plot.PlotRect.Max.y : plot.PlotRect.Min.y;
        yax.UpdateTransformCache();
    }
    // Equal axis constraint. Must happen after we set Pixels
    // constrain equal axes for primary x and y if not approximately equal
    // constrains x to y since x pixel size depends on y labels width, and causes feedback loops in opposite case
    if (axis_equal) {
        for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {
            ImPlotAxis& x_axis = plot.XAxis(i);
            if (x_axis.OrthoAxis == nullptr)
                continue;
            double xar = x_axis.GetAspect();
            double yar = x_axis.OrthoAxis->GetAspect();
            // edge case: user has set x range this frame, so fit y to x so that we honor their request for x range
            // NB: because of feedback across several frames, the user's x request may not be perfectly honored
            if (x_axis.HasRange)
                x_axis.OrthoAxis->SetAspect(xar);
            else if (!ImAlmostEqual(xar,yar) && !x_axis.OrthoAxis->IsInputLocked())
                 x_axis.SetAspect(yar);
        }
    }

    // INPUT ------------------------------------------------------------------
    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoInputs))
        UpdateInput(plot);

    // fit from FitNextPlotAxes or auto fit
    for (int i = 0; i < ImAxis_COUNT; ++i) {
        if (gp.NextPlotData.Fit[i] || plot.Axes[i].IsAutoFitting()) {
            plot.FitThisFrame = true;
            plot.Axes[i].FitThisFrame = true;
        }
    }

    // RENDER -----------------------------------------------------------------

    const float txt_height = ImGui::GetTextLineHeight();

    // render frame
    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoFrame))
        ImGui::RenderFrame(plot.FrameRect.Min, plot.FrameRect.Max, GetStyleColorU32(ImPlotCol_FrameBg), true, Style.FrameRounding);

    // grid bg
    DrawList.AddRectFilled(plot.PlotRect.Min, plot.PlotRect.Max, GetStyleColorU32(ImPlotCol_PlotBg));

    // transform ticks
    for (int i = 0; i < ImAxis_COUNT; i++) {
        ImPlotAxis& axis = plot.Axes[i];
        if (axis.WillRender()) {
            for (int t = 0; t < axis.Ticker.TickCount(); t++) {
                ImPlotTick& tk = axis.Ticker.Ticks[t];
                tk.PixelPos = IM_ROUND(axis.PlotToPixels(tk.PlotPos));
            }
        }
    }

    // render grid (background)
    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
        ImPlotAxis& x_axis = plot.XAxis(i);
        if (x_axis.Enabled && x_axis.HasGridLines() && !x_axis.IsForeground())
            RenderGridLinesX(DrawList, x_axis.Ticker, plot.PlotRect, x_axis.ColorMaj, x_axis.ColorMin, gp.Style.MajorGridSize.x, gp.Style.MinorGridSize.x);
    }
    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
        ImPlotAxis& y_axis = plot.YAxis(i);
        if (y_axis.Enabled && y_axis.HasGridLines() && !y_axis.IsForeground())
            RenderGridLinesY(DrawList, y_axis.Ticker, plot.PlotRect,  y_axis.ColorMaj, y_axis.ColorMin, gp.Style.MajorGridSize.y, gp.Style.MinorGridSize.y);
    }

    // render x axis button, label, tick labels
    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
        ImPlotAxis& ax = plot.XAxis(i);
        if (!ax.Enabled)
            continue;
        if ((ax.Hovered || ax.Held) && !plot.Held && !ImHasFlag(ax.Flags, ImPlotAxisFlags_NoHighlight))
            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.Held ? ax.ColorAct : ax.ColorHov);
        else if (ax.ColorHiLi != IM_COL32_BLACK_TRANS) {
            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.ColorHiLi);
            ax.ColorHiLi = IM_COL32_BLACK_TRANS;
        }
        else if (ax.ColorBg != IM_COL32_BLACK_TRANS) {
            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.ColorBg);
        }
        const ImPlotTicker& tkr = ax.Ticker;
        const bool opp = ax.IsOpposite();
        if (ax.HasLabel()) {
            const char* label        = plot.GetAxisLabel(ax);
            const ImVec2 label_size  = ImGui::CalcTextSize(label);
            const float label_offset = (ax.HasTickLabels() ? tkr.MaxSize.y + gp.Style.LabelPadding.y : 0.0f)
                                     + (tkr.Levels - 1) * (txt_height + gp.Style.LabelPadding.y)
                                     + gp.Style.LabelPadding.y;
            const ImVec2 label_pos(plot.PlotRect.GetCenter().x - label_size.x * 0.5f,
                                   opp ? ax.Datum1 - label_offset - label_size.y : ax.Datum1 + label_offset);
            DrawList.AddText(label_pos, ax.ColorTxt, label);
        }
        if (ax.HasTickLabels()) {
            for (int j = 0; j < tkr.TickCount(); ++j) {
                const ImPlotTick& tk = tkr.Ticks[j];
                const float datum = ax.Datum1 + (opp ? (-gp.Style.LabelPadding.y -txt_height -tk.Level * (txt_height + gp.Style.LabelPadding.y))
                                                     : gp.Style.LabelPadding.y + tk.Level * (txt_height + gp.Style.LabelPadding.y));
                if (tk.ShowLabel && tk.PixelPos >= plot.PlotRect.Min.x - 1 && tk.PixelPos <= plot.PlotRect.Max.x + 1) {
                    ImVec2 start(tk.PixelPos - 0.5f * tk.LabelSize.x, datum);
                    DrawList.AddText(start, ax.ColorTxt, tkr.GetText(j));
                }
            }
        }
    }

    // render y axis button, label, tick labels
    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
        ImPlotAxis& ax = plot.YAxis(i);
        if (!ax.Enabled)
            continue;
        if ((ax.Hovered || ax.Held) && !plot.Held && !ImHasFlag(ax.Flags, ImPlotAxisFlags_NoHighlight))
            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.Held ? ax.ColorAct : ax.ColorHov);
        else if (ax.ColorHiLi != IM_COL32_BLACK_TRANS) {
            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.ColorHiLi);
            ax.ColorHiLi = IM_COL32_BLACK_TRANS;
        }
        else if (ax.ColorBg != IM_COL32_BLACK_TRANS) {
            DrawList.AddRectFilled(ax.HoverRect.Min, ax.HoverRect.Max, ax.ColorBg);
        }
        const ImPlotTicker& tkr = ax.Ticker;
        const bool opp = ax.IsOpposite();
        if (ax.HasLabel()) {
            const char* label        = plot.GetAxisLabel(ax);
            const ImVec2 label_size  = CalcTextSizeVertical(label);
            const float label_offset = (ax.HasTickLabels() ? tkr.MaxSize.x + gp.Style.LabelPadding.x : 0.0f)
                                     + gp.Style.LabelPadding.x;
            const ImVec2 label_pos(opp ? ax.Datum1 + label_offset : ax.Datum1 - label_offset - label_size.x,
                                   plot.PlotRect.GetCenter().y + label_size.y * 0.5f);
            AddTextVertical(&DrawList, label_pos, ax.ColorTxt, label);
        }
        if (ax.HasTickLabels()) {
            for (int j = 0; j < tkr.TickCount(); ++j) {
                const ImPlotTick& tk = tkr.Ticks[j];
                const float datum = ax.Datum1 + (opp ? gp.Style.LabelPadding.x : (-gp.Style.LabelPadding.x - tk.LabelSize.x));
                if (tk.ShowLabel && tk.PixelPos >= plot.PlotRect.Min.y - 1 && tk.PixelPos <= plot.PlotRect.Max.y + 1) {
                    ImVec2 start(datum, tk.PixelPos - 0.5f * tk.LabelSize.y);
                    DrawList.AddText(start, ax.ColorTxt, tkr.GetText(j));
                }
            }
        }
    }


    // clear legend (TODO: put elsewhere)
    plot.Items.Legend.Reset();
    // push ID to set item hashes (NB: !!!THIS PROBABLY NEEDS TO BE IN BEGIN PLOT!!!!)
    ImGui::PushOverrideID(gp.CurrentItems->ID);
}

//-----------------------------------------------------------------------------
// EndPlot()
//-----------------------------------------------------------------------------

void EndPlot() {
    IM_ASSERT_USER_ERROR(GImPlot != nullptr, "No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?");
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "Mismatched BeginPlot()/EndPlot()!");

    SetupLock();

    ImGuiContext &G       = *GImGui;
    ImPlotPlot &plot      = *gp.CurrentPlot;
    ImGuiWindow * Window  = G.CurrentWindow;
    ImDrawList & DrawList = *Window->DrawList;
    const ImGuiIO &   IO  = ImGui::GetIO();

    // FINAL RENDER -----------------------------------------------------------

    const bool render_border  = gp.Style.PlotBorderSize > 0 && GetStyleColorVec4(ImPlotCol_PlotBorder).w > 0;
    const bool any_x_held = plot.Held    || AnyAxesHeld(&plot.Axes[ImAxis_X1], IMPLOT_NUM_X_AXES);
    const bool any_y_held = plot.Held    || AnyAxesHeld(&plot.Axes[ImAxis_Y1], IMPLOT_NUM_Y_AXES);

    ImGui::PushClipRect(plot.FrameRect.Min, plot.FrameRect.Max, true);

    // render grid (foreground)
    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
        ImPlotAxis& x_axis = plot.XAxis(i);
        if (x_axis.Enabled && x_axis.HasGridLines() && x_axis.IsForeground())
            RenderGridLinesX(DrawList, x_axis.Ticker, plot.PlotRect, x_axis.ColorMaj, x_axis.ColorMin, gp.Style.MajorGridSize.x, gp.Style.MinorGridSize.x);
    }
    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
        ImPlotAxis& y_axis = plot.YAxis(i);
        if (y_axis.Enabled && y_axis.HasGridLines() && y_axis.IsForeground())
            RenderGridLinesY(DrawList, y_axis.Ticker, plot.PlotRect,  y_axis.ColorMaj, y_axis.ColorMin, gp.Style.MajorGridSize.y, gp.Style.MinorGridSize.y);
    }


    // render title
    if (plot.HasTitle()) {
        ImU32 col = GetStyleColorU32(ImPlotCol_TitleText);
        AddTextCentered(&DrawList,ImVec2(plot.PlotRect.GetCenter().x, plot.CanvasRect.Min.y),col,plot.GetTitle());
    }

    // render x ticks
    int count_B = 0, count_T = 0;
    for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
        const ImPlotAxis& ax = plot.XAxis(i);
        if (!ax.Enabled)
            continue;
        const ImPlotTicker& tkr = ax.Ticker;
        const bool opp = ax.IsOpposite();
        const bool aux = ((opp && count_T > 0)||(!opp && count_B > 0));
        if (ax.HasTickMarks()) {
            const float direction = opp ? 1.0f : -1.0f;
            for (int j = 0; j < tkr.TickCount(); ++j) {
                const ImPlotTick& tk = tkr.Ticks[j];
                if (tk.Level != 0 || tk.PixelPos < plot.PlotRect.Min.x || tk.PixelPos > plot.PlotRect.Max.x)
                    continue;
                const ImVec2 start(tk.PixelPos, ax.Datum1);
                const float len = (!aux && tk.Major) ? gp.Style.MajorTickLen.x  : gp.Style.MinorTickLen.x;
                const float thk = (!aux && tk.Major) ? gp.Style.MajorTickSize.x : gp.Style.MinorTickSize.x;
                DrawList.AddLine(start, start + ImVec2(0,direction*len), ax.ColorTick, thk);
            }
            if (aux || !render_border)
                DrawList.AddLine(ImVec2(plot.PlotRect.Min.x,ax.Datum1), ImVec2(plot.PlotRect.Max.x,ax.Datum1), ax.ColorTick, gp.Style.MinorTickSize.x);
        }
        count_B += !opp;
        count_T +=  opp;
    }

    // render y ticks
    int count_L = 0, count_R = 0;
    for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
        const ImPlotAxis& ax = plot.YAxis(i);
        if (!ax.Enabled)
            continue;
        const ImPlotTicker& tkr = ax.Ticker;
        const bool opp = ax.IsOpposite();
        const bool aux = ((opp && count_R > 0)||(!opp && count_L > 0));
        if (ax.HasTickMarks()) {
            const float direction = opp ? -1.0f : 1.0f;
            for (int j = 0; j < tkr.TickCount(); ++j) {
                const ImPlotTick& tk = tkr.Ticks[j];
                if (tk.Level != 0 || tk.PixelPos < plot.PlotRect.Min.y || tk.PixelPos > plot.PlotRect.Max.y)
                    continue;
                const ImVec2 start(ax.Datum1, tk.PixelPos);
                const float len = (!aux && tk.Major) ? gp.Style.MajorTickLen.y  : gp.Style.MinorTickLen.y;
                const float thk = (!aux && tk.Major) ? gp.Style.MajorTickSize.y : gp.Style.MinorTickSize.y;
                DrawList.AddLine(start, start + ImVec2(direction*len,0), ax.ColorTick, thk);
            }
            if (aux || !render_border)
                DrawList.AddLine(ImVec2(ax.Datum1, plot.PlotRect.Min.y), ImVec2(ax.Datum1, plot.PlotRect.Max.y), ax.ColorTick, gp.Style.MinorTickSize.y);
        }
        count_L += !opp;
        count_R +=  opp;
    }
    ImGui::PopClipRect();

    // render annotations
    PushPlotClipRect();
    for (int i = 0; i < gp.Annotations.Size; ++i) {
        const char* txt       = gp.Annotations.GetText(i);
        ImPlotAnnotation& an  = gp.Annotations.Annotations[i];
        const ImVec2 txt_size = ImGui::CalcTextSize(txt);
        const ImVec2 size     = txt_size + gp.Style.AnnotationPadding * 2;
        ImVec2 pos            = an.Pos;
        if (an.Offset.x == 0)
            pos.x -= size.x / 2;
        else if (an.Offset.x > 0)
            pos.x += an.Offset.x;
        else
            pos.x -= size.x - an.Offset.x;
        if (an.Offset.y == 0)
            pos.y -= size.y / 2;
        else if (an.Offset.y > 0)
            pos.y += an.Offset.y;
        else
            pos.y -= size.y - an.Offset.y;
        if (an.Clamp)
            pos = ClampLabelPos(pos, size, plot.PlotRect.Min, plot.PlotRect.Max);
        ImRect rect(pos,pos+size);
        if (an.Offset.x != 0 || an.Offset.y != 0) {
            ImVec2 corners[4] = {rect.GetTL(), rect.GetTR(), rect.GetBR(), rect.GetBL()};
            int min_corner = 0;
            float min_len = FLT_MAX;
            for (int c = 0; c < 4; ++c) {
                float len = ImLengthSqr(an.Pos - corners[c]);
                if (len < min_len) {
                    min_corner = c;
                    min_len = len;
                }
            }
            DrawList.AddLine(an.Pos, corners[min_corner], an.ColorBg);
        }
        DrawList.AddRectFilled(rect.Min, rect.Max, an.ColorBg);
        DrawList.AddText(pos + gp.Style.AnnotationPadding, an.ColorFg, txt);
    }

    // render selection
    if (plot.Selected)
        RenderSelectionRect(DrawList, plot.SelectRect.Min + plot.PlotRect.Min, plot.SelectRect.Max + plot.PlotRect.Min, GetStyleColorVec4(ImPlotCol_Selection));

    // render crosshairs
    if (ImHasFlag(plot.Flags, ImPlotFlags_Crosshairs) && plot.Hovered && !(any_x_held || any_y_held) && !plot.Selecting && !plot.Items.Legend.Hovered) {
        ImGui::SetMouseCursor(ImGuiMouseCursor_None);
        ImVec2 xy = IO.MousePos;
        ImVec2 h1(plot.PlotRect.Min.x, xy.y);
        ImVec2 h2(xy.x - 5, xy.y);
        ImVec2 h3(xy.x + 5, xy.y);
        ImVec2 h4(plot.PlotRect.Max.x, xy.y);
        ImVec2 v1(xy.x, plot.PlotRect.Min.y);
        ImVec2 v2(xy.x, xy.y - 5);
        ImVec2 v3(xy.x, xy.y + 5);
        ImVec2 v4(xy.x, plot.PlotRect.Max.y);
        ImU32 col = GetStyleColorU32(ImPlotCol_Crosshairs);
        DrawList.AddLine(h1, h2, col);
        DrawList.AddLine(h3, h4, col);
        DrawList.AddLine(v1, v2, col);
        DrawList.AddLine(v3, v4, col);
    }

    // render mouse pos
    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoMouseText) && (plot.Hovered || ImHasFlag(plot.MouseTextFlags, ImPlotMouseTextFlags_ShowAlways))) {

        const bool no_aux = ImHasFlag(plot.MouseTextFlags, ImPlotMouseTextFlags_NoAuxAxes);
        const bool no_fmt = ImHasFlag(plot.MouseTextFlags, ImPlotMouseTextFlags_NoFormat);

        ImGuiTextBuffer& builder = gp.MousePosStringBuilder;
        builder.Buf.shrink(0);
        char buff[IMPLOT_LABEL_MAX_SIZE];

        const int num_x = no_aux ? 1 : IMPLOT_NUM_X_AXES;
        for (int i = 0; i < num_x; ++i) {
            ImPlotAxis& x_axis = plot.XAxis(i);
            if (!x_axis.Enabled)
                continue;
            if (i > 0)
                builder.append(", (");
            double v = x_axis.PixelsToPlot(IO.MousePos.x);
            if (no_fmt)
                Formatter_Default(v,buff,IMPLOT_LABEL_MAX_SIZE,(void*)IMPLOT_LABEL_FORMAT);
            else
                LabelAxisValue(x_axis,v,buff,IMPLOT_LABEL_MAX_SIZE,true);
            builder.append(buff);
            if (i > 0)
                builder.append(")");
        }
        builder.append(", ");
        const int num_y = no_aux ? 1 : IMPLOT_NUM_Y_AXES;
        for (int i = 0; i < num_y; ++i) {
            ImPlotAxis& y_axis = plot.YAxis(i);
            if (!y_axis.Enabled)
                continue;
            if (i > 0)
                builder.append(", (");
            double v = y_axis.PixelsToPlot(IO.MousePos.y);
            if (no_fmt)
                Formatter_Default(v,buff,IMPLOT_LABEL_MAX_SIZE,(void*)IMPLOT_LABEL_FORMAT);
            else
                LabelAxisValue(y_axis,v,buff,IMPLOT_LABEL_MAX_SIZE,true);
            builder.append(buff);
            if (i > 0)
                builder.append(")");
        }

        if (!builder.empty()) {
            const ImVec2 size = ImGui::CalcTextSize(builder.c_str());
            const ImVec2 pos = GetLocationPos(plot.PlotRect, size, plot.MouseTextLocation, gp.Style.MousePosPadding);
            DrawList.AddText(pos, GetStyleColorU32(ImPlotCol_InlayText), builder.c_str());
        }
    }
    PopPlotClipRect();

    // axis side switch
    if (!plot.Held) {
        ImVec2 mouse_pos = ImGui::GetIO().MousePos;
        ImRect trigger_rect = plot.PlotRect;
        trigger_rect.Expand(-10);
        for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {
            ImPlotAxis& x_axis = plot.XAxis(i);
            if (ImHasFlag(x_axis.Flags, ImPlotAxisFlags_NoSideSwitch))
                continue;
            if (x_axis.Held && plot.PlotRect.Contains(mouse_pos)) {
                const bool opp = ImHasFlag(x_axis.Flags, ImPlotAxisFlags_Opposite);
                if (!opp) {
                    ImRect rect(plot.PlotRect.Min.x - 5, plot.PlotRect.Min.y - 5,
                                plot.PlotRect.Max.x + 5, plot.PlotRect.Min.y + 5);
                    if (mouse_pos.y < plot.PlotRect.Max.y - 10)
                        DrawList.AddRectFilled(rect.Min, rect.Max, x_axis.ColorHov);
                    if (rect.Contains(mouse_pos))
                        x_axis.Flags |= ImPlotAxisFlags_Opposite;
                }
                else {
                    ImRect rect(plot.PlotRect.Min.x - 5, plot.PlotRect.Max.y - 5,
                                plot.PlotRect.Max.x + 5, plot.PlotRect.Max.y + 5);
                    if (mouse_pos.y > plot.PlotRect.Min.y + 10)
                        DrawList.AddRectFilled(rect.Min, rect.Max, x_axis.ColorHov);
                    if (rect.Contains(mouse_pos))
                        x_axis.Flags &= ~ImPlotAxisFlags_Opposite;
                }
            }
        }
        for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {
            ImPlotAxis& y_axis = plot.YAxis(i);
            if (ImHasFlag(y_axis.Flags, ImPlotAxisFlags_NoSideSwitch))
                continue;
            if (y_axis.Held && plot.PlotRect.Contains(mouse_pos)) {
                const bool opp = ImHasFlag(y_axis.Flags, ImPlotAxisFlags_Opposite);
                if (!opp) {
                    ImRect rect(plot.PlotRect.Max.x - 5, plot.PlotRect.Min.y - 5,
                                plot.PlotRect.Max.x + 5, plot.PlotRect.Max.y + 5);
                    if (mouse_pos.x > plot.PlotRect.Min.x + 10)
                        DrawList.AddRectFilled(rect.Min, rect.Max, y_axis.ColorHov);
                    if (rect.Contains(mouse_pos))
                        y_axis.Flags |= ImPlotAxisFlags_Opposite;
                }
                else {
                    ImRect rect(plot.PlotRect.Min.x - 5, plot.PlotRect.Min.y - 5,
                                plot.PlotRect.Min.x + 5, plot.PlotRect.Max.y + 5);
                    if (mouse_pos.x < plot.PlotRect.Max.x - 10)
                        DrawList.AddRectFilled(rect.Min, rect.Max, y_axis.ColorHov);
                    if (rect.Contains(mouse_pos))
                        y_axis.Flags &= ~ImPlotAxisFlags_Opposite;
                }
            }
        }
    }

    // reset legend hovers
    plot.Items.Legend.Hovered = false;
    for (int i = 0; i < plot.Items.GetItemCount(); ++i)
        plot.Items.GetItemByIndex(i)->LegendHovered = false;
    // render legend
    if (!ImHasFlag(plot.Flags, ImPlotFlags_NoLegend) && plot.Items.GetLegendCount() > 0) {
        ImPlotLegend& legend = plot.Items.Legend;
        const bool   legend_out  = ImHasFlag(legend.Flags, ImPlotLegendFlags_Outside);
        const bool   legend_horz = ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal);
        const ImVec2 legend_size = CalcLegendSize(plot.Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !legend_horz);
        const ImVec2 legend_pos  = GetLocationPos(legend_out ? plot.FrameRect : plot.PlotRect,
                                                  legend_size,
                                                  legend.Location,
                                                  legend_out ? gp.Style.PlotPadding : gp.Style.LegendPadding);
        legend.Rect = ImRect(legend_pos, legend_pos + legend_size);
        legend.RectClamped = legend.Rect;
        const bool legend_scrollable = ClampLegendRect(legend.RectClamped,
                                                        legend_out ? plot.FrameRect : plot.PlotRect,
                                                        legend_out ? gp.Style.PlotPadding : gp.Style.LegendPadding
                                                        );
        const ImGuiButtonFlags legend_button_flags = ImGuiButtonFlags_AllowOverlap
                                                    | ImGuiButtonFlags_PressedOnClick
                                                    | ImGuiButtonFlags_PressedOnDoubleClick
                                                    | ImGuiButtonFlags_MouseButtonLeft
                                                    | ImGuiButtonFlags_MouseButtonRight
                                                    | ImGuiButtonFlags_MouseButtonMiddle
                                                    | ImGuiButtonFlags_FlattenChildren;
        ImGui::KeepAliveID(plot.Items.ID);
        ImGui::ButtonBehavior(legend.RectClamped, plot.Items.ID, &legend.Hovered, &legend.Held, legend_button_flags);
        legend.Hovered = legend.Hovered || (ImGui::IsWindowHovered() && legend.RectClamped.Contains(IO.MousePos));

        if (legend_scrollable) {
            if (legend.Hovered) {
                ImGui::SetKeyOwner(ImGuiKey_MouseWheelY, plot.Items.ID);
                if (IO.MouseWheel != 0.0f) {
                    ImVec2 max_step = legend.Rect.GetSize() * 0.67f;
#if IMGUI_VERSION_NUM < 19172
                    float font_size = ImGui::GetCurrentWindow()->CalcFontSize();
#else
                    float font_size = ImGui::GetCurrentWindow()->FontRefSize;
#endif
                    float scroll_step = ImFloor(ImMin(2 * font_size, max_step.x));
                    legend.Scroll.x += scroll_step * IO.MouseWheel;
                    legend.Scroll.y += scroll_step * IO.MouseWheel;
                }
            }
            const ImVec2 min_scroll_offset = legend.RectClamped.GetSize() - legend.Rect.GetSize();
            legend.Scroll.x = ImClamp(legend.Scroll.x, min_scroll_offset.x, 0.0f);
            legend.Scroll.y = ImClamp(legend.Scroll.y, min_scroll_offset.y, 0.0f);
            const ImVec2 scroll_offset = legend_horz ? ImVec2(legend.Scroll.x, 0) : ImVec2(0, legend.Scroll.y);
            ImVec2 legend_offset = legend.RectClamped.Min - legend.Rect.Min + scroll_offset;
            legend.Rect.Min += legend_offset;
            legend.Rect.Max += legend_offset;
        } else {
            legend.Scroll = ImVec2(0,0);
        }

        const ImU32 col_bg  = GetStyleColorU32(ImPlotCol_LegendBg);
        const ImU32 col_bd  = GetStyleColorU32(ImPlotCol_LegendBorder);
        ImGui::PushClipRect(legend.RectClamped.Min, legend.RectClamped.Max, true);
        DrawList.AddRectFilled(legend.RectClamped.Min, legend.RectClamped.Max, col_bg);
        bool legend_contextable = ShowLegendEntries(plot.Items, legend.Rect, legend.Hovered, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !legend_horz, DrawList)
                                && !ImHasFlag(legend.Flags, ImPlotLegendFlags_NoMenus);
        DrawList.AddRect(legend.RectClamped.Min, legend.RectClamped.Max, col_bd);
        ImGui::PopClipRect();

        // main ctx menu
        if (gp.OpenContextThisFrame && legend_contextable && !ImHasFlag(plot.Flags, ImPlotFlags_NoMenus))
            ImGui::OpenPopup("##LegendContext");

        if (ImGui::BeginPopup("##LegendContext")) {
            ImGui::Text("Legend"); ImGui::Separator();
            if (ShowLegendContextMenu(legend, !ImHasFlag(plot.Flags, ImPlotFlags_NoLegend)))
                ImFlipFlag(plot.Flags, ImPlotFlags_NoLegend);
            ImGui::EndPopup();
        }
    }
    else {
        plot.Items.Legend.Rect = ImRect();
    }

    // render border
    if (render_border)
        DrawList.AddRect(plot.PlotRect.Min, plot.PlotRect.Max, GetStyleColorU32(ImPlotCol_PlotBorder), 0, ImDrawFlags_RoundCornersAll, gp.Style.PlotBorderSize);

    // render tags
    for (int i = 0; i < gp.Tags.Size; ++i) {
        ImPlotTag& tag  = gp.Tags.Tags[i];
        ImPlotAxis& axis = plot.Axes[tag.Axis];
        if (!axis.Enabled || !axis.Range.Contains(tag.Value))
            continue;
        const char* txt = gp.Tags.GetText(i);
        ImVec2 text_size = ImGui::CalcTextSize(txt);
        ImVec2 size = text_size + gp.Style.AnnotationPadding * 2;
        ImVec2 pos;
        axis.Ticker.OverrideSizeLate(size);
        float pix = IM_ROUND(axis.PlotToPixels(tag.Value));
        if (axis.Vertical) {
            if (axis.IsOpposite()) {
                pos = ImVec2(axis.Datum1 + gp.Style.LabelPadding.x, pix - size.y * 0.5f);
                DrawList.AddTriangleFilled(ImVec2(axis.Datum1,pix), pos, pos + ImVec2(0,size.y), tag.ColorBg);
            }
            else {
                pos = ImVec2(axis.Datum1 - size.x - gp.Style.LabelPadding.x, pix - size.y * 0.5f);
                DrawList.AddTriangleFilled(pos + ImVec2(size.x,0), ImVec2(axis.Datum1,pix), pos+size, tag.ColorBg);
            }
        }
        else {
            if (axis.IsOpposite()) {
                pos = ImVec2(pix - size.x * 0.5f, axis.Datum1 - size.y - gp.Style.LabelPadding.y );
                DrawList.AddTriangleFilled(pos + ImVec2(0,size.y), pos + size, ImVec2(pix,axis.Datum1), tag.ColorBg);
            }
            else {
                pos = ImVec2(pix - size.x * 0.5f, axis.Datum1 + gp.Style.LabelPadding.y);
                DrawList.AddTriangleFilled(pos, ImVec2(pix,axis.Datum1), pos + ImVec2(size.x, 0), tag.ColorBg);
            }
        }
        DrawList.AddRectFilled(pos,pos+size,tag.ColorBg);
        DrawList.AddText(pos+gp.Style.AnnotationPadding,tag.ColorFg,txt);
    }

    // FIT DATA --------------------------------------------------------------
    const bool axis_equal = ImHasFlag(plot.Flags, ImPlotFlags_Equal);
    if (plot.FitThisFrame) {
        for (int i = 0; i < IMPLOT_NUM_X_AXES; i++) {
            ImPlotAxis& x_axis = plot.XAxis(i);
            if (x_axis.FitThisFrame) {
                x_axis.ApplyFit(gp.Style.FitPadding.x);
                if (axis_equal && x_axis.OrthoAxis != nullptr) {
                    double aspect = x_axis.GetAspect();
                    ImPlotAxis& y_axis = *x_axis.OrthoAxis;
                    if (y_axis.FitThisFrame) {
                        y_axis.ApplyFit(gp.Style.FitPadding.y);
                        y_axis.FitThisFrame = false;
                        aspect = ImMax(aspect, y_axis.GetAspect());
                    }
                    x_axis.SetAspect(aspect);
                    y_axis.SetAspect(aspect);
                }
            }
        }
        for (int i = 0; i < IMPLOT_NUM_Y_AXES; i++) {
            ImPlotAxis& y_axis = plot.YAxis(i);
            if (y_axis.FitThisFrame) {
                y_axis.ApplyFit(gp.Style.FitPadding.y);
                if (axis_equal && y_axis.OrthoAxis != nullptr) {
                    double aspect = y_axis.GetAspect();
                    ImPlotAxis& x_axis = *y_axis.OrthoAxis;
                    if (x_axis.FitThisFrame) {
                        x_axis.ApplyFit(gp.Style.FitPadding.x);
                        x_axis.FitThisFrame = false;
                        aspect = ImMax(x_axis.GetAspect(), aspect);
                    }
                    x_axis.SetAspect(aspect);
                    y_axis.SetAspect(aspect);
                }
            }
        }
        plot.FitThisFrame = false;
    }

    // CONTEXT MENUS -----------------------------------------------------------

    ImGui::PushOverrideID(plot.ID);

    const bool can_ctx = gp.OpenContextThisFrame &&
                         !ImHasFlag(plot.Flags, ImPlotFlags_NoMenus) &&
                         !plot.Items.Legend.Hovered;



    // main ctx menu
    if (can_ctx && plot.Hovered)
        ImGui::OpenPopup("##PlotContext");
    if (ImGui::BeginPopup("##PlotContext")) {
        ShowPlotContextMenu(plot);
        ImGui::EndPopup();
    }

    // axes ctx menus
    for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {
        ImGui::PushID(i);
        ImPlotAxis& x_axis = plot.XAxis(i);
        if (can_ctx && x_axis.Hovered && x_axis.HasMenus())
            ImGui::OpenPopup("##XContext");
        if (ImGui::BeginPopup("##XContext")) {
            ImGui::Text(x_axis.HasLabel() ? plot.GetAxisLabel(x_axis) :  i == 0 ? "X-Axis" : "X-Axis %d", i + 1);
            ImGui::Separator();
            ShowAxisContextMenu(x_axis, axis_equal ? x_axis.OrthoAxis : nullptr, true);
            ImGui::EndPopup();
        }
        ImGui::PopID();
    }
    for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {
        ImGui::PushID(i);
        ImPlotAxis& y_axis = plot.YAxis(i);
        if (can_ctx && y_axis.Hovered && y_axis.HasMenus())
            ImGui::OpenPopup("##YContext");
        if (ImGui::BeginPopup("##YContext")) {
            ImGui::Text(y_axis.HasLabel() ? plot.GetAxisLabel(y_axis) : i == 0 ? "Y-Axis" : "Y-Axis %d", i + 1);
            ImGui::Separator();
            ShowAxisContextMenu(y_axis, axis_equal ? y_axis.OrthoAxis : nullptr, false);
            ImGui::EndPopup();
        }
        ImGui::PopID();
    }
    ImGui::PopID();

    // LINKED AXES ------------------------------------------------------------

    for (int i = 0; i < ImAxis_COUNT; ++i)
        plot.Axes[i].PushLinks();


    // CLEANUP ----------------------------------------------------------------

    // remove items
    if (gp.CurrentItems == &plot.Items)
        gp.CurrentItems = nullptr;
    // reset the plot items for the next frame
    for (int i = 0; i < plot.Items.GetItemCount(); ++i) {
        plot.Items.GetItemByIndex(i)->SeenThisFrame = false;
    }

    // mark the plot as initialized, i.e. having made it through one frame completely
    plot.Initialized = true;
    // Pop ImGui::PushID at the end of BeginPlot
    ImGui::PopID();
    // Reset context for next plot
    ResetCtxForNextPlot(GImPlot);

    // setup next subplot
    if (gp.CurrentSubplot != nullptr) {
        ImGui::PopID();
        SubplotNextCell();
    }
}

//-----------------------------------------------------------------------------
// BEGIN/END SUBPLOT
//-----------------------------------------------------------------------------

static const float SUBPLOT_BORDER_SIZE             = 1.0f;
static const float SUBPLOT_SPLITTER_HALF_THICKNESS = 4.0f;
static const float SUBPLOT_SPLITTER_FEEDBACK_TIMER = 0.06f;

void SubplotSetCell(int row, int col) {
    ImPlotContext& gp      = *GImPlot;
    ImPlotSubplot& subplot = *gp.CurrentSubplot;
    if (row >= subplot.Rows || col >= subplot.Cols)
        return;
    float xoff = 0;
    float yoff = 0;
    for (int c = 0; c < col; ++c)
        xoff += subplot.ColRatios[c];
    for (int r = 0; r < row; ++r)
        yoff += subplot.RowRatios[r];
    const ImVec2 grid_size = subplot.GridRect.GetSize();
    ImVec2 cpos            = subplot.GridRect.Min + ImVec2(xoff*grid_size.x,yoff*grid_size.y);
    cpos.x = IM_ROUND(cpos.x);
    cpos.y = IM_ROUND(cpos.y);
    ImGui::GetCurrentWindow()->DC.CursorPos =  cpos;
    // set cell size
    subplot.CellSize.x = IM_ROUND(subplot.GridRect.GetWidth()  * subplot.ColRatios[col]);
    subplot.CellSize.y = IM_ROUND(subplot.GridRect.GetHeight() * subplot.RowRatios[row]);
    // setup links
    const bool lx = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllX);
    const bool ly = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkAllY);
    const bool lr = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkRows);
    const bool lc = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_LinkCols);

    SetNextAxisLinks(ImAxis_X1, lx ? &subplot.ColLinkData[0].Min : lc ? &subplot.ColLinkData[col].Min : nullptr,
                                lx ? &subplot.ColLinkData[0].Max : lc ? &subplot.ColLinkData[col].Max : nullptr);
    SetNextAxisLinks(ImAxis_Y1, ly ? &subplot.RowLinkData[0].Min : lr ? &subplot.RowLinkData[row].Min : nullptr,
                                ly ? &subplot.RowLinkData[0].Max : lr ? &subplot.RowLinkData[row].Max : nullptr);
    // setup alignment
    if (!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoAlign)) {
        gp.CurrentAlignmentH = &subplot.RowAlignmentData[row];
        gp.CurrentAlignmentV = &subplot.ColAlignmentData[col];
    }
    // set idx
    if (ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ColMajor))
        subplot.CurrentIdx = col * subplot.Rows + row;
    else
        subplot.CurrentIdx = row * subplot.Cols + col;
}

void SubplotSetCell(int idx) {
    ImPlotContext& gp      = *GImPlot;
    ImPlotSubplot& subplot = *gp.CurrentSubplot;
    if (idx >= subplot.Rows * subplot.Cols)
        return;
    int row = 0, col = 0;
    if (ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ColMajor)) {
        row = idx % subplot.Rows;
        col = idx / subplot.Rows;
    }
    else {
        row = idx / subplot.Cols;
        col = idx % subplot.Cols;
    }
    return SubplotSetCell(row, col);
}

void SubplotNextCell() {
    ImPlotContext& gp      = *GImPlot;
    ImPlotSubplot& subplot = *gp.CurrentSubplot;
    SubplotSetCell(++subplot.CurrentIdx);
}

bool BeginSubplots(const char* title, int rows, int cols, const ImVec2& size, ImPlotSubplotFlags flags, float* row_sizes, float* col_sizes) {
    IM_ASSERT_USER_ERROR(rows > 0 && cols > 0, "Invalid sizing arguments!");
    IM_ASSERT_USER_ERROR(GImPlot != nullptr, "No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?");
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentSubplot == nullptr, "Mismatched BeginSubplots()/EndSubplots()!");
    ImGuiContext &G = *GImGui;
    ImGuiWindow * Window = G.CurrentWindow;
    if (Window->SkipItems)
        return false;
    const ImGuiID ID = Window->GetID(title);
    bool just_created = gp.Subplots.GetByKey(ID) == nullptr;
    gp.CurrentSubplot = gp.Subplots.GetOrAddByKey(ID);
    ImPlotSubplot& subplot = *gp.CurrentSubplot;
    subplot.ID       = ID;
    subplot.Items.ID = ID - 1;
    subplot.HasTitle = ImGui::FindRenderedTextEnd(title, nullptr) != title;
    // push ID
    ImGui::PushID(ID);

    if (just_created)
        subplot.Flags = flags;
    else if (flags != subplot.PreviousFlags)
        subplot.Flags = flags;
    subplot.PreviousFlags = flags;

    // check for change in rows and cols
    if (subplot.Rows != rows || subplot.Cols != cols) {
        subplot.RowAlignmentData.resize(rows);
        subplot.RowLinkData.resize(rows);
        subplot.RowRatios.resize(rows);
        for (int r = 0; r < rows; ++r) {
            subplot.RowAlignmentData[r].Reset();
            subplot.RowLinkData[r] = ImPlotRange(0,1);
            subplot.RowRatios[r] = 1.0f / rows;
        }
        subplot.ColAlignmentData.resize(cols);
        subplot.ColLinkData.resize(cols);
        subplot.ColRatios.resize(cols);
        for (int c = 0; c < cols; ++c) {
            subplot.ColAlignmentData[c].Reset();
            subplot.ColLinkData[c] = ImPlotRange(0,1);
            subplot.ColRatios[c] = 1.0f / cols;
        }
    }
    // check incoming size requests
    float row_sum = 0, col_sum = 0;
    if (row_sizes != nullptr) {
        row_sum = ImSum(row_sizes, rows);
        for (int r = 0; r < rows; ++r)
            subplot.RowRatios[r] = row_sizes[r] / row_sum;
    }
    if (col_sizes != nullptr) {
        col_sum = ImSum(col_sizes, cols);
        for (int c = 0; c < cols; ++c)
            subplot.ColRatios[c] = col_sizes[c] / col_sum;
    }
    subplot.Rows = rows;
    subplot.Cols = cols;

    // calc plot frame sizes
    ImVec2 title_size(0.0f, 0.0f);
    if (!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoTitle))
         title_size = ImGui::CalcTextSize(title, nullptr, true);
    const float pad_top = title_size.x > 0.0f ? title_size.y + gp.Style.LabelPadding.y : 0;
    const ImVec2 half_pad = gp.Style.PlotPadding/2;
    const ImVec2 frame_size = ImGui::CalcItemSize(size, gp.Style.PlotDefaultSize.x, gp.Style.PlotDefaultSize.y);
    subplot.FrameRect = ImRect(Window->DC.CursorPos, Window->DC.CursorPos + frame_size);
    subplot.GridRect.Min = subplot.FrameRect.Min + half_pad + ImVec2(0,pad_top);
    subplot.GridRect.Max = subplot.FrameRect.Max - half_pad;
    subplot.FrameHovered = subplot.FrameRect.Contains(ImGui::GetMousePos()) && ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows|ImGuiHoveredFlags_AllowWhenBlockedByActiveItem);

    // outside legend adjustments (TODO: make function)
    const bool share_items = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ShareItems);
    if (share_items)
        gp.CurrentItems = &subplot.Items;
    if (share_items && !ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoLegend) && subplot.Items.GetLegendCount() > 0) {
        ImPlotLegend& legend = subplot.Items.Legend;
        const bool horz = ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal);
        const ImVec2 legend_size = CalcLegendSize(subplot.Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !horz);
        const bool west = ImHasFlag(legend.Location, ImPlotLocation_West) && !ImHasFlag(legend.Location, ImPlotLocation_East);
        const bool east = ImHasFlag(legend.Location, ImPlotLocation_East) && !ImHasFlag(legend.Location, ImPlotLocation_West);
        const bool north = ImHasFlag(legend.Location, ImPlotLocation_North) && !ImHasFlag(legend.Location, ImPlotLocation_South);
        const bool south = ImHasFlag(legend.Location, ImPlotLocation_South) && !ImHasFlag(legend.Location, ImPlotLocation_North);
        if ((west && !horz) || (west && horz && !north && !south))
            subplot.GridRect.Min.x += (legend_size.x + gp.Style.LegendPadding.x);
        if ((east && !horz) || (east && horz && !north && !south))
            subplot.GridRect.Max.x -= (legend_size.x + gp.Style.LegendPadding.x);
        if ((north && horz) || (north && !horz && !west && !east))
            subplot.GridRect.Min.y += (legend_size.y + gp.Style.LegendPadding.y);
        if ((south && horz) || (south && !horz && !west && !east))
            subplot.GridRect.Max.y -= (legend_size.y + gp.Style.LegendPadding.y);
    }

    // render single background frame
    ImGui::RenderFrame(subplot.FrameRect.Min, subplot.FrameRect.Max, GetStyleColorU32(ImPlotCol_FrameBg), true, ImGui::GetStyle().FrameRounding);
    // render title
    if (title_size.x > 0.0f && !ImHasFlag(subplot.Flags, ImPlotFlags_NoTitle)) {
        const ImU32 col = GetStyleColorU32(ImPlotCol_TitleText);
        AddTextCentered(ImGui::GetWindowDrawList(),ImVec2(subplot.GridRect.GetCenter().x, subplot.GridRect.Min.y - pad_top + half_pad.y),col,title);
    }

    // render splitters
    if (!ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoResize)) {
        ImDrawList& DrawList = *ImGui::GetWindowDrawList();
        const ImU32 hov_col = ImGui::ColorConvertFloat4ToU32(GImGui->Style.Colors[ImGuiCol_SeparatorHovered]);
        const ImU32 act_col = ImGui::ColorConvertFloat4ToU32(GImGui->Style.Colors[ImGuiCol_SeparatorActive]);
        float xpos = subplot.GridRect.Min.x;
        float ypos = subplot.GridRect.Min.y;
        int separator = 1;
        // bool pass = false;
        for (int r = 0; r < subplot.Rows-1; ++r) {
            ypos += subplot.RowRatios[r] * subplot.GridRect.GetHeight();
            const ImGuiID sep_id = subplot.ID + separator;
            ImGui::KeepAliveID(sep_id);
            const ImRect sep_bb = ImRect(subplot.GridRect.Min.x, ypos-SUBPLOT_SPLITTER_HALF_THICKNESS, subplot.GridRect.Max.x, ypos+SUBPLOT_SPLITTER_HALF_THICKNESS);
            bool sep_hov = false, sep_hld = false;
            const bool sep_clk = ImGui::ButtonBehavior(sep_bb, sep_id, &sep_hov, &sep_hld, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick);
            if ((sep_hov && G.HoveredIdTimer > SUBPLOT_SPLITTER_FEEDBACK_TIMER) || sep_hld) {
                if (sep_clk && ImGui::IsMouseDoubleClicked(0)) {
                    float p = (subplot.RowRatios[r] + subplot.RowRatios[r+1])/2;
                    subplot.RowRatios[r] = subplot.RowRatios[r+1] = p;
                }
                if (sep_clk) {
                    subplot.TempSizes[0] = subplot.RowRatios[r];
                    subplot.TempSizes[1] = subplot.RowRatios[r+1];
                }
                if (sep_hld) {
                    float dp = ImGui::GetMouseDragDelta(0).y  / subplot.GridRect.GetHeight();
                    if (subplot.TempSizes[0] + dp > 0.1f && subplot.TempSizes[1] - dp > 0.1f) {
                        subplot.RowRatios[r]   = subplot.TempSizes[0] + dp;
                        subplot.RowRatios[r+1] = subplot.TempSizes[1] - dp;
                    }
                }
                DrawList.AddLine(ImVec2(IM_ROUND(subplot.GridRect.Min.x),IM_ROUND(ypos)),
                                 ImVec2(IM_ROUND(subplot.GridRect.Max.x),IM_ROUND(ypos)),
                                 sep_hld ? act_col : hov_col, SUBPLOT_BORDER_SIZE);
                ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS);
            }
            separator++;
        }
        for (int c = 0; c < subplot.Cols-1; ++c) {
            xpos += subplot.ColRatios[c] * subplot.GridRect.GetWidth();
            const ImGuiID sep_id = subplot.ID + separator;
            ImGui::KeepAliveID(sep_id);
            const ImRect sep_bb = ImRect(xpos-SUBPLOT_SPLITTER_HALF_THICKNESS, subplot.GridRect.Min.y, xpos+SUBPLOT_SPLITTER_HALF_THICKNESS, subplot.GridRect.Max.y);
            bool sep_hov = false, sep_hld = false;
            const bool sep_clk = ImGui::ButtonBehavior(sep_bb, sep_id, &sep_hov, &sep_hld, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick);
            if ((sep_hov && G.HoveredIdTimer > SUBPLOT_SPLITTER_FEEDBACK_TIMER) || sep_hld) {
                if (sep_clk && ImGui::IsMouseDoubleClicked(0)) {
                    float p = (subplot.ColRatios[c] + subplot.ColRatios[c+1])/2;
                    subplot.ColRatios[c] = subplot.ColRatios[c+1] = p;
                }
                if (sep_clk) {
                    subplot.TempSizes[0] = subplot.ColRatios[c];
                    subplot.TempSizes[1] = subplot.ColRatios[c+1];
                }
                if (sep_hld) {
                    float dp = ImGui::GetMouseDragDelta(0).x / subplot.GridRect.GetWidth();
                    if (subplot.TempSizes[0] + dp > 0.1f && subplot.TempSizes[1] - dp > 0.1f) {
                        subplot.ColRatios[c]   = subplot.TempSizes[0] + dp;
                        subplot.ColRatios[c+1] = subplot.TempSizes[1] - dp;
                    }
                }
                DrawList.AddLine(ImVec2(IM_ROUND(xpos),IM_ROUND(subplot.GridRect.Min.y)),
                                 ImVec2(IM_ROUND(xpos),IM_ROUND(subplot.GridRect.Max.y)),
                                 sep_hld ? act_col : hov_col, SUBPLOT_BORDER_SIZE);
                ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);
            }
            separator++;
        }
    }

    // set outgoing sizes
    if (row_sizes != nullptr) {
        for (int r = 0; r < rows; ++r)
            row_sizes[r] = subplot.RowRatios[r] * row_sum;
    }
    if (col_sizes != nullptr) {
        for (int c = 0; c < cols; ++c)
            col_sizes[c] = subplot.ColRatios[c] * col_sum;
    }

    // push styling
    PushStyleColor(ImPlotCol_FrameBg, IM_COL32_BLACK_TRANS);
    PushStyleVar(ImPlotStyleVar_PlotPadding, half_pad);
    PushStyleVar(ImPlotStyleVar_PlotMinSize, ImVec2(0,0));
    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize,0);

    // set initial cursor pos
    Window->DC.CursorPos = subplot.GridRect.Min;
    // begin alignments
    for (int r = 0; r < subplot.Rows; ++r)
        subplot.RowAlignmentData[r].Begin();
    for (int c = 0; c < subplot.Cols; ++c)
        subplot.ColAlignmentData[c].Begin();
    // clear legend data
    subplot.Items.Legend.Reset();
    // Setup first subplot
    SubplotSetCell(0,0);
    return true;
}

void EndSubplots() {
    IM_ASSERT_USER_ERROR(GImPlot != nullptr, "No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?");
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentSubplot != nullptr, "Mismatched BeginSubplots()/EndSubplots()!");
    ImPlotSubplot& subplot = *gp.CurrentSubplot;
    const ImGuiIO& IO  = ImGui::GetIO();
    // set alignments
    for (int r = 0; r < subplot.Rows; ++r)
        subplot.RowAlignmentData[r].End();
    for (int c = 0; c < subplot.Cols; ++c)
        subplot.ColAlignmentData[c].End();
    // pop styling
    PopStyleColor();
    PopStyleVar();
    PopStyleVar();
    ImGui::PopStyleVar();
    // legend
    subplot.Items.Legend.Hovered = false;
    for (int i = 0; i < subplot.Items.GetItemCount(); ++i)
        subplot.Items.GetItemByIndex(i)->LegendHovered = false;
    // render legend
    const bool share_items = ImHasFlag(subplot.Flags, ImPlotSubplotFlags_ShareItems);
    ImDrawList& DrawList = *ImGui::GetWindowDrawList();
    if (share_items && !ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoLegend) && subplot.Items.GetLegendCount() > 0) {
        ImPlotLegend& legend = subplot.Items.Legend;
        const bool   legend_horz = ImHasFlag(legend.Flags, ImPlotLegendFlags_Horizontal);
        const ImVec2 legend_size = CalcLegendSize(subplot.Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !legend_horz);
        const ImVec2 legend_pos  = GetLocationPos(subplot.FrameRect, legend_size, legend.Location, gp.Style.PlotPadding);
        legend.Rect = ImRect(legend_pos, legend_pos + legend_size);
        legend.RectClamped = legend.Rect;
        const bool legend_scrollable = ClampLegendRect(legend.RectClamped,subplot.FrameRect, gp.Style.PlotPadding);
        const ImGuiButtonFlags legend_button_flags = ImGuiButtonFlags_AllowOverlap
                                                    | ImGuiButtonFlags_PressedOnClick
                                                    | ImGuiButtonFlags_PressedOnDoubleClick
                                                    | ImGuiButtonFlags_MouseButtonLeft
                                                    | ImGuiButtonFlags_MouseButtonRight
                                                    | ImGuiButtonFlags_MouseButtonMiddle
                                                    | ImGuiButtonFlags_FlattenChildren;
        ImGui::KeepAliveID(subplot.Items.ID);
        ImGui::ButtonBehavior(legend.RectClamped, subplot.Items.ID, &legend.Hovered, &legend.Held, legend_button_flags);
        legend.Hovered = legend.Hovered || (subplot.FrameHovered && legend.RectClamped.Contains(ImGui::GetIO().MousePos));

        if (legend_scrollable) {
            if (legend.Hovered) {
                ImGui::SetKeyOwner(ImGuiKey_MouseWheelY, subplot.Items.ID);
                if (IO.MouseWheel != 0.0f) {
                    ImVec2 max_step = legend.Rect.GetSize() * 0.67f;
#if IMGUI_VERSION_NUM < 19172
                    float font_size = ImGui::GetCurrentWindow()->CalcFontSize();
#else
                    float font_size = ImGui::GetCurrentWindow()->FontRefSize;
#endif
                    float scroll_step = ImFloor(ImMin(2 * font_size, max_step.x));
                    legend.Scroll.x += scroll_step * IO.MouseWheel;
                    legend.Scroll.y += scroll_step * IO.MouseWheel;
                }
            }
            const ImVec2 min_scroll_offset = legend.RectClamped.GetSize() - legend.Rect.GetSize();
            legend.Scroll.x = ImClamp(legend.Scroll.x, min_scroll_offset.x, 0.0f);
            legend.Scroll.y = ImClamp(legend.Scroll.y, min_scroll_offset.y, 0.0f);
            const ImVec2 scroll_offset = legend_horz ? ImVec2(legend.Scroll.x, 0) : ImVec2(0, legend.Scroll.y);
            ImVec2 legend_offset = legend.RectClamped.Min - legend.Rect.Min + scroll_offset;
            legend.Rect.Min += legend_offset;
            legend.Rect.Max += legend_offset;
        } else {
            legend.Scroll = ImVec2(0,0);
        }

        const ImU32 col_bg = GetStyleColorU32(ImPlotCol_LegendBg);
        const ImU32 col_bd = GetStyleColorU32(ImPlotCol_LegendBorder);
        ImGui::PushClipRect(legend.RectClamped.Min, legend.RectClamped.Max, true);
        DrawList.AddRectFilled(legend.RectClamped.Min, legend.RectClamped.Max, col_bg);
        bool legend_contextable = ShowLegendEntries(subplot.Items, legend.Rect, legend.Hovered, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, !legend_horz, DrawList)
                                && !ImHasFlag(legend.Flags, ImPlotLegendFlags_NoMenus);
        DrawList.AddRect(legend.RectClamped.Min, legend.RectClamped.Max, col_bd);
        ImGui::PopClipRect();

        if (legend_contextable && !ImHasFlag(subplot.Flags, ImPlotSubplotFlags_NoMenus) && ImGui::GetIO().MouseReleased[gp.InputMap.Menu])
            ImGui::OpenPopup("##LegendContext");
        if (ImGui::BeginPopup("##LegendContext")) {
            ImGui::Text("Legend"); ImGui::Separator();
            if (ShowLegendContextMenu(legend, !ImHasFlag(subplot.Flags, ImPlotFlags_NoLegend)))
                ImFlipFlag(subplot.Flags, ImPlotFlags_NoLegend);
            ImGui::EndPopup();
        }
    }
    else {
        subplot.Items.Legend.Rect = ImRect();
    }
    // remove items
    if (gp.CurrentItems == &subplot.Items)
        gp.CurrentItems = nullptr;
    // reset the plot items for the next frame (TODO: put this elswhere)
    for (int i = 0; i < subplot.Items.GetItemCount(); ++i) {
        subplot.Items.GetItemByIndex(i)->SeenThisFrame = false;
    }
    // pop id
    ImGui::PopID();
    // set DC back correctly
    GImGui->CurrentWindow->DC.CursorPos = subplot.FrameRect.Min;
    ImGui::Dummy(subplot.FrameRect.GetSize());
    ResetCtxForNextSubplot(GImPlot);

}

//-----------------------------------------------------------------------------
// [SECTION] Plot Utils
//-----------------------------------------------------------------------------

void SetAxis(ImAxis axis) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "SetAxis() needs to be called between BeginPlot() and EndPlot()!");
    IM_ASSERT_USER_ERROR(axis >= ImAxis_X1 && axis < ImAxis_COUNT, "Axis index out of bounds!");
    IM_ASSERT_USER_ERROR(gp.CurrentPlot->Axes[axis].Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    SetupLock();
    if (axis < ImAxis_Y1)
        gp.CurrentPlot->CurrentX = axis;
    else
        gp.CurrentPlot->CurrentY = axis;
}

void SetAxes(ImAxis x_idx, ImAxis y_idx) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "SetAxes() needs to be called between BeginPlot() and EndPlot()!");
    IM_ASSERT_USER_ERROR(x_idx >= ImAxis_X1 && x_idx < ImAxis_Y1, "X-Axis index out of bounds!");
    IM_ASSERT_USER_ERROR(y_idx >= ImAxis_Y1 && y_idx < ImAxis_COUNT, "Y-Axis index out of bounds!");
    IM_ASSERT_USER_ERROR(gp.CurrentPlot->Axes[x_idx].Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    IM_ASSERT_USER_ERROR(gp.CurrentPlot->Axes[y_idx].Enabled, "Axis is not enabled! Did you forget to call SetupAxis()?");
    SetupLock();
    gp.CurrentPlot->CurrentX = x_idx;
    gp.CurrentPlot->CurrentY = y_idx;
}

ImPlotPoint PixelsToPlot(float x, float y, ImAxis x_idx, ImAxis y_idx) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "PixelsToPlot() needs to be called between BeginPlot() and EndPlot()!");
    IM_ASSERT_USER_ERROR(x_idx == IMPLOT_AUTO || (x_idx >= ImAxis_X1 && x_idx < ImAxis_Y1),    "X-Axis index out of bounds!");
    IM_ASSERT_USER_ERROR(y_idx == IMPLOT_AUTO || (y_idx >= ImAxis_Y1 && y_idx < ImAxis_COUNT), "Y-Axis index out of bounds!");
    SetupLock();
    ImPlotPlot& plot   = *gp.CurrentPlot;
    ImPlotAxis& x_axis = x_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentX] : plot.Axes[x_idx];
    ImPlotAxis& y_axis = y_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentY] : plot.Axes[y_idx];
    return ImPlotPoint( x_axis.PixelsToPlot(x), y_axis.PixelsToPlot(y) );
}

ImPlotPoint PixelsToPlot(const ImVec2& pix, ImAxis x_idx, ImAxis y_idx) {
    return PixelsToPlot(pix.x, pix.y, x_idx, y_idx);
}

ImVec2 PlotToPixels(double x, double y, ImAxis x_idx, ImAxis y_idx) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "PlotToPixels() needs to be called between BeginPlot() and EndPlot()!");
    IM_ASSERT_USER_ERROR(x_idx == IMPLOT_AUTO || (x_idx >= ImAxis_X1 && x_idx < ImAxis_Y1),    "X-Axis index out of bounds!");
    IM_ASSERT_USER_ERROR(y_idx == IMPLOT_AUTO || (y_idx >= ImAxis_Y1 && y_idx < ImAxis_COUNT), "Y-Axis index out of bounds!");
    SetupLock();
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& x_axis = x_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentX] : plot.Axes[x_idx];
    ImPlotAxis& y_axis = y_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentY] : plot.Axes[y_idx];
    return ImVec2( x_axis.PlotToPixels(x), y_axis.PlotToPixels(y) );
}

ImVec2 PlotToPixels(const ImPlotPoint& plt, ImAxis x_idx, ImAxis y_idx) {
    return PlotToPixels(plt.x, plt.y, x_idx, y_idx);
}

ImVec2 GetPlotPos() {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "GetPlotPos() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    return gp.CurrentPlot->PlotRect.Min;
}

ImVec2 GetPlotSize() {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "GetPlotSize() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    return gp.CurrentPlot->PlotRect.GetSize();
}

ImPlotPoint GetPlotMousePos(ImAxis x_idx, ImAxis y_idx) {
    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, "GetPlotMousePos() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    return PixelsToPlot(ImGui::GetMousePos(), x_idx, y_idx);
}

ImPlotRect GetPlotLimits(ImAxis x_idx, ImAxis y_idx) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "GetPlotLimits() needs to be called between BeginPlot() and EndPlot()!");
    IM_ASSERT_USER_ERROR(x_idx == IMPLOT_AUTO || (x_idx >= ImAxis_X1 && x_idx < ImAxis_Y1),    "X-Axis index out of bounds!");
    IM_ASSERT_USER_ERROR(y_idx == IMPLOT_AUTO || (y_idx >= ImAxis_Y1 && y_idx < ImAxis_COUNT), "Y-Axis index out of bounds!");
    SetupLock();
    ImPlotPlot& plot = *gp.CurrentPlot;
    ImPlotAxis& x_axis = x_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentX] : plot.Axes[x_idx];
    ImPlotAxis& y_axis = y_idx == IMPLOT_AUTO ? plot.Axes[plot.CurrentY] : plot.Axes[y_idx];
    ImPlotRect limits;
    limits.X = x_axis.Range;
    limits.Y = y_axis.Range;
    return limits;
}

bool IsPlotHovered() {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "IsPlotHovered() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    return gp.CurrentPlot->Hovered;
}

bool IsAxisHovered(ImAxis axis) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "IsPlotXAxisHovered() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    return gp.CurrentPlot->Axes[axis].Hovered;
}

bool IsSubplotsHovered() {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentSubplot != nullptr, "IsSubplotsHovered() needs to be called between BeginSubplots() and EndSubplots()!");
    return gp.CurrentSubplot->FrameHovered;
}

bool IsPlotSelected() {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "IsPlotSelected() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    return gp.CurrentPlot->Selected;
}

ImPlotRect GetPlotSelection(ImAxis x_idx, ImAxis y_idx) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "GetPlotSelection() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    ImPlotPlot& plot = *gp.CurrentPlot;
    if (!plot.Selected)
        return ImPlotRect(0,0,0,0);
    ImPlotPoint p1 = PixelsToPlot(plot.SelectRect.Min + plot.PlotRect.Min, x_idx, y_idx);
    ImPlotPoint p2 = PixelsToPlot(plot.SelectRect.Max + plot.PlotRect.Min, x_idx, y_idx);
    ImPlotRect result;
    result.X.Min = ImMin(p1.x, p2.x);
    result.X.Max = ImMax(p1.x, p2.x);
    result.Y.Min = ImMin(p1.y, p2.y);
    result.Y.Max = ImMax(p1.y, p2.y);
    return result;
}

void CancelPlotSelection() {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "CancelPlotSelection() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    ImPlotPlot& plot = *gp.CurrentPlot;
    if (plot.Selected)
        plot.Selected = plot.Selecting = false;
}

void HideNextItem(bool hidden, ImPlotCond cond) {
    ImPlotContext& gp = *GImPlot;
    gp.NextItemData.HasHidden  = true;
    gp.NextItemData.Hidden     = hidden;
    gp.NextItemData.HiddenCond = cond;
}

//-----------------------------------------------------------------------------
// [SECTION] Plot Tools
//-----------------------------------------------------------------------------

void Annotation(double x, double y, const ImVec4& col, const ImVec2& offset, bool clamp, bool round) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "Annotation() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    char x_buff[IMPLOT_LABEL_MAX_SIZE];
    char y_buff[IMPLOT_LABEL_MAX_SIZE];
    ImPlotAxis& x_axis = gp.CurrentPlot->Axes[gp.CurrentPlot->CurrentX];
    ImPlotAxis& y_axis = gp.CurrentPlot->Axes[gp.CurrentPlot->CurrentY];
    LabelAxisValue(x_axis, x, x_buff, sizeof(x_buff), round);
    LabelAxisValue(y_axis, y, y_buff, sizeof(y_buff), round);
    Annotation(x,y,col,offset,clamp,"%s, %s",x_buff,y_buff);
}

void AnnotationV(double x, double y, const ImVec4& col, const ImVec2& offset, bool clamp, const char* fmt, va_list args) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "Annotation() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    ImVec2 pos = PlotToPixels(x,y,IMPLOT_AUTO,IMPLOT_AUTO);
    ImU32  bg  = ImGui::GetColorU32(col);
    ImU32  fg  = col.w == 0 ? GetStyleColorU32(ImPlotCol_InlayText) : CalcTextColor(col);
    gp.Annotations.AppendV(pos, offset, bg, fg, clamp, fmt, args);
}

void Annotation(double x, double y, const ImVec4& col, const ImVec2& offset, bool clamp, const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    AnnotationV(x,y,col,offset,clamp,fmt,args);
    va_end(args);
}

void TagV(ImAxis axis, double v, const ImVec4& col, const char* fmt, va_list args) {
    ImPlotContext& gp = *GImPlot;
    SetupLock();
    ImU32 bg = ImGui::GetColorU32(col);
    ImU32 fg = col.w == 0 ? GetStyleColorU32(ImPlotCol_AxisText) : CalcTextColor(col);
    gp.Tags.AppendV(axis,v,bg,fg,fmt,args);
}

void Tag(ImAxis axis, double v, const ImVec4& col, const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    TagV(axis,v,col,fmt,args);
    va_end(args);
}

void Tag(ImAxis axis, double v, const ImVec4& color, bool round) {
    ImPlotContext& gp = *GImPlot;
    SetupLock();
    char buff[IMPLOT_LABEL_MAX_SIZE];
    ImPlotAxis& ax = gp.CurrentPlot->Axes[axis];
    LabelAxisValue(ax, v, buff, sizeof(buff), round);
    Tag(axis,v,color,"%s",buff);
}

IMPLOT_API void TagX(double x, const ImVec4& color, bool round) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "TagX() needs to be called between BeginPlot() and EndPlot()!");
    Tag(gp.CurrentPlot->CurrentX, x, color, round);
}

IMPLOT_API void TagX(double x, const ImVec4& color, const char* fmt, ...) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "TagX() needs to be called between BeginPlot() and EndPlot()!");
    va_list args;
    va_start(args, fmt);
    TagV(gp.CurrentPlot->CurrentX,x,color,fmt,args);
    va_end(args);
}

IMPLOT_API void TagXV(double x, const ImVec4& color, const char* fmt, va_list args) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "TagX() needs to be called between BeginPlot() and EndPlot()!");
    TagV(gp.CurrentPlot->CurrentX, x, color, fmt, args);
}

IMPLOT_API void TagY(double y, const ImVec4& color, bool round) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "TagY() needs to be called between BeginPlot() and EndPlot()!");
    Tag(gp.CurrentPlot->CurrentY, y, color, round);
}

IMPLOT_API void TagY(double y, const ImVec4& color, const char* fmt, ...) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "TagY() needs to be called between BeginPlot() and EndPlot()!");
    va_list args;
    va_start(args, fmt);
    TagV(gp.CurrentPlot->CurrentY,y,color,fmt,args);
    va_end(args);
}

IMPLOT_API void TagYV(double y, const ImVec4& color, const char* fmt, va_list args) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "TagY() needs to be called between BeginPlot() and EndPlot()!");
    TagV(gp.CurrentPlot->CurrentY, y, color, fmt, args);
}

static const float DRAG_GRAB_HALF_SIZE = 4.0f;

bool DragPoint(int n_id, double* x, double* y, const ImVec4& col, float radius, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {
    ImGui::PushID("#IMPLOT_DRAG_POINT");
    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, "DragPoint() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();

    if (!ImHasFlag(flags,ImPlotDragToolFlags_NoFit) && FitThisFrame()) {
        FitPoint(ImPlotPoint(*x,*y));
    }

    const bool input = !ImHasFlag(flags, ImPlotDragToolFlags_NoInputs);
    const bool show_curs = !ImHasFlag(flags, ImPlotDragToolFlags_NoCursors);
    const bool no_delay = !ImHasFlag(flags, ImPlotDragToolFlags_Delayed);
    const float grab_half_size = ImMax(DRAG_GRAB_HALF_SIZE, radius);
    const ImVec4 color = IsColorAuto(col) ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : col;
    const ImU32 col32 = ImGui::ColorConvertFloat4ToU32(color);

    ImVec2 pos = PlotToPixels(*x,*y,IMPLOT_AUTO,IMPLOT_AUTO);
    const ImGuiID id = ImGui::GetCurrentWindow()->GetID(n_id);
    ImRect rect(pos.x-grab_half_size,pos.y-grab_half_size,pos.x+grab_half_size,pos.y+grab_half_size);
    bool hovered = false, held = false;

    ImGui::KeepAliveID(id);
    if (input) {
        bool clicked = ImGui::ButtonBehavior(rect,id,&hovered,&held);
        if (out_clicked) *out_clicked = clicked;
        if (out_hovered) *out_hovered = hovered;
        if (out_held)    *out_held    = held;
    }

    bool modified = false;
    if (held && ImGui::IsMouseDragging(0)) {
        *x = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).x;
        *y = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).y;
        modified = true;
    }

    PushPlotClipRect();
    ImDrawList& DrawList = *GetPlotDrawList();
    if ((hovered || held) && show_curs)
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    if (modified && no_delay)
        pos = PlotToPixels(*x,*y,IMPLOT_AUTO,IMPLOT_AUTO);
    DrawList.AddCircleFilled(pos, radius, col32);
    PopPlotClipRect();

    ImGui::PopID();
    return modified;
}

bool DragLineX(int n_id, double* value, const ImVec4& col, float thickness, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {
    // ImGui::PushID("#IMPLOT_DRAG_LINE_X");
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "DragLineX() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();

    if (!ImHasFlag(flags,ImPlotDragToolFlags_NoFit) && FitThisFrame()) {
        FitPointX(*value);
    }

    const bool input = !ImHasFlag(flags, ImPlotDragToolFlags_NoInputs);
    const bool show_curs = !ImHasFlag(flags, ImPlotDragToolFlags_NoCursors);
    const bool no_delay = !ImHasFlag(flags, ImPlotDragToolFlags_Delayed);
    const float grab_half_size = ImMax(DRAG_GRAB_HALF_SIZE, thickness/2);
    float yt = gp.CurrentPlot->PlotRect.Min.y;
    float yb = gp.CurrentPlot->PlotRect.Max.y;
    float x  = IM_ROUND(PlotToPixels(*value,0,IMPLOT_AUTO,IMPLOT_AUTO).x);
    const ImGuiID id = ImGui::GetCurrentWindow()->GetID(n_id);
    ImRect rect(x-grab_half_size,yt,x+grab_half_size,yb);
    bool hovered = false, held = false;

    ImGui::KeepAliveID(id);
    if (input) {
        bool clicked = ImGui::ButtonBehavior(rect,id,&hovered,&held);
        if (out_clicked) *out_clicked = clicked;
        if (out_hovered) *out_hovered = hovered;
        if (out_held)    *out_held    = held;
    }

    if ((hovered || held) && show_curs)
        ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);

    float len = gp.Style.MajorTickLen.x;
    ImVec4 color = IsColorAuto(col) ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : col;
    ImU32 col32 = ImGui::ColorConvertFloat4ToU32(color);

    bool modified = false;
    if (held && ImGui::IsMouseDragging(0)) {
        *value = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).x;
        modified = true;
    }

    PushPlotClipRect();
    ImDrawList& DrawList = *GetPlotDrawList();
    if (modified && no_delay)
        x  = IM_ROUND(PlotToPixels(*value,0,IMPLOT_AUTO,IMPLOT_AUTO).x);
    DrawList.AddLine(ImVec2(x,yt), ImVec2(x,yb),     col32,   thickness);
    DrawList.AddLine(ImVec2(x,yt), ImVec2(x,yt+len), col32, 3*thickness);
    DrawList.AddLine(ImVec2(x,yb), ImVec2(x,yb-len), col32, 3*thickness);
    PopPlotClipRect();

    // ImGui::PopID();
    return modified;
}

bool DragLineY(int n_id, double* value, const ImVec4& col, float thickness, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {
    ImGui::PushID("#IMPLOT_DRAG_LINE_Y");
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "DragLineY() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();

    if (!ImHasFlag(flags,ImPlotDragToolFlags_NoFit) && FitThisFrame()) {
        FitPointY(*value);
    }

    const bool input = !ImHasFlag(flags, ImPlotDragToolFlags_NoInputs);
    const bool show_curs = !ImHasFlag(flags, ImPlotDragToolFlags_NoCursors);
    const bool no_delay = !ImHasFlag(flags, ImPlotDragToolFlags_Delayed);
    const float grab_half_size = ImMax(DRAG_GRAB_HALF_SIZE, thickness/2);
    float xl = gp.CurrentPlot->PlotRect.Min.x;
    float xr = gp.CurrentPlot->PlotRect.Max.x;
    float y  = IM_ROUND(PlotToPixels(0, *value,IMPLOT_AUTO,IMPLOT_AUTO).y);

    const ImGuiID id = ImGui::GetCurrentWindow()->GetID(n_id);
    ImRect rect(xl,y-grab_half_size,xr,y+grab_half_size);
    bool hovered = false, held = false;

    ImGui::KeepAliveID(id);
    if (input) {
        bool clicked = ImGui::ButtonBehavior(rect,id,&hovered,&held);
        if (out_clicked) *out_clicked = clicked;
        if (out_hovered) *out_hovered = hovered;
        if (out_held)    *out_held    = held;
    }

    if ((hovered || held) && show_curs)
        ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS);

    float len = gp.Style.MajorTickLen.y;
    ImVec4 color = IsColorAuto(col) ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : col;
    ImU32 col32 = ImGui::ColorConvertFloat4ToU32(color);

    bool modified = false;
    if (held && ImGui::IsMouseDragging(0)) {
        *value = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).y;
        modified = true;
    }

    PushPlotClipRect();
    ImDrawList& DrawList = *GetPlotDrawList();
    if (modified && no_delay)
        y  = IM_ROUND(PlotToPixels(0, *value,IMPLOT_AUTO,IMPLOT_AUTO).y);
    DrawList.AddLine(ImVec2(xl,y), ImVec2(xr,y),     col32,   thickness);
    DrawList.AddLine(ImVec2(xl,y), ImVec2(xl+len,y), col32, 3*thickness);
    DrawList.AddLine(ImVec2(xr,y), ImVec2(xr-len,y), col32, 3*thickness);
    PopPlotClipRect();

    ImGui::PopID();
    return modified;
}

bool DragRect(int n_id, double* x_min, double* y_min, double* x_max, double* y_max, const ImVec4& col, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {
    ImGui::PushID("#IMPLOT_DRAG_RECT");
    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, "DragRect() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();

    if (!ImHasFlag(flags,ImPlotDragToolFlags_NoFit) && FitThisFrame()) {
        FitPoint(ImPlotPoint(*x_min,*y_min));
        FitPoint(ImPlotPoint(*x_max,*y_max));
    }

    const bool input = !ImHasFlag(flags, ImPlotDragToolFlags_NoInputs);
    const bool show_curs = !ImHasFlag(flags, ImPlotDragToolFlags_NoCursors);
    const bool no_delay = !ImHasFlag(flags, ImPlotDragToolFlags_Delayed);
    bool    h[] = {true,false,true,false};
    double* x[] = {x_min,x_max,x_max,x_min};
    double* y[] = {y_min,y_min,y_max,y_max};
    ImVec2 p[4];
    for (int i = 0; i < 4; ++i)
        p[i] = PlotToPixels(*x[i],*y[i],IMPLOT_AUTO,IMPLOT_AUTO);
    ImVec2 pc = PlotToPixels((*x_min+*x_max)/2,(*y_min+*y_max)/2,IMPLOT_AUTO,IMPLOT_AUTO);
    ImRect rect(ImMin(p[0],p[2]),ImMax(p[0],p[2]));
    ImRect rect_grab = rect; rect_grab.Expand(DRAG_GRAB_HALF_SIZE);

    ImGuiMouseCursor cur[4];
    if (show_curs) {
        cur[0] = (rect.Min.x == p[0].x && rect.Min.y == p[0].y) || (rect.Max.x == p[0].x && rect.Max.y == p[0].y) ? ImGuiMouseCursor_ResizeNWSE : ImGuiMouseCursor_ResizeNESW;
        cur[1] = cur[0] == ImGuiMouseCursor_ResizeNWSE ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;
        cur[2] = cur[1] == ImGuiMouseCursor_ResizeNWSE ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;
        cur[3] = cur[2] == ImGuiMouseCursor_ResizeNWSE ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;
    }

    ImVec4 color = IsColorAuto(col) ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : col;
    ImU32 col32 = ImGui::ColorConvertFloat4ToU32(color);
    color.w *= 0.25f;
    ImU32 col32_a = ImGui::ColorConvertFloat4ToU32(color);
    const ImGuiID id = ImGui::GetCurrentWindow()->GetID(n_id);

    bool modified = false;
    bool clicked = false, hovered = false, held = false;
    ImRect b_rect(pc.x-DRAG_GRAB_HALF_SIZE,pc.y-DRAG_GRAB_HALF_SIZE,pc.x+DRAG_GRAB_HALF_SIZE,pc.y+DRAG_GRAB_HALF_SIZE);

    ImGui::KeepAliveID(id);
    if (input) {
        // middle point
        clicked = ImGui::ButtonBehavior(b_rect,id,&hovered,&held);
        if (out_clicked) *out_clicked = clicked;
        if (out_hovered) *out_hovered = hovered;
        if (out_held)    *out_held    = held;
    }

    if ((hovered || held) && show_curs)
        ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeAll);
    if (held && ImGui::IsMouseDragging(0)) {
        for (int i = 0; i < 4; ++i) {
            ImPlotPoint pp = PixelsToPlot(p[i] + ImGui::GetIO().MouseDelta,IMPLOT_AUTO,IMPLOT_AUTO);
            *y[i] = pp.y;
            *x[i] = pp.x;
        }
        modified = true;
    }

    for (int i = 0; i < 4; ++i) {
        // points
        b_rect = ImRect(p[i].x-DRAG_GRAB_HALF_SIZE,p[i].y-DRAG_GRAB_HALF_SIZE,p[i].x+DRAG_GRAB_HALF_SIZE,p[i].y+DRAG_GRAB_HALF_SIZE);
        ImGuiID p_id = id + i + 1;
        ImGui::KeepAliveID(p_id);
        if (input) {
            clicked = ImGui::ButtonBehavior(b_rect,p_id,&hovered,&held);
            if (out_clicked) *out_clicked = *out_clicked || clicked;
            if (out_hovered) *out_hovered = *out_hovered || hovered;
            if (out_held)    *out_held    = *out_held    || held;
        }
        if ((hovered || held) && show_curs)
            ImGui::SetMouseCursor(cur[i]);

        if (held && ImGui::IsMouseDragging(0)) {
            *x[i] = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).x;
            *y[i] = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).y;
            modified = true;
        }

        // edges
        ImVec2 e_min = ImMin(p[i],p[(i+1)%4]);
        ImVec2 e_max = ImMax(p[i],p[(i+1)%4]);
        b_rect = h[i] ? ImRect(e_min.x + DRAG_GRAB_HALF_SIZE, e_min.y - DRAG_GRAB_HALF_SIZE, e_max.x - DRAG_GRAB_HALF_SIZE, e_max.y + DRAG_GRAB_HALF_SIZE)
                    : ImRect(e_min.x - DRAG_GRAB_HALF_SIZE, e_min.y + DRAG_GRAB_HALF_SIZE, e_max.x + DRAG_GRAB_HALF_SIZE, e_max.y - DRAG_GRAB_HALF_SIZE);
        ImGuiID e_id = id + i + 5;
        ImGui::KeepAliveID(e_id);
        if (input) {
            clicked = ImGui::ButtonBehavior(b_rect,e_id,&hovered,&held);
            if (out_clicked) *out_clicked = *out_clicked || clicked;
            if (out_hovered) *out_hovered = *out_hovered || hovered;
            if (out_held)    *out_held    = *out_held    || held;
        }
        if ((hovered || held) && show_curs)
            h[i] ? ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeNS) : ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);
        if (held && ImGui::IsMouseDragging(0)) {
            if (h[i])
                *y[i] = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).y;
            else
                *x[i] = ImPlot::GetPlotMousePos(IMPLOT_AUTO,IMPLOT_AUTO).x;
            modified = true;
        }
        if (hovered && ImGui::IsMouseDoubleClicked(0))
        {
            ImPlotRect b = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO);
            if (h[i])
                *y[i] = ((y[i] == y_min && *y_min < *y_max) || (y[i] == y_max && *y_max < *y_min)) ? b.Y.Min : b.Y.Max;
            else
                *x[i] = ((x[i] == x_min && *x_min < *x_max) || (x[i] == x_max && *x_max < *x_min)) ? b.X.Min : b.X.Max;
            modified = true;
        }
    }

    const bool mouse_inside = rect_grab.Contains(ImGui::GetMousePos());
    const bool mouse_clicked = ImGui::IsMouseClicked(0);
    const bool mouse_down = ImGui::IsMouseDown(0);
    if (input && mouse_inside) {
        if (out_clicked) *out_clicked = *out_clicked || mouse_clicked;
        if (out_hovered) *out_hovered = true;
        if (out_held)    *out_held    = *out_held    || mouse_down;
    }

    PushPlotClipRect();
    ImDrawList& DrawList = *GetPlotDrawList();
    if (modified && no_delay) {
        for (int i = 0; i < 4; ++i)
            p[i] = PlotToPixels(*x[i],*y[i],IMPLOT_AUTO,IMPLOT_AUTO);
        pc = PlotToPixels((*x_min+*x_max)/2,(*y_min+*y_max)/2,IMPLOT_AUTO,IMPLOT_AUTO);
        rect = ImRect(ImMin(p[0],p[2]),ImMax(p[0],p[2]));
    }
    DrawList.AddRectFilled(rect.Min, rect.Max, col32_a);
    DrawList.AddRect(rect.Min, rect.Max, col32);
    if (input && (modified || mouse_inside)) {
        DrawList.AddCircleFilled(pc,DRAG_GRAB_HALF_SIZE,col32);
        for (int i = 0; i < 4; ++i)
            DrawList.AddCircleFilled(p[i],DRAG_GRAB_HALF_SIZE,col32);
    }
    PopPlotClipRect();
    ImGui::PopID();
    return modified;
}

bool DragRect(int id, ImPlotRect* bounds, const ImVec4& col, ImPlotDragToolFlags flags, bool* out_clicked, bool* out_hovered, bool* out_held) {
    return DragRect(id, &bounds->X.Min, &bounds->Y.Min,&bounds->X.Max, &bounds->Y.Max, col, flags, out_clicked, out_hovered, out_held);
}

//-----------------------------------------------------------------------------
// [SECTION] Legend Utils and Tools
//-----------------------------------------------------------------------------

bool IsLegendEntryHovered(const char* label_id) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentItems != nullptr, "IsPlotItemHighlight() needs to be called within an itemized context!");
    SetupLock();
    ImGuiID id = ImGui::GetIDWithSeed(label_id, nullptr, gp.CurrentItems->ID);
    ImPlotItem* item = gp.CurrentItems->GetItem(id);
    return item && item->LegendHovered;
}

bool BeginLegendPopup(const char* label_id, ImGuiMouseButton mouse_button) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentItems != nullptr, "BeginLegendPopup() needs to be called within an itemized context!");
    SetupLock();
    ImGuiWindow* window = GImGui->CurrentWindow;
    if (window->SkipItems)
        return false;
    ImGuiID id = ImGui::GetIDWithSeed(label_id, nullptr, gp.CurrentItems->ID);
    if (ImGui::IsMouseReleased(mouse_button)) {
        ImPlotItem* item = gp.CurrentItems->GetItem(id);
        if (item && item->LegendHovered)
            ImGui::OpenPopupEx(id);
    }
    return ImGui::BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

void EndLegendPopup() {
    SetupLock();
    ImGui::EndPopup();
}

void ShowAltLegend(const char* title_id, bool vertical, const ImVec2 size, bool interactable) {
    ImPlotContext& gp    = *GImPlot;
    ImGuiContext &G      = *GImGui;
    ImGuiWindow * Window = G.CurrentWindow;
    if (Window->SkipItems)
        return;
    ImDrawList &DrawList = *Window->DrawList;
    ImPlotPlot* plot = GetPlot(title_id);
    ImVec2 legend_size;
    ImVec2 default_size = gp.Style.LegendPadding * 2;
    if (plot != nullptr) {
        legend_size  = CalcLegendSize(plot->Items, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, vertical);
        default_size = legend_size + gp.Style.LegendPadding * 2;
    }
    ImVec2 frame_size = ImGui::CalcItemSize(size, default_size.x, default_size.y);
    ImRect bb_frame = ImRect(Window->DC.CursorPos, Window->DC.CursorPos + frame_size);
    ImGui::ItemSize(bb_frame);
    if (!ImGui::ItemAdd(bb_frame, 0, &bb_frame))
        return;
    ImGui::RenderFrame(bb_frame.Min, bb_frame.Max, GetStyleColorU32(ImPlotCol_FrameBg), true, G.Style.FrameRounding);
    DrawList.PushClipRect(bb_frame.Min, bb_frame.Max, true);
    if (plot != nullptr) {
        const ImVec2 legend_pos  = GetLocationPos(bb_frame, legend_size, 0, gp.Style.LegendPadding);
        const ImRect legend_bb(legend_pos, legend_pos + legend_size);
        interactable = interactable && bb_frame.Contains(ImGui::GetIO().MousePos);
        // render legend box
        ImU32  col_bg      = GetStyleColorU32(ImPlotCol_LegendBg);
        ImU32  col_bd      = GetStyleColorU32(ImPlotCol_LegendBorder);
        DrawList.AddRectFilled(legend_bb.Min, legend_bb.Max, col_bg);
        DrawList.AddRect(legend_bb.Min, legend_bb.Max, col_bd);
        // render entries
        ShowLegendEntries(plot->Items, legend_bb, interactable, gp.Style.LegendInnerPadding, gp.Style.LegendSpacing, vertical, DrawList);
    }
    DrawList.PopClipRect();
}

//-----------------------------------------------------------------------------
// [SECTION] Drag and Drop Utils
//-----------------------------------------------------------------------------

bool BeginDragDropTargetPlot() {
    SetupLock();
    ImPlotContext& gp = *GImPlot;
    ImRect rect = gp.CurrentPlot->PlotRect;
    return ImGui::BeginDragDropTargetCustom(rect, gp.CurrentPlot->ID);
}

bool BeginDragDropTargetAxis(ImAxis axis) {
    SetupLock();
    ImPlotPlot& plot = *GImPlot->CurrentPlot;
    ImPlotAxis& ax = plot.Axes[axis];
    ImRect rect = ax.HoverRect;
    rect.Expand(-3.5f);
    return ImGui::BeginDragDropTargetCustom(rect, ax.ID);
}

bool BeginDragDropTargetLegend() {
    SetupLock();
    ImPlotItemGroup& items = *GImPlot->CurrentItems;
    ImRect rect = items.Legend.RectClamped;
    return ImGui::BeginDragDropTargetCustom(rect, items.ID);
}

void EndDragDropTarget() {
    SetupLock();
	ImGui::EndDragDropTarget();
}

bool BeginDragDropSourcePlot(ImGuiDragDropFlags flags) {
    SetupLock();
    ImPlotContext& gp = *GImPlot;
    ImPlotPlot* plot = gp.CurrentPlot;
    if (GImGui->IO.KeyMods == gp.InputMap.OverrideMod || GImGui->DragDropPayload.SourceId == plot->ID)
        return ImGui::ItemAdd(plot->PlotRect, plot->ID) && ImGui::BeginDragDropSource(flags);
    return false;
}

bool BeginDragDropSourceAxis(ImAxis idx, ImGuiDragDropFlags flags) {
    SetupLock();
    ImPlotContext& gp = *GImPlot;
    ImPlotAxis& axis = gp.CurrentPlot->Axes[idx];
    if (GImGui->IO.KeyMods == gp.InputMap.OverrideMod || GImGui->DragDropPayload.SourceId == axis.ID)
        return ImGui::ItemAdd(axis.HoverRect, axis.ID) && ImGui::BeginDragDropSource(flags);
    return false;
}

bool BeginDragDropSourceItem(const char* label_id, ImGuiDragDropFlags flags) {
    SetupLock();
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentItems != nullptr, "BeginDragDropSourceItem() needs to be called within an itemized context!");
    ImGuiID item_id = ImGui::GetIDWithSeed(label_id, nullptr, gp.CurrentItems->ID);
    ImPlotItem* item = gp.CurrentItems->GetItem(item_id);
    if (item != nullptr) {
        return ImGui::ItemAdd(item->LegendHoverRect, item->ID) && ImGui::BeginDragDropSource(flags);
    }
    return false;
}

void EndDragDropSource() {
    SetupLock();
    ImGui::EndDragDropSource();
}

//-----------------------------------------------------------------------------
// [SECTION] Aligned Plots
//-----------------------------------------------------------------------------

bool BeginAlignedPlots(const char* group_id, bool vertical) {
    IM_ASSERT_USER_ERROR(GImPlot != nullptr, "No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?");
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentAlignmentH == nullptr && gp.CurrentAlignmentV == nullptr, "Mismatched BeginAlignedPlots()/EndAlignedPlots()!");
    ImGuiContext &G = *GImGui;
    ImGuiWindow * Window = G.CurrentWindow;
    if (Window->SkipItems)
        return false;
    const ImGuiID ID = Window->GetID(group_id);
    ImPlotAlignmentData* alignment = gp.AlignmentData.GetOrAddByKey(ID);
    if (vertical)
        gp.CurrentAlignmentV = alignment;
    else
        gp.CurrentAlignmentH = alignment;
    if (alignment->Vertical != vertical)
        alignment->Reset();
    alignment->Vertical = vertical;
    alignment->Begin();
    return true;
}

void EndAlignedPlots() {
    IM_ASSERT_USER_ERROR(GImPlot != nullptr, "No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?");
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentAlignmentH != nullptr || gp.CurrentAlignmentV != nullptr, "Mismatched BeginAlignedPlots()/EndAlignedPlots()!");
    ImPlotAlignmentData* alignment = gp.CurrentAlignmentH != nullptr ? gp.CurrentAlignmentH : (gp.CurrentAlignmentV != nullptr ? gp.CurrentAlignmentV : nullptr);
    if (alignment)
        alignment->End();
    ResetCtxForNextAlignedPlots(GImPlot);
}

//-----------------------------------------------------------------------------
// [SECTION] Plot and Item Styling
//-----------------------------------------------------------------------------

ImPlotStyle& GetStyle() {
    IM_ASSERT_USER_ERROR(GImPlot != nullptr, "No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?");
    ImPlotContext& gp = *GImPlot;
    return gp.Style;
}

void PushStyleColor(ImPlotCol idx, ImU32 col) {
    ImPlotContext& gp = *GImPlot;
    ImGuiColorMod backup;
    backup.Col = (ImGuiCol)idx;
    backup.BackupValue = gp.Style.Colors[idx];
    gp.ColorModifiers.push_back(backup);
    gp.Style.Colors[idx] = ImGui::ColorConvertU32ToFloat4(col);
}

void PushStyleColor(ImPlotCol idx, const ImVec4& col) {
    ImPlotContext& gp = *GImPlot;
    ImGuiColorMod backup;
    backup.Col = (ImGuiCol)idx;
    backup.BackupValue = gp.Style.Colors[idx];
    gp.ColorModifiers.push_back(backup);
    gp.Style.Colors[idx] = col;
}

void PopStyleColor(int count) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(count <= gp.ColorModifiers.Size, "You can't pop more modifiers than have been pushed!");
    while (count > 0)
    {
        ImGuiColorMod& backup = gp.ColorModifiers.back();
        gp.Style.Colors[backup.Col] = backup.BackupValue;
        gp.ColorModifiers.pop_back();
        count--;
    }
}

void PushStyleVar(ImPlotStyleVar idx, float val) {
    ImPlotContext& gp = *GImPlot;
    const ImPlotStyleVarInfo* var_info = GetPlotStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1) {
        float* pvar = (float*)var_info->GetVarPtr(&gp.Style);
        gp.StyleModifiers.push_back(ImGuiStyleMod((ImGuiStyleVar)idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0 && "Called PushStyleVar() float variant but variable is not a float!");
}

void PushStyleVar(ImPlotStyleVar idx, int val) {
    ImPlotContext& gp = *GImPlot;
    const ImPlotStyleVarInfo* var_info = GetPlotStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_S32 && var_info->Count == 1) {
        int* pvar = (int*)var_info->GetVarPtr(&gp.Style);
        gp.StyleModifiers.push_back(ImGuiStyleMod((ImGuiStyleVar)idx, *pvar));
        *pvar = val;
        return;
    }
    else if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1) {
        float* pvar = (float*)var_info->GetVarPtr(&gp.Style);
        gp.StyleModifiers.push_back(ImGuiStyleMod((ImGuiStyleVar)idx, *pvar));
        *pvar = (float)val;
        return;
    }
    IM_ASSERT(0 && "Called PushStyleVar() int variant but variable is not a int!");
}

void PushStyleVar(ImPlotStyleVar idx, const ImVec2& val)
{
    ImPlotContext& gp = *GImPlot;
    const ImPlotStyleVarInfo* var_info = GetPlotStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
    {
        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&gp.Style);
        gp.StyleModifiers.push_back(ImGuiStyleMod((ImGuiStyleVar)idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0 && "Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!");
}

void PopStyleVar(int count) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(count <= gp.StyleModifiers.Size, "You can't pop more modifiers than have been pushed!");
    while (count > 0) {
        ImGuiStyleMod& backup = gp.StyleModifiers.back();
        const ImPlotStyleVarInfo* info = GetPlotStyleVarInfo(backup.VarIdx);
        void* data = info->GetVarPtr(&gp.Style);
        if (info->Type == ImGuiDataType_Float && info->Count == 1) {
            ((float*)data)[0] = backup.BackupFloat[0];
        }
        else if (info->Type == ImGuiDataType_Float && info->Count == 2) {
             ((float*)data)[0] = backup.BackupFloat[0];
             ((float*)data)[1] = backup.BackupFloat[1];
        }
        else if (info->Type == ImGuiDataType_S32 && info->Count == 1) {
            ((int*)data)[0] = backup.BackupInt[0];
        }
        gp.StyleModifiers.pop_back();
        count--;
    }
}

//------------------------------------------------------------------------------
// [Section] Colormaps
//------------------------------------------------------------------------------

ImPlotColormap AddColormap(const char* name, const ImVec4* colormap, int size, bool qual) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(size > 1, "The colormap size must be greater than 1!");
    IM_ASSERT_USER_ERROR(gp.ColormapData.GetIndex(name) == -1, "The colormap name has already been used!");
    ImVector<ImU32> buffer;
    buffer.resize(size);
    for (int i = 0; i < size; ++i)
        buffer[i] = ImGui::ColorConvertFloat4ToU32(colormap[i]);
    return gp.ColormapData.Append(name, buffer.Data, size, qual);
}

ImPlotColormap AddColormap(const char* name, const ImU32*  colormap, int size, bool qual) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(size > 1, "The colormap size must be greater than 1!");
    IM_ASSERT_USER_ERROR(gp.ColormapData.GetIndex(name) == -1, "The colormap name has already be used!");
    return gp.ColormapData.Append(name, colormap, size, qual);
}

int GetColormapCount() {
    ImPlotContext& gp = *GImPlot;
    return gp.ColormapData.Count;
}

const char* GetColormapName(ImPlotColormap colormap) {
    ImPlotContext& gp = *GImPlot;
    return gp.ColormapData.GetName(colormap);
}

ImPlotColormap GetColormapIndex(const char* name) {
    ImPlotContext& gp = *GImPlot;
    return gp.ColormapData.GetIndex(name);
}

void PushColormap(ImPlotColormap colormap) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(colormap >= 0 && colormap < gp.ColormapData.Count, "The colormap index is invalid!");
    gp.ColormapModifiers.push_back(gp.Style.Colormap);
    gp.Style.Colormap = colormap;
}

void PushColormap(const char* name) {
    ImPlotContext& gp = *GImPlot;
    ImPlotColormap idx = gp.ColormapData.GetIndex(name);
    IM_ASSERT_USER_ERROR(idx != -1, "The colormap name is invalid!");
    PushColormap(idx);
}

void PopColormap(int count) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(count <= gp.ColormapModifiers.Size, "You can't pop more modifiers than have been pushed!");
    while (count > 0) {
        const ImPlotColormap& backup = gp.ColormapModifiers.back();
        gp.Style.Colormap     = backup;
        gp.ColormapModifiers.pop_back();
        count--;
    }
}

ImU32 NextColormapColorU32() {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentItems != nullptr, "NextColormapColor() needs to be called between BeginPlot() and EndPlot()!");
    int idx = gp.CurrentItems->ColormapIdx % gp.ColormapData.GetKeyCount(gp.Style.Colormap);
    ImU32 col  = gp.ColormapData.GetKeyColor(gp.Style.Colormap, idx);
    gp.CurrentItems->ColormapIdx++;
    return col;
}

ImVec4 NextColormapColor() {
    return ImGui::ColorConvertU32ToFloat4(NextColormapColorU32());
}

int GetColormapSize(ImPlotColormap cmap) {
    ImPlotContext& gp = *GImPlot;
    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;
    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, "Invalid colormap index!");
    return gp.ColormapData.GetKeyCount(cmap);
}

ImU32 GetColormapColorU32(int idx, ImPlotColormap cmap) {
    ImPlotContext& gp = *GImPlot;
    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;
    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, "Invalid colormap index!");
    idx = idx % gp.ColormapData.GetKeyCount(cmap);
    return gp.ColormapData.GetKeyColor(cmap, idx);
}

ImVec4 GetColormapColor(int idx, ImPlotColormap cmap) {
    return ImGui::ColorConvertU32ToFloat4(GetColormapColorU32(idx,cmap));
}

ImU32  SampleColormapU32(float t, ImPlotColormap cmap) {
    ImPlotContext& gp = *GImPlot;
    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;
    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, "Invalid colormap index!");
    return gp.ColormapData.LerpTable(cmap, t);
}

ImVec4 SampleColormap(float t, ImPlotColormap cmap) {
    return ImGui::ColorConvertU32ToFloat4(SampleColormapU32(t,cmap));
}

void RenderColorBar(const ImU32* colors, int size, ImDrawList& DrawList, const ImRect& bounds, bool vert, bool reversed, bool continuous) {
    const int n = continuous ? size - 1 : size;
    ImU32 col1, col2;
    if (vert) {
        const float step = bounds.GetHeight() / n;
        ImRect rect(bounds.Min.x, bounds.Min.y, bounds.Max.x, bounds.Min.y + step);
        for (int i = 0; i < n; ++i) {
            if (reversed) {
                col1 = colors[size-i-1];
                col2 = continuous ? colors[size-i-2] : col1;
            }
            else {
                col1 = colors[i];
                col2 = continuous ? colors[i+1] : col1;
            }
            DrawList.AddRectFilledMultiColor(rect.Min, rect.Max, col1, col1, col2, col2);
            rect.TranslateY(step);
        }
    }
    else {
        const float step = bounds.GetWidth() / n;
        ImRect rect(bounds.Min.x, bounds.Min.y, bounds.Min.x + step, bounds.Max.y);
        for (int i = 0; i < n; ++i) {
            if (reversed) {
                col1 = colors[size-i-1];
                col2 = continuous ? colors[size-i-2] : col1;
            }
            else {
                col1 = colors[i];
                col2 = continuous ? colors[i+1] : col1;
            }
            DrawList.AddRectFilledMultiColor(rect.Min, rect.Max, col1, col2, col2, col1);
            rect.TranslateX(step);
        }
    }
}

void ColormapScale(const char* label, double scale_min, double scale_max, const ImVec2& size, const char* format, ImPlotColormapScaleFlags flags, ImPlotColormap cmap) {
    ImGuiContext &G      = *GImGui;
    ImGuiWindow * Window = G.CurrentWindow;
    if (Window->SkipItems)
        return;

    const ImGuiID ID = Window->GetID(label);
    ImVec2 label_size(0,0);
    if (!ImHasFlag(flags, ImPlotColormapScaleFlags_NoLabel)) {
        label_size = ImGui::CalcTextSize(label,nullptr,true);
    }

    ImPlotContext& gp = *GImPlot;
    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;
    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, "Invalid colormap index!");

    ImVec2 frame_size  = ImGui::CalcItemSize(size, 0, gp.Style.PlotDefaultSize.y);
    if (frame_size.y < gp.Style.PlotMinSize.y && size.y < 0.0f)
        frame_size.y = gp.Style.PlotMinSize.y;

    ImPlotRange range(ImMin(scale_min,scale_max), ImMax(scale_min,scale_max));
    gp.CTicker.Reset();
    Locator_Default(gp.CTicker, range, frame_size.y, true, Formatter_Default, (void*)format);

    const bool rend_label = label_size.x > 0;
    const float txt_off   = gp.Style.LabelPadding.x;
    const float pad       = txt_off + gp.CTicker.MaxSize.x + (rend_label ? txt_off + label_size.y : 0);
    float bar_w           = 20;
    if (frame_size.x == 0)
        frame_size.x = bar_w + pad + 2 * gp.Style.PlotPadding.x;
    else {
        bar_w = frame_size.x - (pad + 2 * gp.Style.PlotPadding.x);
        if (bar_w < gp.Style.MajorTickLen.y)
            bar_w = gp.Style.MajorTickLen.y;
    }

    ImDrawList &DrawList = *Window->DrawList;
    ImRect bb_frame = ImRect(Window->DC.CursorPos, Window->DC.CursorPos + frame_size);
    ImGui::ItemSize(bb_frame);
    if (!ImGui::ItemAdd(bb_frame, ID, &bb_frame))
        return;

    ImGui::RenderFrame(bb_frame.Min, bb_frame.Max, GetStyleColorU32(ImPlotCol_FrameBg), true, G.Style.FrameRounding);

    const bool opposite = ImHasFlag(flags, ImPlotColormapScaleFlags_Opposite);
    const bool inverted = ImHasFlag(flags, ImPlotColormapScaleFlags_Invert);
    const bool reversed = scale_min > scale_max;

    float bb_grad_shift = opposite ? pad : 0;
    ImRect bb_grad(bb_frame.Min + gp.Style.PlotPadding + ImVec2(bb_grad_shift, 0),
                   bb_frame.Min + ImVec2(bar_w + gp.Style.PlotPadding.x + bb_grad_shift,
                                         frame_size.y - gp.Style.PlotPadding.y));

    ImGui::PushClipRect(bb_frame.Min, bb_frame.Max, true);
    const ImU32 col_text = ImGui::GetColorU32(ImGuiCol_Text);

    const bool invert_scale = inverted ? (reversed ? false : true) : (reversed ? true : false);
    const float y_min = invert_scale ? bb_grad.Max.y : bb_grad.Min.y;
    const float y_max = invert_scale ? bb_grad.Min.y : bb_grad.Max.y;

    RenderColorBar(gp.ColormapData.GetKeys(cmap), gp.ColormapData.GetKeyCount(cmap), DrawList, bb_grad, true, !inverted, !gp.ColormapData.IsQual(cmap));
    for (int i = 0; i < gp.CTicker.TickCount(); ++i) {
        const double y_pos_plt = gp.CTicker.Ticks[i].PlotPos;
        const float y_pos = ImRemap((float)y_pos_plt, (float)range.Max, (float)range.Min, y_min, y_max);
        const float tick_width = gp.CTicker.Ticks[i].Major ? gp.Style.MajorTickLen.y : gp.Style.MinorTickLen.y;
        const float tick_thick = gp.CTicker.Ticks[i].Major ? gp.Style.MajorTickSize.y : gp.Style.MinorTickSize.y;
        const float tick_t     = (float)((y_pos_plt - scale_min) / (scale_max - scale_min));
        const ImU32 tick_col = CalcTextColor(gp.ColormapData.LerpTable(cmap,tick_t));
        if (y_pos < bb_grad.Max.y - 2 && y_pos > bb_grad.Min.y + 2) {
            DrawList.AddLine(opposite ? ImVec2(bb_grad.Min.x+1, y_pos) : ImVec2(bb_grad.Max.x-1, y_pos),
                             opposite ? ImVec2(bb_grad.Min.x + tick_width, y_pos) : ImVec2(bb_grad.Max.x - tick_width, y_pos),
                             tick_col,
                             tick_thick);
        }
        const float txt_x = opposite ? bb_grad.Min.x - txt_off - gp.CTicker.Ticks[i].LabelSize.x : bb_grad.Max.x + txt_off;
        const float txt_y = y_pos - gp.CTicker.Ticks[i].LabelSize.y * 0.5f;
        DrawList.AddText(ImVec2(txt_x, txt_y), col_text, gp.CTicker.GetText(i));
    }

    if (rend_label) {
        const float pos_x = opposite ? bb_frame.Min.x + gp.Style.PlotPadding.x : bb_grad.Max.x + 2 * txt_off + gp.CTicker.MaxSize.x;
        const float pos_y = bb_grad.GetCenter().y + label_size.x * 0.5f;
        const char* label_end = ImGui::FindRenderedTextEnd(label);
        AddTextVertical(&DrawList,ImVec2(pos_x,pos_y),col_text,label,label_end);
    }
    DrawList.AddRect(bb_grad.Min, bb_grad.Max, GetStyleColorU32(ImPlotCol_PlotBorder));
    ImGui::PopClipRect();
}

bool ColormapSlider(const char* label, float* t, ImVec4* out, const char* format, ImPlotColormap cmap) {
    *t = ImClamp(*t,0.0f,1.0f);
    ImGuiContext &G      = *GImGui;
    ImGuiWindow * Window = G.CurrentWindow;
    if (Window->SkipItems)
        return false;
    ImPlotContext& gp = *GImPlot;
    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;
    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, "Invalid colormap index!");
    const ImU32* keys  = gp.ColormapData.GetKeys(cmap);
    const int    count = gp.ColormapData.GetKeyCount(cmap);
    const bool   qual  = gp.ColormapData.IsQual(cmap);
    const ImVec2 pos  = ImGui::GetCurrentWindow()->DC.CursorPos;
    const float w     = ImGui::CalcItemWidth();
    const float h     = ImGui::GetFrameHeight();
    const ImRect rect = ImRect(pos.x,pos.y,pos.x+w,pos.y+h);
    RenderColorBar(keys,count,*ImGui::GetWindowDrawList(),rect,false,false,!qual);
    const ImU32 grab = CalcTextColor(gp.ColormapData.LerpTable(cmap,*t));
    // const ImU32 text = CalcTextColor(gp.ColormapData.LerpTable(cmap,0.5f));
    ImGui::PushStyleColor(ImGuiCol_FrameBg,IM_COL32_BLACK_TRANS);
    ImGui::PushStyleColor(ImGuiCol_FrameBgActive,IM_COL32_BLACK_TRANS);
    ImGui::PushStyleColor(ImGuiCol_FrameBgHovered,ImVec4(1,1,1,0.1f));
    ImGui::PushStyleColor(ImGuiCol_SliderGrab,grab);
    ImGui::PushStyleColor(ImGuiCol_SliderGrabActive, grab);
    ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize,2);
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding,0);
    const bool changed = ImGui::SliderFloat(label,t,0,1,format);
    ImGui::PopStyleColor(5);
    ImGui::PopStyleVar(2);
    if (out != nullptr)
        *out = ImGui::ColorConvertU32ToFloat4(gp.ColormapData.LerpTable(cmap,*t));
    return changed;
}

bool ColormapButton(const char* label, const ImVec2& size_arg, ImPlotColormap cmap) {
    ImGuiContext &G      = *GImGui;
    const ImGuiStyle& style = G.Style;
    ImGuiWindow * Window = G.CurrentWindow;
    if (Window->SkipItems)
        return false;
    ImPlotContext& gp = *GImPlot;
    cmap = cmap == IMPLOT_AUTO ? gp.Style.Colormap : cmap;
    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, "Invalid colormap index!");
    const ImU32* keys  = gp.ColormapData.GetKeys(cmap);
    const int    count = gp.ColormapData.GetKeyCount(cmap);
    const bool   qual  = gp.ColormapData.IsQual(cmap);
    const ImVec2 pos  = ImGui::GetCurrentWindow()->DC.CursorPos;
    const ImVec2 label_size = ImGui::CalcTextSize(label, nullptr, true);
    ImVec2 size = ImGui::CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);
    const ImRect rect = ImRect(pos.x,pos.y,pos.x+size.x,pos.y+size.y);
    RenderColorBar(keys,count,*ImGui::GetWindowDrawList(),rect,false,false,!qual);
    const ImU32 text = CalcTextColor(gp.ColormapData.LerpTable(cmap,G.Style.ButtonTextAlign.x));
    ImGui::PushStyleColor(ImGuiCol_Button,IM_COL32_BLACK_TRANS);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered,ImVec4(1,1,1,0.1f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive,ImVec4(1,1,1,0.2f));
    ImGui::PushStyleColor(ImGuiCol_Text,text);
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding,0);
    const bool pressed = ImGui::Button(label,size);
    ImGui::PopStyleColor(4);
    ImGui::PopStyleVar(1);
    return pressed;
}

//-----------------------------------------------------------------------------
// [Section] Miscellaneous
//-----------------------------------------------------------------------------

ImPlotInputMap& GetInputMap() {
    IM_ASSERT_USER_ERROR(GImPlot != nullptr, "No current context. Did you call ImPlot::CreateContext() or ImPlot::SetCurrentContext()?");
    ImPlotContext& gp = *GImPlot;
    return gp.InputMap;
}

void MapInputDefault(ImPlotInputMap* dst) {
    ImPlotInputMap& map = dst ? *dst : GetInputMap();
    map.Pan             = ImGuiMouseButton_Left;
    map.PanMod          = ImGuiMod_None;
    map.Fit             = ImGuiMouseButton_Left;
    map.Menu            = ImGuiMouseButton_Right;
    map.Select          = ImGuiMouseButton_Right;
    map.SelectMod       = ImGuiMod_None;
    map.SelectCancel    = ImGuiMouseButton_Left;
    map.SelectHorzMod   = ImGuiMod_Alt;
    map.SelectVertMod   = ImGuiMod_Shift;
    map.OverrideMod     = ImGuiMod_Ctrl;
    map.ZoomMod         = ImGuiMod_None;
    map.ZoomRate        = 0.1f;
}

void MapInputReverse(ImPlotInputMap* dst) {
    ImPlotInputMap& map = dst ? *dst : GetInputMap();
    map.Pan             = ImGuiMouseButton_Right;
    map.PanMod          = ImGuiMod_None;
    map.Fit             = ImGuiMouseButton_Left;
    map.Menu            = ImGuiMouseButton_Right;
    map.Select          = ImGuiMouseButton_Left;
    map.SelectMod       = ImGuiMod_None;
    map.SelectCancel    = ImGuiMouseButton_Right;
    map.SelectHorzMod   = ImGuiMod_Alt;
    map.SelectVertMod   = ImGuiMod_Shift;
    map.OverrideMod     = ImGuiMod_Ctrl;
    map.ZoomMod         = ImGuiMod_None;
    map.ZoomRate        = 0.1f;
}

//-----------------------------------------------------------------------------
// [Section] Miscellaneous
//-----------------------------------------------------------------------------

void ItemIcon(const ImVec4& col) {
    ItemIcon(ImGui::ColorConvertFloat4ToU32(col));
}

void ItemIcon(ImU32 col) {
    const float txt_size = ImGui::GetTextLineHeight();
    ImVec2 size(txt_size-4,txt_size);
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    ImVec2 pos = window->DC.CursorPos;
    ImGui::GetWindowDrawList()->AddRectFilled(pos + ImVec2(0,2), pos + size - ImVec2(0,2), col);
    ImGui::Dummy(size);
}

void ColormapIcon(ImPlotColormap cmap) {
    ImPlotContext& gp = *GImPlot;
    const float txt_size = ImGui::GetTextLineHeight();
    ImVec2 size(txt_size-4,txt_size);
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    ImVec2 pos = window->DC.CursorPos;
    ImRect rect(pos+ImVec2(0,2),pos+size-ImVec2(0,2));
    ImDrawList& DrawList = *ImGui::GetWindowDrawList();
    RenderColorBar(gp.ColormapData.GetKeys(cmap),gp.ColormapData.GetKeyCount(cmap),DrawList,rect,false,false,!gp.ColormapData.IsQual(cmap));
    ImGui::Dummy(size);
}

ImDrawList* GetPlotDrawList() {
    return ImGui::GetWindowDrawList();
}

void PushPlotClipRect(float expand) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "PushPlotClipRect() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    ImRect rect = gp.CurrentPlot->PlotRect;
    rect.Expand(expand);
    ImGui::PushClipRect(rect.Min, rect.Max, true);
}

void PopPlotClipRect() {
    SetupLock();
    ImGui::PopClipRect();
}

static void HelpMarker(const char* desc) {
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

bool ShowStyleSelector(const char* label)
{
    static int style_idx = -1;
    if (ImGui::Combo(label, &style_idx, "Auto\0Classic\0Dark\0Light\0"))
    {
        switch (style_idx)
        {
        case 0: StyleColorsAuto(); break;
        case 1: StyleColorsClassic(); break;
        case 2: StyleColorsDark(); break;
        case 3: StyleColorsLight(); break;
        }
        return true;
    }
    return false;
}

bool ShowColormapSelector(const char* label) {
    ImPlotContext& gp = *GImPlot;
    bool set = false;
    if (ImGui::BeginCombo(label, gp.ColormapData.GetName(gp.Style.Colormap))) {
        for (int i = 0; i < gp.ColormapData.Count; ++i) {
            const char* name = gp.ColormapData.GetName(i);
            if (ImGui::Selectable(name, gp.Style.Colormap == i)) {
                gp.Style.Colormap = i;
                ImPlot::BustItemCache();
                set = true;
            }
        }
        ImGui::EndCombo();
    }
    return set;
}

bool ShowInputMapSelector(const char* label) {
    static int map_idx = -1;
    if (ImGui::Combo(label, &map_idx, "Default\0Reversed\0"))
    {
        switch (map_idx)
        {
        case 0: MapInputDefault(); break;
        case 1: MapInputReverse(); break;
        }
        return true;
    }
    return false;
}


void ShowStyleEditor(ImPlotStyle* ref) {
    ImPlotContext& gp = *GImPlot;
    ImPlotStyle& style = GetStyle();
    static ImPlotStyle ref_saved_style;
    // Default to using internal storage as reference
    static bool init = true;
    if (init && ref == nullptr)
        ref_saved_style = style;
    init = false;
    if (ref == nullptr)
        ref = &ref_saved_style;

    if (ImPlot::ShowStyleSelector("Colors##Selector"))
        ref_saved_style = style;

    // Save/Revert button
    if (ImGui::Button("Save Ref"))
        *ref = ref_saved_style = style;
    ImGui::SameLine();
    if (ImGui::Button("Revert Ref"))
        style = *ref;
    ImGui::SameLine();
    HelpMarker("Save/Revert in local non-persistent storage. Default Colors definition are not affected. "
               "Use \"Export\" below to save them somewhere.");
    if (ImGui::BeginTabBar("##StyleEditor")) {
        if (ImGui::BeginTabItem("Variables")) {
            ImGui::Text("Item Styling");
            ImGui::SliderFloat("LineWeight", &style.LineWeight, 0.0f, 5.0f, "%.1f");
            ImGui::SliderFloat("MarkerSize", &style.MarkerSize, 2.0f, 10.0f, "%.1f");
            ImGui::SliderFloat("MarkerWeight", &style.MarkerWeight, 0.0f, 5.0f, "%.1f");
            ImGui::SliderFloat("FillAlpha", &style.FillAlpha, 0.0f, 1.0f, "%.2f");
            ImGui::SliderFloat("ErrorBarSize", &style.ErrorBarSize, 0.0f, 10.0f, "%.1f");
            ImGui::SliderFloat("ErrorBarWeight", &style.ErrorBarWeight, 0.0f, 5.0f, "%.1f");
            ImGui::SliderFloat("DigitalBitHeight", &style.DigitalBitHeight, 0.0f, 20.0f, "%.1f");
            ImGui::SliderFloat("DigitalBitGap", &style.DigitalBitGap, 0.0f, 20.0f, "%.1f");
            ImGui::Text("Plot Styling");
            ImGui::SliderFloat("PlotBorderSize", &style.PlotBorderSize, 0.0f, 2.0f, "%.0f");
            ImGui::SliderFloat("MinorAlpha", &style.MinorAlpha, 0.0f, 1.0f, "%.2f");
            ImGui::SliderFloat2("MajorTickLen", (float*)&style.MajorTickLen, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("MinorTickLen", (float*)&style.MinorTickLen, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("MajorTickSize",  (float*)&style.MajorTickSize, 0.0f, 2.0f, "%.1f");
            ImGui::SliderFloat2("MinorTickSize", (float*)&style.MinorTickSize, 0.0f, 2.0f, "%.1f");
            ImGui::SliderFloat2("MajorGridSize", (float*)&style.MajorGridSize, 0.0f, 2.0f, "%.1f");
            ImGui::SliderFloat2("MinorGridSize", (float*)&style.MinorGridSize, 0.0f, 2.0f, "%.1f");
            ImGui::SliderFloat2("PlotDefaultSize", (float*)&style.PlotDefaultSize, 0.0f, 1000, "%.0f");
            ImGui::SliderFloat2("PlotMinSize", (float*)&style.PlotMinSize, 0.0f, 300, "%.0f");
            ImGui::Text("Plot Padding");
            ImGui::SliderFloat2("PlotPadding", (float*)&style.PlotPadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("LabelPadding", (float*)&style.LabelPadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("LegendPadding", (float*)&style.LegendPadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("LegendInnerPadding", (float*)&style.LegendInnerPadding, 0.0f, 10.0f, "%.0f");
            ImGui::SliderFloat2("LegendSpacing", (float*)&style.LegendSpacing, 0.0f, 5.0f, "%.0f");
            ImGui::SliderFloat2("MousePosPadding", (float*)&style.MousePosPadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("AnnotationPadding", (float*)&style.AnnotationPadding, 0.0f, 5.0f, "%.0f");
            ImGui::SliderFloat2("FitPadding", (float*)&style.FitPadding, 0, 0.2f, "%.2f");

            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Colors")) {
            static int output_dest = 0;
            static bool output_only_modified = false;

            if (ImGui::Button("Export", ImVec2(75,0))) {
                if (output_dest == 0)
                    ImGui::LogToClipboard();
                else
                    ImGui::LogToTTY();
                ImGui::LogText("ImVec4* colors = ImPlot::GetStyle().Colors;\n");
                for (int i = 0; i < ImPlotCol_COUNT; i++) {
                    const ImVec4& col = style.Colors[i];
                    const char* name = ImPlot::GetStyleColorName(i);
                    if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0) {
                        if (IsColorAuto(i))
                            ImGui::LogText("colors[ImPlotCol_%s]%*s= IMPLOT_AUTO_COL;\n",name,14 - (int)strlen(name), "");
                        else
                            ImGui::LogText("colors[ImPlotCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);\n",
                                        name, 14 - (int)strlen(name), "", col.x, col.y, col.z, col.w);
                    }
                }
                ImGui::LogFinish();
            }
            ImGui::SameLine(); ImGui::SetNextItemWidth(120); ImGui::Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0");
            ImGui::SameLine(); ImGui::Checkbox("Only Modified Colors", &output_only_modified);

            static ImGuiTextFilter filter;
            filter.Draw("Filter colors", ImGui::GetFontSize() * 16);

            static ImGuiColorEditFlags alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf;
#if IMGUI_VERSION_NUM < 19173
            if (ImGui::RadioButton("Opaque", alpha_flags == ImGuiColorEditFlags_None))             { alpha_flags = ImGuiColorEditFlags_None; } ImGui::SameLine();
            if (ImGui::RadioButton("Alpha",  alpha_flags == ImGuiColorEditFlags_AlphaPreview))     { alpha_flags = ImGuiColorEditFlags_AlphaPreview; } ImGui::SameLine();
            if (ImGui::RadioButton("Both",   alpha_flags == ImGuiColorEditFlags_AlphaPreviewHalf)) { alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf; } ImGui::SameLine();
#else
            if (ImGui::RadioButton("Opaque", alpha_flags == ImGuiColorEditFlags_AlphaOpaque))      { alpha_flags = ImGuiColorEditFlags_AlphaOpaque; } ImGui::SameLine();
            if (ImGui::RadioButton("Alpha",  alpha_flags == ImGuiColorEditFlags_None))             { alpha_flags = ImGuiColorEditFlags_None; } ImGui::SameLine();
            if (ImGui::RadioButton("Both",   alpha_flags == ImGuiColorEditFlags_AlphaPreviewHalf)) { alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf; } ImGui::SameLine();
#endif
            HelpMarker(
                "In the color list:\n"
                "Left-click on colored square to open color picker,\n"
                "Right-click to open edit options menu.");
            ImGui::Separator();
            ImGui::PushItemWidth(-160);
            for (int i = 0; i < ImPlotCol_COUNT; i++) {
                const char* name = ImPlot::GetStyleColorName(i);
                if (!filter.PassFilter(name))
                    continue;
                ImGui::PushID(i);
                ImVec4 temp = GetStyleColorVec4(i);
                const bool is_auto = IsColorAuto(i);
                if (!is_auto)
                    ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.25f);
                if (ImGui::Button("Auto")) {
                    if (is_auto)
                        style.Colors[i] = temp;
                    else
                        style.Colors[i] = IMPLOT_AUTO_COL;
                    BustItemCache();
                }
                if (!is_auto)
                    ImGui::PopStyleVar();
                ImGui::SameLine();
                if (ImGui::ColorEdit4(name, &temp.x, ImGuiColorEditFlags_NoInputs | alpha_flags)) {
                    style.Colors[i] = temp;
                    BustItemCache();
                }
                if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0) {
                    ImGui::SameLine(175); if (ImGui::Button("Save")) { ref->Colors[i] = style.Colors[i]; }
                    ImGui::SameLine(); if (ImGui::Button("Revert")) {
                        style.Colors[i] = ref->Colors[i];
                        BustItemCache();
                    }
                }
                ImGui::PopID();
            }
            ImGui::PopItemWidth();
            ImGui::Separator();
            ImGui::Text("Colors that are set to Auto (i.e. IMPLOT_AUTO_COL) will\n"
                        "be automatically deduced from your ImGui style or the\n"
                        "current ImPlot Colormap. If you want to style individual\n"
                        "plot items, use Push/PopStyleColor around its function.");
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Colormaps")) {
            static int output_dest = 0;
            if (ImGui::Button("Export", ImVec2(75,0))) {
                if (output_dest == 0)
                    ImGui::LogToClipboard();
                else
                    ImGui::LogToTTY();
                int size = GetColormapSize();
                const char* name = GetColormapName(gp.Style.Colormap);
                ImGui::LogText("static const ImU32 %s_Data[%d] = {\n", name, size);
                for (int i = 0; i < size; ++i) {
                    ImU32 col = GetColormapColorU32(i,gp.Style.Colormap);
                    ImGui::LogText("    %u%s\n", col, i == size - 1 ? "" : ",");
                }
                ImGui::LogText("};\nImPlotColormap %s = ImPlot::AddColormap(\"%s\", %s_Data, %d);", name, name, name, size);
                ImGui::LogFinish();
            }
            ImGui::SameLine(); ImGui::SetNextItemWidth(120); ImGui::Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0");
            ImGui::SameLine();
            static bool edit = false;
            ImGui::Checkbox("Edit Mode",&edit);

            // built-in/added
            ImGui::Separator();
            for (int i = 0; i < gp.ColormapData.Count; ++i) {
                ImGui::PushID(i);
                int size = gp.ColormapData.GetKeyCount(i);
                bool selected = i == gp.Style.Colormap;

                const char* name = GetColormapName(i);
                if (!selected)
                    ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.25f);
                if (ImGui::Button(name, ImVec2(100,0))) {
                    gp.Style.Colormap = i;
                    BustItemCache();
                }
                if (!selected)
                    ImGui::PopStyleVar();
                ImGui::SameLine();
                ImGui::BeginGroup();
                if (edit) {
                    for (int c = 0; c < size; ++c) {
                        ImGui::PushID(c);
                        ImVec4 col4 = ImGui::ColorConvertU32ToFloat4(gp.ColormapData.GetKeyColor(i,c));
                        if (ImGui::ColorEdit4("",&col4.x,ImGuiColorEditFlags_NoInputs)) {
                            ImU32 col32 = ImGui::ColorConvertFloat4ToU32(col4);
                            gp.ColormapData.SetKeyColor(i,c,col32);
                            BustItemCache();
                        }
                        if ((c + 1) % 12 != 0 && c != size -1)
                            ImGui::SameLine();
                        ImGui::PopID();
                    }
                }
                else {
                    if (ImPlot::ColormapButton("##",ImVec2(-1,0),i))
                        edit = true;
                }
                ImGui::EndGroup();
                ImGui::PopID();
            }


            static ImVector<ImVec4> custom;
            if (custom.Size == 0) {
                custom.push_back(ImVec4(1,0,0,1));
                custom.push_back(ImVec4(0,1,0,1));
                custom.push_back(ImVec4(0,0,1,1));
            }
            ImGui::Separator();
            ImGui::BeginGroup();
            static char name[16] = "MyColormap";


            if (ImGui::Button("+", ImVec2((100 - ImGui::GetStyle().ItemSpacing.x)/2,0)))
                custom.push_back(ImVec4(0,0,0,1));
            ImGui::SameLine();
            if (ImGui::Button("-", ImVec2((100 - ImGui::GetStyle().ItemSpacing.x)/2,0)) && custom.Size > 2)
                custom.pop_back();
            ImGui::SetNextItemWidth(100);
            ImGui::InputText("##Name",name,16,ImGuiInputTextFlags_CharsNoBlank);
            static bool qual = true;
            ImGui::Checkbox("Qualitative",&qual);
            if (ImGui::Button("Add", ImVec2(100, 0)) && gp.ColormapData.GetIndex(name)==-1)
                AddColormap(name,custom.Data,custom.Size,qual);

            ImGui::EndGroup();
            ImGui::SameLine();
            ImGui::BeginGroup();
            for (int c = 0; c < custom.Size; ++c) {
                ImGui::PushID(c);
                if (ImGui::ColorEdit4("##Col1", &custom[c].x, ImGuiColorEditFlags_NoInputs)) {

                }
                if ((c + 1) % 12 != 0)
                    ImGui::SameLine();
                ImGui::PopID();
            }
            ImGui::EndGroup();


            ImGui::EndTabItem();
        }
        ImGui::EndTabBar();
    }
}

void ShowUserGuide() {
        ImGui::BulletText("Left-click drag within the plot area to pan X and Y axes.");
    ImGui::Indent();
        ImGui::BulletText("Left-click drag on axis labels to pan an individual axis.");
    ImGui::Unindent();
    ImGui::BulletText("Scroll in the plot area to zoom both X and Y axes.");
    ImGui::Indent();
        ImGui::BulletText("Scroll on axis labels to zoom an individual axis.");
    ImGui::Unindent();
    ImGui::BulletText("Right-click drag to box select data.");
    ImGui::Indent();
        ImGui::BulletText("Hold Alt to expand box selection horizontally.");
        ImGui::BulletText("Hold Shift to expand box selection vertically.");
        ImGui::BulletText("Left-click while box selecting to cancel the selection.");
    ImGui::Unindent();
    ImGui::BulletText("Double left-click to fit all visible data.");
    ImGui::Indent();
        ImGui::BulletText("Double left-click axis labels to fit the individual axis.");
    ImGui::Unindent();
    ImGui::BulletText("Right-click open the full plot context menu.");
    ImGui::Indent();
        ImGui::BulletText("Right-click axis labels to open an individual axis context menu.");
    ImGui::Unindent();
    ImGui::BulletText("Click legend label icons to show/hide plot items.");
}

void ShowTicksMetrics(const ImPlotTicker& ticker) {
    ImGui::BulletText("Size: %d", ticker.TickCount());
    ImGui::BulletText("MaxSize: [%f,%f]", ticker.MaxSize.x, ticker.MaxSize.y);
}

void ShowAxisMetrics(const ImPlotPlot& plot, const ImPlotAxis& axis) {
    ImGui::BulletText("Label: %s", axis.LabelOffset == -1 ? "[none]" : plot.GetAxisLabel(axis));
    ImGui::BulletText("Flags: 0x%08X", axis.Flags);
    ImGui::BulletText("Range: [%f,%f]",axis.Range.Min, axis.Range.Max);
    ImGui::BulletText("Pixels: %f", axis.PixelSize());
    ImGui::BulletText("Aspect: %f", axis.GetAspect());
    ImGui::BulletText(axis.OrthoAxis == nullptr ? "OrtherAxis: NULL" : "OrthoAxis: 0x%08X", axis.OrthoAxis->ID);
    ImGui::BulletText("LinkedMin: %p", (void*)axis.LinkedMin);
    ImGui::BulletText("LinkedMax: %p", (void*)axis.LinkedMax);
    ImGui::BulletText("HasRange: %s", axis.HasRange ? "true" : "false");
    ImGui::BulletText("Hovered: %s", axis.Hovered ? "true" : "false");
    ImGui::BulletText("Held: %s", axis.Held ? "true" : "false");

    if (ImGui::TreeNode("Transform")) {
        ImGui::BulletText("PixelMin: %f", axis.PixelMin);
        ImGui::BulletText("PixelMax: %f", axis.PixelMax);
        ImGui::BulletText("ScaleToPixel: %f", axis.ScaleToPixel);
        ImGui::BulletText("ScaleMax: %f", axis.ScaleMax);
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Ticks")) {
        ShowTicksMetrics(axis.Ticker);
        ImGui::TreePop();
    }
}

void ShowMetricsWindow(bool* p_popen) {

    static bool show_plot_rects = false;
    static bool show_axes_rects = false;
    static bool show_axis_rects = false;
    static bool show_canvas_rects = false;
    static bool show_frame_rects = false;
    static bool show_subplot_frame_rects = false;
    static bool show_subplot_grid_rects = false;
    static bool show_legend_rects = false;

    ImDrawList& fg = *ImGui::GetForegroundDrawList();

    ImPlotContext& gp = *GImPlot;
    // ImGuiContext& g = *GImGui;
    ImGuiIO& io = ImGui::GetIO();
    ImGui::Begin("ImPlot Metrics", p_popen);
    ImGui::Text("ImPlot " IMPLOT_VERSION);
    ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
    ImGui::Text("Mouse Position: [%.0f,%.0f]", io.MousePos.x, io.MousePos.y);
    ImGui::Separator();
    if (ImGui::TreeNode("Tools")) {
        if (ImGui::Button("Bust Plot Cache"))
            BustPlotCache();
        ImGui::SameLine();
        if (ImGui::Button("Bust Item Cache"))
            BustItemCache();
        ImGui::Checkbox("Show Frame Rects", &show_frame_rects);
        ImGui::Checkbox("Show Canvas Rects",&show_canvas_rects);
        ImGui::Checkbox("Show Plot Rects",  &show_plot_rects);
        ImGui::Checkbox("Show Axes Rects",  &show_axes_rects);
        ImGui::Checkbox("Show Axis Rects",  &show_axis_rects);
        ImGui::Checkbox("Show Subplot Frame Rects",  &show_subplot_frame_rects);
        ImGui::Checkbox("Show Subplot Grid Rects",  &show_subplot_grid_rects);
        ImGui::Checkbox("Show Legend Rects",  &show_legend_rects);
        ImGui::TreePop();
    }
    const int n_plots = gp.Plots.GetBufSize();
    const int n_subplots = gp.Subplots.GetBufSize();
    // render rects
    for (int p = 0; p < n_plots; ++p) {
        ImPlotPlot* plot = gp.Plots.GetByIndex(p);
        if (show_frame_rects)
            fg.AddRect(plot->FrameRect.Min, plot->FrameRect.Max, IM_COL32(255,0,255,255));
        if (show_canvas_rects)
            fg.AddRect(plot->CanvasRect.Min, plot->CanvasRect.Max, IM_COL32(0,255,255,255));
        if (show_plot_rects)
            fg.AddRect(plot->PlotRect.Min, plot->PlotRect.Max, IM_COL32(255,255,0,255));
        if (show_axes_rects)
            fg.AddRect(plot->AxesRect.Min, plot->AxesRect.Max, IM_COL32(0,255,128,255));
        if (show_axis_rects) {
            for (int i = 0; i < ImAxis_COUNT; ++i) {
                if (plot->Axes[i].Enabled)
                    fg.AddRect(plot->Axes[i].HoverRect.Min, plot->Axes[i].HoverRect.Max, IM_COL32(0,255,0,255));
            }
        }
        if (show_legend_rects && plot->Items.GetLegendCount() > 0) {
            fg.AddRect(plot->Items.Legend.Rect.Min, plot->Items.Legend.Rect.Max, IM_COL32(255,192,0,255));
            fg.AddRect(plot->Items.Legend.RectClamped.Min, plot->Items.Legend.RectClamped.Max, IM_COL32(255,128,0,255));
        }
    }
    for (int p = 0; p < n_subplots; ++p) {
        ImPlotSubplot* subplot = gp.Subplots.GetByIndex(p);
        if (show_subplot_frame_rects)
            fg.AddRect(subplot->FrameRect.Min, subplot->FrameRect.Max, IM_COL32(255,0,0,255));
        if (show_subplot_grid_rects)
            fg.AddRect(subplot->GridRect.Min, subplot->GridRect.Max, IM_COL32(0,0,255,255));
        if (show_legend_rects && subplot->Items.GetLegendCount() > 0) {
            fg.AddRect(subplot->Items.Legend.Rect.Min, subplot->Items.Legend.Rect.Max, IM_COL32(255,192,0,255));
            fg.AddRect(subplot->Items.Legend.RectClamped.Min, subplot->Items.Legend.RectClamped.Max, IM_COL32(255,128,0,255));
        }
    }
    if (ImGui::TreeNode("Plots","Plots (%d)", n_plots)) {
        for (int p = 0; p < n_plots; ++p) {
            // plot
            ImPlotPlot& plot = *gp.Plots.GetByIndex(p);
            ImGui::PushID(p);
            if (ImGui::TreeNode("Plot", "Plot [0x%08X]", plot.ID)) {
                int n_items = plot.Items.GetItemCount();
                if (ImGui::TreeNode("Items", "Items (%d)", n_items)) {
                    for (int i = 0; i < n_items; ++i) {
                        ImPlotItem* item = plot.Items.GetItemByIndex(i);
                        ImGui::PushID(i);
                        if (ImGui::TreeNode("Item", "Item [0x%08X]", item->ID)) {
                            ImGui::Bullet(); ImGui::Checkbox("Show", &item->Show);
                            ImGui::Bullet();
                            ImVec4 temp = ImGui::ColorConvertU32ToFloat4(item->Color);
                            if (ImGui::ColorEdit4("Color",&temp.x, ImGuiColorEditFlags_NoInputs))
                                item->Color = ImGui::ColorConvertFloat4ToU32(temp);

                            ImGui::BulletText("NameOffset: %d",item->NameOffset);
                            ImGui::BulletText("Name: %s", item->NameOffset != -1 ? plot.Items.Legend.Labels.Buf.Data + item->NameOffset : "N/A");
                            ImGui::BulletText("Hovered: %s",item->LegendHovered ? "true" : "false");
                            ImGui::TreePop();
                        }
                        ImGui::PopID();
                    }
                    ImGui::TreePop();
                }
                char buff[16];
                for (int i = 0; i < IMPLOT_NUM_X_AXES; ++i) {
                    ImFormatString(buff,16,"X-Axis %d", i+1);
                    if (plot.XAxis(i).Enabled && ImGui::TreeNode(buff, "X-Axis %d [0x%08X]", i+1, plot.XAxis(i).ID)) {
                        ShowAxisMetrics(plot, plot.XAxis(i));
                        ImGui::TreePop();
                    }
                }
                for (int i = 0; i < IMPLOT_NUM_Y_AXES; ++i) {
                    ImFormatString(buff,16,"Y-Axis %d", i+1);
                    if (plot.YAxis(i).Enabled && ImGui::TreeNode(buff, "Y-Axis %d [0x%08X]", i+1, plot.YAxis(i).ID)) {
                        ShowAxisMetrics(plot, plot.YAxis(i));
                        ImGui::TreePop();
                    }
                }
                ImGui::BulletText("Title: %s", plot.HasTitle() ? plot.GetTitle() : "none");
                ImGui::BulletText("Flags: 0x%08X", plot.Flags);
                ImGui::BulletText("Initialized: %s", plot.Initialized ? "true" : "false");
                ImGui::BulletText("Selecting: %s", plot.Selecting ? "true" : "false");
                ImGui::BulletText("Selected: %s", plot.Selected ? "true" : "false");
                ImGui::BulletText("Hovered: %s", plot.Hovered ? "true" : "false");
                ImGui::BulletText("Held: %s", plot.Held ? "true" : "false");
                ImGui::BulletText("LegendHovered: %s", plot.Items.Legend.Hovered ? "true" : "false");
                ImGui::BulletText("ContextLocked: %s", plot.ContextLocked ? "true" : "false");
                ImGui::TreePop();
            }
            ImGui::PopID();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Subplots","Subplots (%d)", n_subplots)) {
        for (int p = 0; p < n_subplots; ++p) {
            // plot
            ImPlotSubplot& plot = *gp.Subplots.GetByIndex(p);
            ImGui::PushID(p);
            if (ImGui::TreeNode("Subplot", "Subplot [0x%08X]", plot.ID)) {
                int n_items = plot.Items.GetItemCount();
                if (ImGui::TreeNode("Items", "Items (%d)", n_items)) {
                    for (int i = 0; i < n_items; ++i) {
                        ImPlotItem* item = plot.Items.GetItemByIndex(i);
                        ImGui::PushID(i);
                        if (ImGui::TreeNode("Item", "Item [0x%08X]", item->ID)) {
                            ImGui::Bullet(); ImGui::Checkbox("Show", &item->Show);
                            ImGui::Bullet();
                            ImVec4 temp = ImGui::ColorConvertU32ToFloat4(item->Color);
                            if (ImGui::ColorEdit4("Color",&temp.x, ImGuiColorEditFlags_NoInputs))
                                item->Color = ImGui::ColorConvertFloat4ToU32(temp);

                            ImGui::BulletText("NameOffset: %d",item->NameOffset);
                            ImGui::BulletText("Name: %s", item->NameOffset != -1 ? plot.Items.Legend.Labels.Buf.Data + item->NameOffset : "N/A");
                            ImGui::BulletText("Hovered: %s",item->LegendHovered ? "true" : "false");
                            ImGui::TreePop();
                        }
                        ImGui::PopID();
                    }
                    ImGui::TreePop();
                }
                ImGui::BulletText("Flags: 0x%08X", plot.Flags);
                ImGui::BulletText("FrameHovered: %s", plot.FrameHovered ? "true" : "false");
                ImGui::BulletText("LegendHovered: %s", plot.Items.Legend.Hovered ? "true" : "false");
                ImGui::TreePop();
            }
            ImGui::PopID();
        }
        ImGui::TreePop();
    }
    if (ImGui::TreeNode("Colormaps")) {
        ImGui::BulletText("Colormaps:  %d", gp.ColormapData.Count);
        ImGui::BulletText("Memory: %d bytes", gp.ColormapData.Tables.Size * 4);
        if (ImGui::TreeNode("Data")) {
            for (int m = 0; m < gp.ColormapData.Count; ++m) {
                if (ImGui::TreeNode(gp.ColormapData.GetName(m))) {
                    int count = gp.ColormapData.GetKeyCount(m);
                    int size = gp.ColormapData.GetTableSize(m);
                    bool qual = gp.ColormapData.IsQual(m);
                    ImGui::BulletText("Qualitative: %s", qual ? "true" : "false");
                    ImGui::BulletText("Key Count: %d", count);
                    ImGui::BulletText("Table Size: %d", size);
                    ImGui::Indent();

                    static float t = 0.5;
                    ImVec4 samp;
                    float wid = 32 * 10 - ImGui::GetFrameHeight() - ImGui::GetStyle().ItemSpacing.x;
                    ImGui::SetNextItemWidth(wid);
                    ImPlot::ColormapSlider("##Sample",&t,&samp,"%.3f",m);
                    ImGui::SameLine();
                    ImGui::ColorButton("Sampler",samp);
                    ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0,0,0,0));
                    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
                    for (int c = 0; c < size; ++c) {
                        ImVec4 col = ImGui::ColorConvertU32ToFloat4(gp.ColormapData.GetTableColor(m,c));
                        ImGui::PushID(m*1000+c);
                        ImGui::ColorButton("",col,0,ImVec2(10,10));
                        ImGui::PopID();
                        if ((c + 1) % 32 != 0 && c != size - 1)
                            ImGui::SameLine();
                    }
                    ImGui::PopStyleVar();
                    ImGui::PopStyleColor();
                    ImGui::Unindent();
                    ImGui::TreePop();
                }
            }
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }
    ImGui::End();
}

bool ShowDatePicker(const char* id, int* level, ImPlotTime* t, const ImPlotTime* t1, const ImPlotTime* t2) {

    ImGui::PushID(id);
    ImGui::BeginGroup();

    ImGuiStyle& style = ImGui::GetStyle();
    ImVec4 col_txt    = style.Colors[ImGuiCol_Text];
    ImVec4 col_dis    = style.Colors[ImGuiCol_TextDisabled];
    ImVec4 col_btn    = style.Colors[ImGuiCol_Button];
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0,0,0,0));
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));

    const float ht    = ImGui::GetFrameHeight();
    ImVec2 cell_size(ht*1.25f,ht);
    char buff[32];
    bool clk = false;
    tm& Tm = GImPlot->Tm;

    const int min_yr = 1970;
    const int max_yr = 2999;

    // t1 parts
    int t1_mo = 0; int t1_md = 0; int t1_yr = 0;
    if (t1 != nullptr) {
        GetTime(*t1,&Tm);
        t1_mo = Tm.tm_mon;
        t1_md = Tm.tm_mday;
        t1_yr = Tm.tm_year + 1900;
    }

     // t2 parts
    int t2_mo = 0; int t2_md = 0; int t2_yr = 0;
    if (t2 != nullptr) {
        GetTime(*t2,&Tm);
        t2_mo = Tm.tm_mon;
        t2_md = Tm.tm_mday;
        t2_yr = Tm.tm_year + 1900;
    }

    // day widget
    if (*level == 0) {
        *t = FloorTime(*t, ImPlotTimeUnit_Day);
        GetTime(*t, &Tm);
        const int this_year = Tm.tm_year + 1900;
        const int last_year = this_year - 1;
        const int next_year = this_year + 1;
        const int this_mon  = Tm.tm_mon;
        const int last_mon  = this_mon == 0 ? 11 : this_mon - 1;
        const int next_mon  = this_mon == 11 ? 0 : this_mon + 1;
        const int days_this_mo = GetDaysInMonth(this_year, this_mon);
        const int days_last_mo = GetDaysInMonth(this_mon == 0 ? last_year : this_year, last_mon);
        ImPlotTime t_first_mo = FloorTime(*t,ImPlotTimeUnit_Mo);
        GetTime(t_first_mo,&Tm);
        const int first_wd = Tm.tm_wday;
        // month year
        ImFormatString(buff, 32, "%s %d", MONTH_NAMES[this_mon], this_year);
        if (ImGui::Button(buff))
            *level = 1;
        ImGui::SameLine(5*cell_size.x);
        BeginDisabledControls(this_year <= min_yr && this_mon == 0);
        if (ImGui::ArrowButtonEx("##Up",ImGuiDir_Up,cell_size))
            *t = AddTime(*t, ImPlotTimeUnit_Mo, -1);
        EndDisabledControls(this_year <= min_yr && this_mon == 0);
        ImGui::SameLine();
        BeginDisabledControls(this_year >= max_yr && this_mon == 11);
        if (ImGui::ArrowButtonEx("##Down",ImGuiDir_Down,cell_size))
            *t = AddTime(*t, ImPlotTimeUnit_Mo, 1);
        EndDisabledControls(this_year >= max_yr && this_mon == 11);
        // render weekday abbreviations
        ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
        for (int i = 0; i < 7; ++i) {
            ImGui::Button(WD_ABRVS[i],cell_size);
            if (i != 6) { ImGui::SameLine(); }
        }
        ImGui::PopItemFlag();
        // 0 = last mo, 1 = this mo, 2 = next mo
        int mo = first_wd > 0 ? 0 : 1;
        int day = mo == 1 ? 1 : days_last_mo - first_wd + 1;
        for (int i = 0; i < 6; ++i) {
            for (int j = 0; j < 7; ++j) {
                if (mo == 0 && day > days_last_mo) {
                    mo = 1;
                    day = 1;
                }
                else if (mo == 1 && day > days_this_mo) {
                    mo = 2;
                    day = 1;
                }
                const int now_yr = (mo == 0 && this_mon == 0) ? last_year : ((mo == 2 && this_mon == 11) ? next_year : this_year);
                const int now_mo = mo == 0 ? last_mon : (mo == 1 ? this_mon : next_mon);
                const int now_md = day;

                const bool off_mo   = mo == 0 || mo == 2;
                const bool t1_or_t2 = (t1 != nullptr && t1_mo == now_mo && t1_yr == now_yr && t1_md == now_md) ||
                                      (t2 != nullptr && t2_mo == now_mo && t2_yr == now_yr && t2_md == now_md);

                if (off_mo)
                    ImGui::PushStyleColor(ImGuiCol_Text, col_dis);
                if (t1_or_t2) {
                    ImGui::PushStyleColor(ImGuiCol_Button, col_btn);
                    ImGui::PushStyleColor(ImGuiCol_Text, col_txt);
                }
                ImGui::PushID(i*7+j);
                ImFormatString(buff,32,"%d",day);
                if (now_yr == min_yr-1 || now_yr == max_yr+1) {
                    ImGui::Dummy(cell_size);
                }
                else if (ImGui::Button(buff,cell_size) && !clk) {
                    *t = MakeTime(now_yr, now_mo, now_md);
                    clk = true;
                }
                ImGui::PopID();
                if (t1_or_t2)
                    ImGui::PopStyleColor(2);
                if (off_mo)
                    ImGui::PopStyleColor();
                if (j != 6)
                    ImGui::SameLine();
                day++;
            }
        }
    }
    // month widget
    else if (*level == 1) {
        *t = FloorTime(*t, ImPlotTimeUnit_Mo);
        GetTime(*t, &Tm);
        int this_yr  = Tm.tm_year + 1900;
        ImFormatString(buff, 32, "%d", this_yr);
        if (ImGui::Button(buff))
            *level = 2;
        BeginDisabledControls(this_yr <= min_yr);
        ImGui::SameLine(5*cell_size.x);
        if (ImGui::ArrowButtonEx("##Up",ImGuiDir_Up,cell_size))
            *t = AddTime(*t, ImPlotTimeUnit_Yr, -1);
        EndDisabledControls(this_yr <= min_yr);
        ImGui::SameLine();
        BeginDisabledControls(this_yr >= max_yr);
        if (ImGui::ArrowButtonEx("##Down",ImGuiDir_Down,cell_size))
            *t = AddTime(*t, ImPlotTimeUnit_Yr, 1);
        EndDisabledControls(this_yr >= max_yr);
        // ImGui::Dummy(cell_size);
        cell_size.x *= 7.0f/4.0f;
        cell_size.y *= 7.0f/3.0f;
        int mo = 0;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 4; ++j) {
                const bool t1_or_t2 = (t1 != nullptr && t1_yr == this_yr && t1_mo == mo) ||
                                      (t2 != nullptr && t2_yr == this_yr && t2_mo == mo);
                if (t1_or_t2)
                    ImGui::PushStyleColor(ImGuiCol_Button, col_btn);
                if (ImGui::Button(MONTH_ABRVS[mo],cell_size) && !clk) {
                    *t = MakeTime(this_yr, mo);
                    *level = 0;
                }
                if (t1_or_t2)
                    ImGui::PopStyleColor();
                if (j != 3)
                    ImGui::SameLine();
                mo++;
            }
        }
    }
    else if (*level == 2) {
        *t = FloorTime(*t, ImPlotTimeUnit_Yr);
        int this_yr = GetYear(*t);
        int yr = this_yr  - this_yr % 20;
        ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
        ImFormatString(buff,32,"%d-%d",yr,yr+19);
        ImGui::Button(buff);
        ImGui::PopItemFlag();
        ImGui::SameLine(5*cell_size.x);
        BeginDisabledControls(yr <= min_yr);
        if (ImGui::ArrowButtonEx("##Up",ImGuiDir_Up,cell_size))
            *t = MakeTime(yr-20);
        EndDisabledControls(yr <= min_yr);
        ImGui::SameLine();
        BeginDisabledControls(yr + 20 >= max_yr);
        if (ImGui::ArrowButtonEx("##Down",ImGuiDir_Down,cell_size))
            *t = MakeTime(yr+20);
        EndDisabledControls(yr+ 20 >= max_yr);
        // ImGui::Dummy(cell_size);
        cell_size.x *= 7.0f/4.0f;
        cell_size.y *= 7.0f/5.0f;
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 4; ++j) {
                const bool t1_or_t2 = (t1 != nullptr && t1_yr == yr) || (t2 != nullptr && t2_yr == yr);
                if (t1_or_t2)
                    ImGui::PushStyleColor(ImGuiCol_Button, col_btn);
                ImFormatString(buff,32,"%d",yr);
                if (yr<1970||yr>3000) {
                    ImGui::Dummy(cell_size);
                }
                else if (ImGui::Button(buff,cell_size)) {
                    *t = MakeTime(yr);
                    *level = 1;
                }
                if (t1_or_t2)
                    ImGui::PopStyleColor();
                if (j != 3)
                    ImGui::SameLine();
                yr++;
            }
        }
    }
    ImGui::PopStyleVar();
    ImGui::PopStyleColor();
    ImGui::EndGroup();
    ImGui::PopID();
    return clk;
}

bool ShowTimePicker(const char* id, ImPlotTime* t) {
    ImPlotContext& gp = *GImPlot;
    ImGui::PushID(id);
    tm& Tm = gp.Tm;
    GetTime(*t,&Tm);

    static const char* nums[] = { "00","01","02","03","04","05","06","07","08","09",
                                  "10","11","12","13","14","15","16","17","18","19",
                                  "20","21","22","23","24","25","26","27","28","29",
                                  "30","31","32","33","34","35","36","37","38","39",
                                  "40","41","42","43","44","45","46","47","48","49",
                                  "50","51","52","53","54","55","56","57","58","59"};

    static const char* am_pm[] = {"am","pm"};

    bool hour24 = gp.Style.Use24HourClock;

    int hr  = hour24 ? Tm.tm_hour : ((Tm.tm_hour == 0 || Tm.tm_hour == 12) ? 12 : Tm.tm_hour % 12);
    int min = Tm.tm_min;
    int sec = Tm.tm_sec;
    int ap  = Tm.tm_hour < 12 ? 0 : 1;

    bool changed = false;

    ImVec2 spacing = ImGui::GetStyle().ItemSpacing;
    spacing.x = 0;
    float width    = ImGui::CalcTextSize("888").x;
    float height   = ImGui::GetFrameHeight();

    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, spacing);
    ImGui::PushStyleVar(ImGuiStyleVar_ScrollbarSize,2.0f);
    ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0,0,0,0));
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0,0,0,0));
    ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImGui::GetStyleColorVec4(ImGuiCol_ButtonHovered));

    ImGui::SetNextItemWidth(width);
    if (ImGui::BeginCombo("##hr",nums[hr],ImGuiComboFlags_NoArrowButton)) {
        const int ia = hour24 ? 0 : 1;
        const int ib = hour24 ? 24 : 13;
        for (int i = ia; i < ib; ++i) {
            if (ImGui::Selectable(nums[i],i==hr)) {
                hr = i;
                changed = true;
            }
        }
        ImGui::EndCombo();
    }
    ImGui::SameLine();
    ImGui::Text(":");
    ImGui::SameLine();
    ImGui::SetNextItemWidth(width);
    if (ImGui::BeginCombo("##min",nums[min],ImGuiComboFlags_NoArrowButton)) {
        for (int i = 0; i < 60; ++i) {
            if (ImGui::Selectable(nums[i],i==min)) {
                min = i;
                changed = true;
            }
        }
        ImGui::EndCombo();
    }
    ImGui::SameLine();
    ImGui::Text(":");
    ImGui::SameLine();
    ImGui::SetNextItemWidth(width);
    if (ImGui::BeginCombo("##sec",nums[sec],ImGuiComboFlags_NoArrowButton)) {
        for (int i = 0; i < 60; ++i) {
            if (ImGui::Selectable(nums[i],i==sec)) {
                sec = i;
                changed = true;
            }
        }
        ImGui::EndCombo();
    }
    if (!hour24) {
        ImGui::SameLine();
        if (ImGui::Button(am_pm[ap],ImVec2(0,height))) {
            ap = 1 - ap;
            changed = true;
        }
    }

    ImGui::PopStyleColor(3);
    ImGui::PopStyleVar(2);
    ImGui::PopID();

    if (changed) {
        if (!hour24)
            hr = hr % 12 + ap * 12;
        Tm.tm_hour = hr;
        Tm.tm_min  = min;
        Tm.tm_sec  = sec;
        *t = MkTime(&Tm);
    }

    return changed;
}

void StyleColorsAuto(ImPlotStyle* dst) {
    ImPlotStyle* style              = dst ? dst : &ImPlot::GetStyle();
    ImVec4* colors                  = style->Colors;

    style->MinorAlpha               = 0.25f;

    colors[ImPlotCol_Line]          = IMPLOT_AUTO_COL;
    colors[ImPlotCol_Fill]          = IMPLOT_AUTO_COL;
    colors[ImPlotCol_MarkerOutline] = IMPLOT_AUTO_COL;
    colors[ImPlotCol_MarkerFill]    = IMPLOT_AUTO_COL;
    colors[ImPlotCol_ErrorBar]      = IMPLOT_AUTO_COL;
    colors[ImPlotCol_FrameBg]       = IMPLOT_AUTO_COL;
    colors[ImPlotCol_PlotBg]        = IMPLOT_AUTO_COL;
    colors[ImPlotCol_PlotBorder]    = IMPLOT_AUTO_COL;
    colors[ImPlotCol_LegendBg]      = IMPLOT_AUTO_COL;
    colors[ImPlotCol_LegendBorder]  = IMPLOT_AUTO_COL;
    colors[ImPlotCol_LegendText]    = IMPLOT_AUTO_COL;
    colors[ImPlotCol_TitleText]     = IMPLOT_AUTO_COL;
    colors[ImPlotCol_InlayText]     = IMPLOT_AUTO_COL;
    colors[ImPlotCol_PlotBorder]    = IMPLOT_AUTO_COL;
    colors[ImPlotCol_AxisText]      = IMPLOT_AUTO_COL;
    colors[ImPlotCol_AxisGrid]      = IMPLOT_AUTO_COL;
    colors[ImPlotCol_AxisTick]      = IMPLOT_AUTO_COL;
    colors[ImPlotCol_AxisBg]        = IMPLOT_AUTO_COL;
    colors[ImPlotCol_AxisBgHovered] = IMPLOT_AUTO_COL;
    colors[ImPlotCol_AxisBgActive]  = IMPLOT_AUTO_COL;
    colors[ImPlotCol_Selection]     = IMPLOT_AUTO_COL;
    colors[ImPlotCol_Crosshairs]    = IMPLOT_AUTO_COL;
}

void StyleColorsClassic(ImPlotStyle* dst) {
    ImPlotStyle* style              = dst ? dst : &ImPlot::GetStyle();
    ImVec4* colors                  = style->Colors;

    style->MinorAlpha               = 0.5f;

    colors[ImPlotCol_Line]          = IMPLOT_AUTO_COL;
    colors[ImPlotCol_Fill]          = IMPLOT_AUTO_COL;
    colors[ImPlotCol_MarkerOutline] = IMPLOT_AUTO_COL;
    colors[ImPlotCol_MarkerFill]    = IMPLOT_AUTO_COL;
    colors[ImPlotCol_ErrorBar]      = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImPlotCol_FrameBg]       = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);
    colors[ImPlotCol_PlotBg]        = ImVec4(0.00f, 0.00f, 0.00f, 0.35f);
    colors[ImPlotCol_PlotBorder]    = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);
    colors[ImPlotCol_LegendBg]      = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);
    colors[ImPlotCol_LegendBorder]  = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);
    colors[ImPlotCol_LegendText]    = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImPlotCol_TitleText]     = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImPlotCol_InlayText]     = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImPlotCol_AxisText]      = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImPlotCol_AxisGrid]      = ImVec4(0.90f, 0.90f, 0.90f, 0.25f);
    colors[ImPlotCol_AxisTick]      = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_AxisBg]        = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_AxisBgHovered] = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_AxisBgActive]  = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_Selection]     = ImVec4(0.97f, 0.97f, 0.39f, 1.00f);
    colors[ImPlotCol_Crosshairs]    = ImVec4(0.50f, 0.50f, 0.50f, 0.75f);
}

void StyleColorsDark(ImPlotStyle* dst) {
    ImPlotStyle* style              = dst ? dst : &ImPlot::GetStyle();
    ImVec4* colors                  = style->Colors;

    style->MinorAlpha               = 0.25f;

    colors[ImPlotCol_Line]          = IMPLOT_AUTO_COL;
    colors[ImPlotCol_Fill]          = IMPLOT_AUTO_COL;
    colors[ImPlotCol_MarkerOutline] = IMPLOT_AUTO_COL;
    colors[ImPlotCol_MarkerFill]    = IMPLOT_AUTO_COL;
    colors[ImPlotCol_ErrorBar]      = IMPLOT_AUTO_COL;
    colors[ImPlotCol_FrameBg]       = ImVec4(1.00f, 1.00f, 1.00f, 0.07f);
    colors[ImPlotCol_PlotBg]        = ImVec4(0.00f, 0.00f, 0.00f, 0.50f);
    colors[ImPlotCol_PlotBorder]    = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
    colors[ImPlotCol_LegendBg]      = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
    colors[ImPlotCol_LegendBorder]  = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
    colors[ImPlotCol_LegendText]    = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImPlotCol_TitleText]     = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImPlotCol_InlayText]     = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImPlotCol_AxisText]      = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImPlotCol_AxisGrid]      = ImVec4(1.00f, 1.00f, 1.00f, 0.25f);
    colors[ImPlotCol_AxisTick]      = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_AxisBg]        = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_AxisBgHovered] = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_AxisBgActive]  = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_Selection]     = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    colors[ImPlotCol_Crosshairs]    = ImVec4(1.00f, 1.00f, 1.00f, 0.50f);
}

void StyleColorsLight(ImPlotStyle* dst) {
    ImPlotStyle* style              = dst ? dst : &ImPlot::GetStyle();
    ImVec4* colors                  = style->Colors;

    style->MinorAlpha               = 1.0f;

    colors[ImPlotCol_Line]          = IMPLOT_AUTO_COL;
    colors[ImPlotCol_Fill]          = IMPLOT_AUTO_COL;
    colors[ImPlotCol_MarkerOutline] = IMPLOT_AUTO_COL;
    colors[ImPlotCol_MarkerFill]    = IMPLOT_AUTO_COL;
    colors[ImPlotCol_ErrorBar]      = IMPLOT_AUTO_COL;
    colors[ImPlotCol_FrameBg]       = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImPlotCol_PlotBg]        = ImVec4(0.42f, 0.57f, 1.00f, 0.13f);
    colors[ImPlotCol_PlotBorder]    = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImPlotCol_LegendBg]      = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);
    colors[ImPlotCol_LegendBorder]  = ImVec4(0.82f, 0.82f, 0.82f, 0.80f);
    colors[ImPlotCol_LegendText]    = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImPlotCol_TitleText]     = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImPlotCol_InlayText]     = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImPlotCol_AxisText]      = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImPlotCol_AxisGrid]      = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImPlotCol_AxisTick]      = ImVec4(0.00f, 0.00f, 0.00f, 0.25f);
    colors[ImPlotCol_AxisBg]        = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_AxisBgHovered] = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_AxisBgActive]  = IMPLOT_AUTO_COL; // TODO
    colors[ImPlotCol_Selection]     = ImVec4(0.82f, 0.64f, 0.03f, 1.00f);
    colors[ImPlotCol_Crosshairs]    = ImVec4(0.00f, 0.00f, 0.00f, 0.50f);
}

//-----------------------------------------------------------------------------
// [SECTION] Obsolete Functions/Types
//-----------------------------------------------------------------------------

#ifndef IMPLOT_DISABLE_OBSOLETE_FUNCTIONS

bool BeginPlot(const char* title, const char* x_label, const char* y1_label, const ImVec2& size,
               ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y1_flags, ImPlotAxisFlags y2_flags, ImPlotAxisFlags y3_flags,
               const char* y2_label, const char* y3_label)
{
    if (!BeginPlot(title, size, flags))
        return false;
    SetupAxis(ImAxis_X1, x_label, x_flags);
    SetupAxis(ImAxis_Y1, y1_label, y1_flags);
    if (ImHasFlag(flags, ImPlotFlags_YAxis2))
        SetupAxis(ImAxis_Y2, y2_label, y2_flags);
    if (ImHasFlag(flags, ImPlotFlags_YAxis3))
        SetupAxis(ImAxis_Y3, y3_label, y3_flags);
    return true;
}

#endif

}  // namespace ImPlot

#endif // #ifndef IMGUI_DISABLE
// MIT License

// Copyright (c) 2023 Evan Pezent

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// ImPlot v0.17

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "implot.h"
#ifndef IMGUI_DISABLE
#include "implot_internal.h"

//-----------------------------------------------------------------------------
// [SECTION] Macros and Defines
//-----------------------------------------------------------------------------

#define SQRT_1_2 0.70710678118f
#define SQRT_3_2 0.86602540378f

#ifndef IMPLOT_NO_FORCE_INLINE
    #ifdef _MSC_VER
        #define IMPLOT_INLINE __forceinline
    #elif defined(__GNUC__)
        #define IMPLOT_INLINE inline __attribute__((__always_inline__))
    #elif defined(__CLANG__)
        #if __has_attribute(__always_inline__)
            #define IMPLOT_INLINE inline __attribute__((__always_inline__))
        #else
            #define IMPLOT_INLINE inline
        #endif
    #else
        #define IMPLOT_INLINE inline
    #endif
#else
    #define IMPLOT_INLINE inline
#endif

#if defined __SSE__ || defined __x86_64__ || defined _M_X64
#ifndef IMGUI_ENABLE_SSE
#include <immintrin.h>
#endif
static IMPLOT_INLINE float  ImInvSqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }
#else
static IMPLOT_INLINE float  ImInvSqrt(float x) { return 1.0f / sqrtf(x); }
#endif

#define IMPLOT_NORMALIZE2F_OVER_ZERO(VX,VY) do { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImInvSqrt(d2); VX *= inv_len; VY *= inv_len; } } while (0)

// Support for pre-1.82 versions. Users on 1.82+ can use 0 (default) flags to mean "all corners" but in order to support older versions we are more explicit.
#if (IMGUI_VERSION_NUM < 18102) && !defined(ImDrawFlags_RoundCornersAll)
#define ImDrawFlags_RoundCornersAll ImDrawCornerFlags_All
#endif

//-----------------------------------------------------------------------------
// [SECTION] Template instantiation utility
//-----------------------------------------------------------------------------

// By default, templates are instantiated for `float`, `double`, and for the following integer types, which are defined in imgui.h:
//     signed char         ImS8;   // 8-bit signed integer
//     unsigned char       ImU8;   // 8-bit unsigned integer
//     signed short        ImS16;  // 16-bit signed integer
//     unsigned short      ImU16;  // 16-bit unsigned integer
//     signed int          ImS32;  // 32-bit signed integer == int
//     unsigned int        ImU32;  // 32-bit unsigned integer
//     signed   long long  ImS64;  // 64-bit signed integer
//     unsigned long long  ImU64;  // 64-bit unsigned integer
// (note: this list does *not* include `long`, `unsigned long` and `long double`)
//
// You can customize the supported types by defining IMPLOT_CUSTOM_NUMERIC_TYPES at compile time to define your own type list.
//    As an example, you could use the compile time define given by the line below in order to support only float and double.
//        -DIMPLOT_CUSTOM_NUMERIC_TYPES="(float)(double)"
//    In order to support all known C++ types, use:
//        -DIMPLOT_CUSTOM_NUMERIC_TYPES="(signed char)(unsigned char)(signed short)(unsigned short)(signed int)(unsigned int)(signed long)(unsigned long)(signed long long)(unsigned long long)(float)(double)(long double)"

#ifdef IMPLOT_CUSTOM_NUMERIC_TYPES
    #define IMPLOT_NUMERIC_TYPES IMPLOT_CUSTOM_NUMERIC_TYPES
#else
    #define IMPLOT_NUMERIC_TYPES (ImS8)(ImU8)(ImS16)(ImU16)(ImS32)(ImU32)(ImS64)(ImU64)(float)(double)
#endif

// CALL_INSTANTIATE_FOR_NUMERIC_TYPES will duplicate the template instantion code `INSTANTIATE_MACRO(T)` on supported types.
#define _CAT(x, y) _CAT_(x, y)
#define _CAT_(x,y) x ## y
#define _INSTANTIATE_FOR_NUMERIC_TYPES(chain) _CAT(_INSTANTIATE_FOR_NUMERIC_TYPES_1 chain, _END)
#define _INSTANTIATE_FOR_NUMERIC_TYPES_1(T) INSTANTIATE_MACRO(T) _INSTANTIATE_FOR_NUMERIC_TYPES_2
#define _INSTANTIATE_FOR_NUMERIC_TYPES_2(T) INSTANTIATE_MACRO(T) _INSTANTIATE_FOR_NUMERIC_TYPES_1
#define _INSTANTIATE_FOR_NUMERIC_TYPES_1_END
#define _INSTANTIATE_FOR_NUMERIC_TYPES_2_END
#define CALL_INSTANTIATE_FOR_NUMERIC_TYPES() _INSTANTIATE_FOR_NUMERIC_TYPES(IMPLOT_NUMERIC_TYPES)

namespace ImPlot {

//-----------------------------------------------------------------------------
// [SECTION] Utils
//-----------------------------------------------------------------------------

// Calc maximum index size of ImDrawIdx
template <typename T>
struct MaxIdx { static const unsigned int Value; };
template <> const unsigned int MaxIdx<unsigned short>::Value = 65535;
template <> const unsigned int MaxIdx<unsigned int>::Value   = 4294967295;

IMPLOT_INLINE void GetLineRenderProps(const ImDrawList& draw_list, float& half_weight, ImVec2& tex_uv0, ImVec2& tex_uv1) {
    const bool aa = ImHasFlag(draw_list.Flags, ImDrawListFlags_AntiAliasedLines) &&
                    ImHasFlag(draw_list.Flags, ImDrawListFlags_AntiAliasedLinesUseTex);
    if (aa) {
        ImVec4 tex_uvs = draw_list._Data->TexUvLines[(int)(half_weight*2)];
        tex_uv0 = ImVec2(tex_uvs.x, tex_uvs.y);
        tex_uv1 = ImVec2(tex_uvs.z, tex_uvs.w);
        half_weight += 1;
    }
    else {
        tex_uv0 = tex_uv1 = draw_list._Data->TexUvWhitePixel;
    }
}

IMPLOT_INLINE void PrimLine(ImDrawList& draw_list, const ImVec2& P1, const ImVec2& P2, float half_weight, ImU32 col, const ImVec2& tex_uv0, const ImVec2 tex_uv1) {
    float dx = P2.x - P1.x;
    float dy = P2.y - P1.y;
    IMPLOT_NORMALIZE2F_OVER_ZERO(dx, dy);
    dx *= half_weight;
    dy *= half_weight;
    draw_list._VtxWritePtr[0].pos.x = P1.x + dy;
    draw_list._VtxWritePtr[0].pos.y = P1.y - dx;
    draw_list._VtxWritePtr[0].uv    = tex_uv0;
    draw_list._VtxWritePtr[0].col   = col;
    draw_list._VtxWritePtr[1].pos.x = P2.x + dy;
    draw_list._VtxWritePtr[1].pos.y = P2.y - dx;
    draw_list._VtxWritePtr[1].uv    = tex_uv0;
    draw_list._VtxWritePtr[1].col   = col;
    draw_list._VtxWritePtr[2].pos.x = P2.x - dy;
    draw_list._VtxWritePtr[2].pos.y = P2.y + dx;
    draw_list._VtxWritePtr[2].uv    = tex_uv1;
    draw_list._VtxWritePtr[2].col   = col;
    draw_list._VtxWritePtr[3].pos.x = P1.x - dy;
    draw_list._VtxWritePtr[3].pos.y = P1.y + dx;
    draw_list._VtxWritePtr[3].uv    = tex_uv1;
    draw_list._VtxWritePtr[3].col   = col;
    draw_list._VtxWritePtr += 4;
    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);
    draw_list._IdxWritePtr[3] = (ImDrawIdx)(draw_list._VtxCurrentIdx);
    draw_list._IdxWritePtr[4] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);
    draw_list._IdxWritePtr[5] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);
    draw_list._IdxWritePtr += 6;
    draw_list._VtxCurrentIdx += 4;
}

IMPLOT_INLINE void PrimRectFill(ImDrawList& draw_list, const ImVec2& Pmin, const ImVec2& Pmax, ImU32 col, const ImVec2& uv) {
    draw_list._VtxWritePtr[0].pos   = Pmin;
    draw_list._VtxWritePtr[0].uv    = uv;
    draw_list._VtxWritePtr[0].col   = col;
    draw_list._VtxWritePtr[1].pos   = Pmax;
    draw_list._VtxWritePtr[1].uv    = uv;
    draw_list._VtxWritePtr[1].col   = col;
    draw_list._VtxWritePtr[2].pos.x = Pmin.x;
    draw_list._VtxWritePtr[2].pos.y = Pmax.y;
    draw_list._VtxWritePtr[2].uv    = uv;
    draw_list._VtxWritePtr[2].col   = col;
    draw_list._VtxWritePtr[3].pos.x = Pmax.x;
    draw_list._VtxWritePtr[3].pos.y = Pmin.y;
    draw_list._VtxWritePtr[3].uv    = uv;
    draw_list._VtxWritePtr[3].col   = col;
    draw_list._VtxWritePtr += 4;
    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);
    draw_list._IdxWritePtr[3] = (ImDrawIdx)(draw_list._VtxCurrentIdx);
    draw_list._IdxWritePtr[4] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);
    draw_list._IdxWritePtr[5] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);
    draw_list._IdxWritePtr += 6;
    draw_list._VtxCurrentIdx += 4;
}

IMPLOT_INLINE void PrimRectLine(ImDrawList& draw_list, const ImVec2& Pmin, const ImVec2& Pmax, float weight, ImU32 col, const ImVec2& uv) {

    draw_list._VtxWritePtr[0].pos.x = Pmin.x;
    draw_list._VtxWritePtr[0].pos.y = Pmin.y;
    draw_list._VtxWritePtr[0].uv    = uv;
    draw_list._VtxWritePtr[0].col   = col;

    draw_list._VtxWritePtr[1].pos.x = Pmin.x;
    draw_list._VtxWritePtr[1].pos.y = Pmax.y;
    draw_list._VtxWritePtr[1].uv    = uv;
    draw_list._VtxWritePtr[1].col   = col;

    draw_list._VtxWritePtr[2].pos.x = Pmax.x;
    draw_list._VtxWritePtr[2].pos.y = Pmax.y;
    draw_list._VtxWritePtr[2].uv    = uv;
    draw_list._VtxWritePtr[2].col   = col;

    draw_list._VtxWritePtr[3].pos.x = Pmax.x;
    draw_list._VtxWritePtr[3].pos.y = Pmin.y;
    draw_list._VtxWritePtr[3].uv    = uv;
    draw_list._VtxWritePtr[3].col   = col;

    draw_list._VtxWritePtr[4].pos.x = Pmin.x + weight;
    draw_list._VtxWritePtr[4].pos.y = Pmin.y + weight;
    draw_list._VtxWritePtr[4].uv    = uv;
    draw_list._VtxWritePtr[4].col   = col;

    draw_list._VtxWritePtr[5].pos.x = Pmin.x + weight;
    draw_list._VtxWritePtr[5].pos.y = Pmax.y - weight;
    draw_list._VtxWritePtr[5].uv    = uv;
    draw_list._VtxWritePtr[5].col   = col;

    draw_list._VtxWritePtr[6].pos.x = Pmax.x - weight;
    draw_list._VtxWritePtr[6].pos.y = Pmax.y - weight;
    draw_list._VtxWritePtr[6].uv    = uv;
    draw_list._VtxWritePtr[6].col   = col;

    draw_list._VtxWritePtr[7].pos.x = Pmax.x - weight;
    draw_list._VtxWritePtr[7].pos.y = Pmin.y + weight;
    draw_list._VtxWritePtr[7].uv    = uv;
    draw_list._VtxWritePtr[7].col   = col;

    draw_list._VtxWritePtr += 8;

    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 0);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 5);
    draw_list._IdxWritePtr += 3;

    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 0);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 5);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 4);
    draw_list._IdxWritePtr += 3;

    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 6);
    draw_list._IdxWritePtr += 3;

    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 6);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 5);
    draw_list._IdxWritePtr += 3;

    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 7);
    draw_list._IdxWritePtr += 3;

    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 2);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 7);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 6);
    draw_list._IdxWritePtr += 3;

    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 0);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 4);
    draw_list._IdxWritePtr += 3;

    draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);
    draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 4);
    draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 7);
    draw_list._IdxWritePtr += 3;

    draw_list._VtxCurrentIdx += 8;
}


//-----------------------------------------------------------------------------
// [SECTION] Item Utils
//-----------------------------------------------------------------------------

ImPlotItem* RegisterOrGetItem(const char* label_id, ImPlotItemFlags flags, bool* just_created) {
    ImPlotContext& gp = *GImPlot;
    ImPlotItemGroup& Items = *gp.CurrentItems;
    ImGuiID id = Items.GetItemID(label_id);
    if (just_created != nullptr)
        *just_created = Items.GetItem(id) == nullptr;
    ImPlotItem* item = Items.GetOrAddItem(id);
    if (item->SeenThisFrame)
        return item;
    item->SeenThisFrame = true;
    int idx = Items.GetItemIndex(item);
    item->ID = id;
    if (!ImHasFlag(flags, ImPlotItemFlags_NoLegend) && ImGui::FindRenderedTextEnd(label_id, nullptr) != label_id) {
        Items.Legend.Indices.push_back(idx);
        item->NameOffset = Items.Legend.Labels.size();
        Items.Legend.Labels.append(label_id, label_id + strlen(label_id) + 1);
    }
    else {
        item->Show = true;
    }
    return item;
}

ImPlotItem* GetItem(const char* label_id) {
    ImPlotContext& gp = *GImPlot;
    return gp.CurrentItems->GetItem(label_id);
}

bool IsItemHidden(const char* label_id) {
    ImPlotItem* item = GetItem(label_id);
    return item != nullptr && !item->Show;
}

ImPlotItem* GetCurrentItem() {
    ImPlotContext& gp = *GImPlot;
    return gp.CurrentItem;
}

void SetNextLineStyle(const ImVec4& col, float weight) {
    ImPlotContext& gp = *GImPlot;
    gp.NextItemData.Colors[ImPlotCol_Line] = col;
    gp.NextItemData.LineWeight             = weight;
}

void SetNextFillStyle(const ImVec4& col, float alpha) {
    ImPlotContext& gp = *GImPlot;
    gp.NextItemData.Colors[ImPlotCol_Fill] = col;
    gp.NextItemData.FillAlpha              = alpha;
}

void SetNextMarkerStyle(ImPlotMarker marker, float size, const ImVec4& fill, float weight, const ImVec4& outline) {
    ImPlotContext& gp = *GImPlot;
    gp.NextItemData.Marker                          = marker;
    gp.NextItemData.Colors[ImPlotCol_MarkerFill]    = fill;
    gp.NextItemData.MarkerSize                      = size;
    gp.NextItemData.Colors[ImPlotCol_MarkerOutline] = outline;
    gp.NextItemData.MarkerWeight                    = weight;
}

void SetNextErrorBarStyle(const ImVec4& col, float size, float weight) {
    ImPlotContext& gp = *GImPlot;
    gp.NextItemData.Colors[ImPlotCol_ErrorBar] = col;
    gp.NextItemData.ErrorBarSize               = size;
    gp.NextItemData.ErrorBarWeight             = weight;
}

ImVec4 GetLastItemColor() {
    ImPlotContext& gp = *GImPlot;
    if (gp.PreviousItem)
        return ImGui::ColorConvertU32ToFloat4(gp.PreviousItem->Color);
    return ImVec4();
}

void BustItemCache() {
    ImPlotContext& gp = *GImPlot;
    for (int p = 0; p < gp.Plots.GetBufSize(); ++p) {
        ImPlotPlot& plot = *gp.Plots.GetByIndex(p);
        plot.Items.Reset();
    }
    for (int p = 0; p < gp.Subplots.GetBufSize(); ++p) {
        ImPlotSubplot& subplot = *gp.Subplots.GetByIndex(p);
        subplot.Items.Reset();
    }
}

void BustColorCache(const char* plot_title_id) {
    ImPlotContext& gp = *GImPlot;
    if (plot_title_id == nullptr) {
        BustItemCache();
    }
    else {
        ImGuiID id = ImGui::GetCurrentWindow()->GetID(plot_title_id);
        ImPlotPlot* plot = gp.Plots.GetByKey(id);
        if (plot != nullptr)
            plot->Items.Reset();
        else {
            ImPlotSubplot* subplot = gp.Subplots.GetByKey(id);
            if (subplot != nullptr)
                subplot->Items.Reset();
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] BeginItem / EndItem
//-----------------------------------------------------------------------------

static const float ITEM_HIGHLIGHT_LINE_SCALE = 2.0f;
static const float ITEM_HIGHLIGHT_MARK_SCALE = 1.25f;

// Begins a new item. Returns false if the item should not be plotted.
bool BeginItem(const char* label_id, ImPlotItemFlags flags, ImPlotCol recolor_from) {
    ImPlotContext& gp = *GImPlot;
    IM_ASSERT_USER_ERROR(gp.CurrentPlot != nullptr, "PlotX() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    bool just_created;
    ImPlotItem* item = RegisterOrGetItem(label_id, flags, &just_created);
    // set current item
    gp.CurrentItem = item;
    ImPlotNextItemData& s = gp.NextItemData;
    // set/override item color
    if (recolor_from != -1) {
        if (!IsColorAuto(s.Colors[recolor_from]))
            item->Color = ImGui::ColorConvertFloat4ToU32(s.Colors[recolor_from]);
        else if (!IsColorAuto(gp.Style.Colors[recolor_from]))
            item->Color = ImGui::ColorConvertFloat4ToU32(gp.Style.Colors[recolor_from]);
        else if (just_created)
            item->Color = NextColormapColorU32();
    }
    else if (just_created) {
        item->Color = NextColormapColorU32();
    }
    // hide/show item
    if (gp.NextItemData.HasHidden) {
        if (just_created || gp.NextItemData.HiddenCond == ImGuiCond_Always)
            item->Show = !gp.NextItemData.Hidden;
    }
    if (!item->Show) {
        // reset next item data
        gp.NextItemData.Reset();
        gp.PreviousItem = item;
        gp.CurrentItem  = nullptr;
        return false;
    }
    else {
        ImVec4 item_color = ImGui::ColorConvertU32ToFloat4(item->Color);
        // stage next item colors
        s.Colors[ImPlotCol_Line]           = IsColorAuto(s.Colors[ImPlotCol_Line])          ? ( IsColorAuto(ImPlotCol_Line)           ? item_color                 : gp.Style.Colors[ImPlotCol_Line]          ) : s.Colors[ImPlotCol_Line];
        s.Colors[ImPlotCol_Fill]           = IsColorAuto(s.Colors[ImPlotCol_Fill])          ? ( IsColorAuto(ImPlotCol_Fill)           ? item_color                 : gp.Style.Colors[ImPlotCol_Fill]          ) : s.Colors[ImPlotCol_Fill];
        s.Colors[ImPlotCol_MarkerOutline]  = IsColorAuto(s.Colors[ImPlotCol_MarkerOutline]) ? ( IsColorAuto(ImPlotCol_MarkerOutline)  ? s.Colors[ImPlotCol_Line]   : gp.Style.Colors[ImPlotCol_MarkerOutline] ) : s.Colors[ImPlotCol_MarkerOutline];
        s.Colors[ImPlotCol_MarkerFill]     = IsColorAuto(s.Colors[ImPlotCol_MarkerFill])    ? ( IsColorAuto(ImPlotCol_MarkerFill)     ? s.Colors[ImPlotCol_Line]   : gp.Style.Colors[ImPlotCol_MarkerFill]    ) : s.Colors[ImPlotCol_MarkerFill];
        s.Colors[ImPlotCol_ErrorBar]       = IsColorAuto(s.Colors[ImPlotCol_ErrorBar])      ? ( GetStyleColorVec4(ImPlotCol_ErrorBar)                                                                         ) : s.Colors[ImPlotCol_ErrorBar];
        // stage next item style vars
        s.LineWeight         = s.LineWeight       < 0 ? gp.Style.LineWeight       : s.LineWeight;
        s.Marker             = s.Marker           < 0 ? gp.Style.Marker           : s.Marker;
        s.MarkerSize         = s.MarkerSize       < 0 ? gp.Style.MarkerSize       : s.MarkerSize;
        s.MarkerWeight       = s.MarkerWeight     < 0 ? gp.Style.MarkerWeight     : s.MarkerWeight;
        s.FillAlpha          = s.FillAlpha        < 0 ? gp.Style.FillAlpha        : s.FillAlpha;
        s.ErrorBarSize       = s.ErrorBarSize     < 0 ? gp.Style.ErrorBarSize     : s.ErrorBarSize;
        s.ErrorBarWeight     = s.ErrorBarWeight   < 0 ? gp.Style.ErrorBarWeight   : s.ErrorBarWeight;
        s.DigitalBitHeight   = s.DigitalBitHeight < 0 ? gp.Style.DigitalBitHeight : s.DigitalBitHeight;
        s.DigitalBitGap      = s.DigitalBitGap    < 0 ? gp.Style.DigitalBitGap    : s.DigitalBitGap;
        // apply alpha modifier(s)
        s.Colors[ImPlotCol_Fill].w       *= s.FillAlpha;
        s.Colors[ImPlotCol_MarkerFill].w *= s.FillAlpha; // TODO: this should be separate, if it at all
        // apply highlight mods
        if (item->LegendHovered) {
            if (!ImHasFlag(gp.CurrentItems->Legend.Flags, ImPlotLegendFlags_NoHighlightItem)) {
                s.LineWeight   *= ITEM_HIGHLIGHT_LINE_SCALE;
                s.MarkerSize   *= ITEM_HIGHLIGHT_MARK_SCALE;
                s.MarkerWeight *= ITEM_HIGHLIGHT_LINE_SCALE;
                // TODO: how to highlight fills?
            }
            if (!ImHasFlag(gp.CurrentItems->Legend.Flags, ImPlotLegendFlags_NoHighlightAxis)) {
                if (gp.CurrentPlot->EnabledAxesX() > 1)
                    gp.CurrentPlot->Axes[gp.CurrentPlot->CurrentX].ColorHiLi = item->Color;
                if (gp.CurrentPlot->EnabledAxesY() > 1)
                    gp.CurrentPlot->Axes[gp.CurrentPlot->CurrentY].ColorHiLi = item->Color;
            }
        }
        // set render flags
        s.RenderLine       = s.Colors[ImPlotCol_Line].w          > 0 && s.LineWeight > 0;
        s.RenderFill       = s.Colors[ImPlotCol_Fill].w          > 0;
        s.RenderMarkerFill = s.Colors[ImPlotCol_MarkerFill].w    > 0;
        s.RenderMarkerLine = s.Colors[ImPlotCol_MarkerOutline].w > 0 && s.MarkerWeight > 0;
        // push rendering clip rect
        PushPlotClipRect();
        return true;
    }
}

// Ends an item (call only if BeginItem returns true)
void EndItem() {
    ImPlotContext& gp = *GImPlot;
    // pop rendering clip rect
    PopPlotClipRect();
    // reset next item data
    gp.NextItemData.Reset();
    // set current item
    gp.PreviousItem = gp.CurrentItem;
    gp.CurrentItem  = nullptr;
}

//-----------------------------------------------------------------------------
// [SECTION] Indexers
//-----------------------------------------------------------------------------

template <typename T>
IMPLOT_INLINE T IndexData(const T* data, int idx, int count, int offset, int stride) {
    const int s = ((offset == 0) << 0) | ((stride == sizeof(T)) << 1);
    switch (s) {
        case 3 : return data[idx];
        case 2 : return data[(offset + idx) % count];
        case 1 : return *(const T*)(const void*)((const unsigned char*)data + (size_t)((idx) ) * stride);
        case 0 : return *(const T*)(const void*)((const unsigned char*)data + (size_t)((offset + idx) % count) * stride);
        default: return T(0);
    }
}

template <typename T>
struct IndexerIdx {
    IndexerIdx(const T* data, int count, int offset = 0, int stride = sizeof(T)) :
        Data(data),
        Count(count),
        Offset(count ? ImPosMod(offset, count) : 0),
        Stride(stride)
    { }
    template <typename I> IMPLOT_INLINE double operator()(I idx) const {
        return (double)IndexData(Data, idx, Count, Offset, Stride);
    }
    const T* Data;
    int Count;
    int Offset;
    int Stride;
};

template <typename _Indexer1, typename _Indexer2>
struct IndexerAdd {
    IndexerAdd(const _Indexer1& indexer1, const _Indexer2& indexer2, double scale1 = 1, double scale2 = 1)
        : Indexer1(indexer1),
          Indexer2(indexer2),
          Scale1(scale1),
          Scale2(scale2),
          Count(ImMin(Indexer1.Count, Indexer2.Count))
    { }
    template <typename I> IMPLOT_INLINE double operator()(I idx) const {
        return Scale1 * Indexer1(idx) + Scale2 * Indexer2(idx);
    }
    const _Indexer1& Indexer1;
    const _Indexer2& Indexer2;
    double Scale1;
    double Scale2;
    int Count;
};

struct IndexerLin {
    IndexerLin(double m, double b) : M(m), B(b) { }
    template <typename I> IMPLOT_INLINE double operator()(I idx) const {
        return M * idx + B;
    }
    const double M;
    const double B;
};

struct IndexerConst {
    IndexerConst(double ref) : Ref(ref) { }
    template <typename I> IMPLOT_INLINE double operator()(I) const { return Ref; }
    const double Ref;
};

//-----------------------------------------------------------------------------
// [SECTION] Getters
//-----------------------------------------------------------------------------

template <typename _IndexerX, typename _IndexerY>
struct GetterXY {
    GetterXY(_IndexerX x, _IndexerY y, int count) : IndxerX(x), IndxerY(y), Count(count) { }
    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {
        return ImPlotPoint(IndxerX(idx),IndxerY(idx));
    }
    const _IndexerX IndxerX;
    const _IndexerY IndxerY;
    const int Count;
};

/// Interprets a user's function pointer as ImPlotPoints
struct GetterFuncPtr {
    GetterFuncPtr(ImPlotGetter getter, void* data, int count) :
        Getter(getter),
        Data(data),
        Count(count)
    { }
    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {
        return Getter(idx, Data);
    }
    ImPlotGetter Getter;
    void* const Data;
    const int Count;
};

template <typename _Getter>
struct GetterOverrideX {
    GetterOverrideX(_Getter getter, double x) : Getter(getter), X(x), Count(getter.Count) { }
    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {
        ImPlotPoint p = Getter(idx);
        p.x = X;
        return p;
    }
    const _Getter Getter;
    const double X;
    const int Count;
};

template <typename _Getter>
struct GetterOverrideY {
    GetterOverrideY(_Getter getter, double y) : Getter(getter), Y(y), Count(getter.Count) { }
    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {
        ImPlotPoint p = Getter(idx);
        p.y = Y;
        return p;
    }
    const _Getter Getter;
    const double Y;
    const int Count;
};

template <typename _Getter>
struct GetterLoop {
    GetterLoop(_Getter getter) : Getter(getter), Count(getter.Count + 1) { }
    template <typename I> IMPLOT_INLINE ImPlotPoint operator()(I idx) const {
        idx = idx % (Count - 1);
        return Getter(idx);
    }
    const _Getter Getter;
    const int Count;
};

template <typename T>
struct GetterError {
    GetterError(const T* xs, const T* ys, const T* neg, const T* pos, int count, int offset, int stride) :
        Xs(xs),
        Ys(ys),
        Neg(neg),
        Pos(pos),
        Count(count),
        Offset(count ? ImPosMod(offset, count) : 0),
        Stride(stride)
    { }
    template <typename I> IMPLOT_INLINE ImPlotPointError operator()(I idx) const {
        return ImPlotPointError((double)IndexData(Xs,  idx, Count, Offset, Stride),
                                (double)IndexData(Ys,  idx, Count, Offset, Stride),
                                (double)IndexData(Neg, idx, Count, Offset, Stride),
                                (double)IndexData(Pos, idx, Count, Offset, Stride));
    }
    const T* const Xs;
    const T* const Ys;
    const T* const Neg;
    const T* const Pos;
    const int Count;
    const int Offset;
    const int Stride;
};

//-----------------------------------------------------------------------------
// [SECTION] Fitters
//-----------------------------------------------------------------------------

template <typename _Getter1>
struct Fitter1 {
    Fitter1(const _Getter1& getter) : Getter(getter) { }
    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {
        for (int i = 0; i < Getter.Count; ++i) {
            ImPlotPoint p = Getter(i);
            x_axis.ExtendFitWith(y_axis, p.x, p.y);
            y_axis.ExtendFitWith(x_axis, p.y, p.x);
        }
    }
    const _Getter1& Getter;
};

template <typename _Getter1>
struct FitterX {
    FitterX(const _Getter1& getter) : Getter(getter) { }
    void Fit(ImPlotAxis& x_axis, ImPlotAxis&) const {
        for (int i = 0; i < Getter.Count; ++i) {
            ImPlotPoint p = Getter(i);
            x_axis.ExtendFit(p.x);
        }
    }
    const _Getter1& Getter;
};

template <typename _Getter1>
struct FitterY {
    FitterY(const _Getter1& getter) : Getter(getter) { }
    void Fit(ImPlotAxis&, ImPlotAxis& y_axis) const {
        for (int i = 0; i < Getter.Count; ++i) {
            ImPlotPoint p = Getter(i);
            y_axis.ExtendFit(p.y);
        }
    }
    const _Getter1& Getter;
};

template <typename _Getter1, typename _Getter2>
struct Fitter2 {
    Fitter2(const _Getter1& getter1, const _Getter2& getter2) : Getter1(getter1), Getter2(getter2) { }
    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {
        for (int i = 0; i < Getter1.Count; ++i) {
            ImPlotPoint p = Getter1(i);
            x_axis.ExtendFitWith(y_axis, p.x, p.y);
            y_axis.ExtendFitWith(x_axis, p.y, p.x);
        }
        for (int i = 0; i < Getter2.Count; ++i) {
            ImPlotPoint p = Getter2(i);
            x_axis.ExtendFitWith(y_axis, p.x, p.y);
            y_axis.ExtendFitWith(x_axis, p.y, p.x);
        }
    }
    const _Getter1& Getter1;
    const _Getter2& Getter2;
};

template <typename _Getter1, typename _Getter2>
struct FitterBarV {
    FitterBarV(const _Getter1& getter1, const _Getter2& getter2, double width) :
        Getter1(getter1),
        Getter2(getter2),
        HalfWidth(width*0.5)
    { }
    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {
        int count = ImMin(Getter1.Count, Getter2.Count);
        for (int i = 0; i < count; ++i) {
            ImPlotPoint p1 = Getter1(i); p1.x -= HalfWidth;
            ImPlotPoint p2 = Getter2(i); p2.x += HalfWidth;
            x_axis.ExtendFitWith(y_axis, p1.x, p1.y);
            y_axis.ExtendFitWith(x_axis, p1.y, p1.x);
            x_axis.ExtendFitWith(y_axis, p2.x, p2.y);
            y_axis.ExtendFitWith(x_axis, p2.y, p2.x);
        }
    }
    const _Getter1& Getter1;
    const _Getter2& Getter2;
    const double    HalfWidth;
};

template <typename _Getter1, typename _Getter2>
struct FitterBarH {
    FitterBarH(const _Getter1& getter1, const _Getter2& getter2, double height) :
        Getter1(getter1),
        Getter2(getter2),
        HalfHeight(height*0.5)
    { }
    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {
        int count = ImMin(Getter1.Count, Getter2.Count);
        for (int i = 0; i < count; ++i) {
            ImPlotPoint p1 = Getter1(i); p1.y -= HalfHeight;
            ImPlotPoint p2 = Getter2(i); p2.y += HalfHeight;
            x_axis.ExtendFitWith(y_axis, p1.x, p1.y);
            y_axis.ExtendFitWith(x_axis, p1.y, p1.x);
            x_axis.ExtendFitWith(y_axis, p2.x, p2.y);
            y_axis.ExtendFitWith(x_axis, p2.y, p2.x);
        }
    }
    const _Getter1& Getter1;
    const _Getter2& Getter2;
    const double    HalfHeight;
};

struct FitterRect {
    FitterRect(const ImPlotPoint& pmin, const ImPlotPoint& pmax) :
        Pmin(pmin),
        Pmax(pmax)
    { }
    FitterRect(const ImPlotRect& rect) :
        FitterRect(rect.Min(), rect.Max())
    { }
    void Fit(ImPlotAxis& x_axis, ImPlotAxis& y_axis) const {
        x_axis.ExtendFitWith(y_axis, Pmin.x, Pmin.y);
        y_axis.ExtendFitWith(x_axis, Pmin.y, Pmin.x);
        x_axis.ExtendFitWith(y_axis, Pmax.x, Pmax.y);
        y_axis.ExtendFitWith(x_axis, Pmax.y, Pmax.x);
    }
    const ImPlotPoint Pmin;
    const ImPlotPoint Pmax;
};

//-----------------------------------------------------------------------------
// [SECTION] Transformers
//-----------------------------------------------------------------------------

struct Transformer1 {
    Transformer1(double pixMin, double pltMin, double pltMax, double m, double scaMin, double scaMax, ImPlotTransform fwd, void* data) :
        ScaMin(scaMin),
        ScaMax(scaMax),
        PltMin(pltMin),
        PltMax(pltMax),
        PixMin(pixMin),
        M(m),
        TransformFwd(fwd),
        TransformData(data)
    { }

    template <typename T> IMPLOT_INLINE float operator()(T p) const {
        if (TransformFwd != nullptr) {
            double s = TransformFwd(p, TransformData);
            double t = (s - ScaMin) / (ScaMax - ScaMin);
            p = PltMin + (PltMax - PltMin) * t;
        }
        return (float)(PixMin + M * (p - PltMin));
    }

    double ScaMin, ScaMax, PltMin, PltMax, PixMin, M;
    ImPlotTransform TransformFwd;
    void*           TransformData;
};

struct Transformer2 {
    Transformer2(const ImPlotAxis& x_axis, const ImPlotAxis& y_axis) :
        Tx(x_axis.PixelMin,
           x_axis.Range.Min,
           x_axis.Range.Max,
           x_axis.ScaleToPixel,
           x_axis.ScaleMin,
           x_axis.ScaleMax,
           x_axis.TransformForward,
           x_axis.TransformData),
        Ty(y_axis.PixelMin,
           y_axis.Range.Min,
           y_axis.Range.Max,
           y_axis.ScaleToPixel,
           y_axis.ScaleMin,
           y_axis.ScaleMax,
           y_axis.TransformForward,
           y_axis.TransformData)
    { }

    Transformer2(const ImPlotPlot& plot) :
        Transformer2(plot.Axes[plot.CurrentX], plot.Axes[plot.CurrentY])
    { }

    Transformer2() :
        Transformer2(*GImPlot->CurrentPlot)
    { }

    template <typename P> IMPLOT_INLINE ImVec2 operator()(const P& plt) const {
        ImVec2 out;
        out.x = Tx(plt.x);
        out.y = Ty(plt.y);
        return out;
    }

    template <typename T> IMPLOT_INLINE ImVec2 operator()(T x, T y) const {
        ImVec2 out;
        out.x = Tx(x);
        out.y = Ty(y);
        return out;
    }

    Transformer1 Tx;
    Transformer1 Ty;
};

//-----------------------------------------------------------------------------
// [SECTION] Renderers
//-----------------------------------------------------------------------------

struct RendererBase {
    RendererBase(int prims, int idx_consumed, int vtx_consumed) :
        Prims(prims),
        IdxConsumed(idx_consumed),
        VtxConsumed(vtx_consumed)
    { }
    const int Prims;
    Transformer2 Transformer;
    const int IdxConsumed;
    const int VtxConsumed;
};

template <class _Getter>
struct RendererLineStrip : RendererBase {
    RendererLineStrip(const _Getter& getter, ImU32 col, float weight) :
        RendererBase(getter.Count - 1, 6, 4),
        Getter(getter),
        Col(col),
        HalfWeight(ImMax(1.0f,weight)*0.5f)
    {
        P1 = this->Transformer(Getter(0));
    }
    void Init(ImDrawList& draw_list) const {
        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 P2 = this->Transformer(Getter(prim + 1));
        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2)))) {
            P1 = P2;
            return false;
        }
        PrimLine(draw_list,P1,P2,HalfWeight,Col,UV0,UV1);
        P1 = P2;
        return true;
    }
    const _Getter& Getter;
    const ImU32 Col;
    mutable float HalfWeight;
    mutable ImVec2 P1;
    mutable ImVec2 UV0;
    mutable ImVec2 UV1;
};

template <class _Getter>
struct RendererLineStripSkip : RendererBase {
    RendererLineStripSkip(const _Getter& getter, ImU32 col, float weight) :
        RendererBase(getter.Count - 1, 6, 4),
        Getter(getter),
        Col(col),
        HalfWeight(ImMax(1.0f,weight)*0.5f)
    {
        P1 = this->Transformer(Getter(0));
    }
    void Init(ImDrawList& draw_list) const {
        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 P2 = this->Transformer(Getter(prim + 1));
        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2)))) {
            if (!ImNan(P2.x) && !ImNan(P2.y))
                P1 = P2;
            return false;
        }
        PrimLine(draw_list,P1,P2,HalfWeight,Col,UV0,UV1);
        if (!ImNan(P2.x) && !ImNan(P2.y))
            P1 = P2;
        return true;
    }
    const _Getter& Getter;
    const ImU32 Col;
    mutable float HalfWeight;
    mutable ImVec2 P1;
    mutable ImVec2 UV0;
    mutable ImVec2 UV1;
};

template <class _Getter>
struct RendererLineSegments1 : RendererBase {
    RendererLineSegments1(const _Getter& getter, ImU32 col, float weight) :
        RendererBase(getter.Count / 2, 6, 4),
        Getter(getter),
        Col(col),
        HalfWeight(ImMax(1.0f,weight)*0.5f)
    { }
    void Init(ImDrawList& draw_list) const {
        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 P1 = this->Transformer(Getter(prim*2+0));
        ImVec2 P2 = this->Transformer(Getter(prim*2+1));
        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2))))
            return false;
        PrimLine(draw_list,P1,P2,HalfWeight,Col,UV0,UV1);
        return true;
    }
    const _Getter& Getter;
    const ImU32 Col;
    mutable float HalfWeight;
    mutable ImVec2 UV0;
    mutable ImVec2 UV1;
};

template <class _Getter1, class _Getter2>
struct RendererLineSegments2 : RendererBase {
    RendererLineSegments2(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, float weight) :
        RendererBase(ImMin(getter1.Count, getter1.Count), 6, 4),
        Getter1(getter1),
        Getter2(getter2),
        Col(col),
        HalfWeight(ImMax(1.0f,weight)*0.5f)
    {}
    void Init(ImDrawList& draw_list) const {
        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 P1 = this->Transformer(Getter1(prim));
        ImVec2 P2 = this->Transformer(Getter2(prim));
        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2))))
            return false;
        PrimLine(draw_list,P1,P2,HalfWeight,Col,UV0,UV1);
        return true;
    }
    const _Getter1& Getter1;
    const _Getter2& Getter2;
    const ImU32 Col;
    mutable float HalfWeight;
    mutable ImVec2 UV0;
    mutable ImVec2 UV1;
};

template <class _Getter1, class _Getter2>
struct RendererBarsFillV : RendererBase {
    RendererBarsFillV(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, double width) :
        RendererBase(ImMin(getter1.Count, getter1.Count), 6, 4),
        Getter1(getter1),
        Getter2(getter2),
        Col(col),
        HalfWidth(width/2)
    {}
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImPlotPoint p1 = Getter1(prim);
        ImPlotPoint p2 = Getter2(prim);
        p1.x += HalfWidth;
        p2.x -= HalfWidth;
        ImVec2 P1 = this->Transformer(p1);
        ImVec2 P2 = this->Transformer(p2);
        float width_px = ImAbs(P1.x-P2.x);
        if (width_px < 1.0f) {
            P1.x += P1.x > P2.x ? (1-width_px) / 2 : (width_px-1) / 2;
            P2.x += P2.x > P1.x ? (1-width_px) / 2 : (width_px-1) / 2;
        }
        ImVec2 PMin = ImMin(P1, P2);
        ImVec2 PMax = ImMax(P1, P2);
        if (!cull_rect.Overlaps(ImRect(PMin, PMax)))
            return false;
        PrimRectFill(draw_list,PMin,PMax,Col,UV);
        return true;
    }
    const _Getter1& Getter1;
    const _Getter2& Getter2;
    const ImU32 Col;
    const double HalfWidth;
    mutable ImVec2 UV;
};

template <class _Getter1, class _Getter2>
struct RendererBarsFillH : RendererBase {
    RendererBarsFillH(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, double height) :
        RendererBase(ImMin(getter1.Count, getter1.Count), 6, 4),
        Getter1(getter1),
        Getter2(getter2),
        Col(col),
        HalfHeight(height/2)
    {}
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImPlotPoint p1 = Getter1(prim);
        ImPlotPoint p2 = Getter2(prim);
        p1.y += HalfHeight;
        p2.y -= HalfHeight;
        ImVec2 P1 = this->Transformer(p1);
        ImVec2 P2 = this->Transformer(p2);
        float height_px = ImAbs(P1.y-P2.y);
        if (height_px < 1.0f) {
            P1.y += P1.y > P2.y ? (1-height_px) / 2 : (height_px-1) / 2;
            P2.y += P2.y > P1.y ? (1-height_px) / 2 : (height_px-1) / 2;
        }
        ImVec2 PMin = ImMin(P1, P2);
        ImVec2 PMax = ImMax(P1, P2);
        if (!cull_rect.Overlaps(ImRect(PMin, PMax)))
            return false;
        PrimRectFill(draw_list,PMin,PMax,Col,UV);
        return true;
    }
    const _Getter1& Getter1;
    const _Getter2& Getter2;
    const ImU32 Col;
    const double HalfHeight;
    mutable ImVec2 UV;
};

template <class _Getter1, class _Getter2>
struct RendererBarsLineV : RendererBase {
    RendererBarsLineV(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, double width, float weight) :
        RendererBase(ImMin(getter1.Count, getter1.Count), 24, 8),
        Getter1(getter1),
        Getter2(getter2),
        Col(col),
        HalfWidth(width/2),
        Weight(weight)
    {}
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImPlotPoint p1 = Getter1(prim);
        ImPlotPoint p2 = Getter2(prim);
        p1.x += HalfWidth;
        p2.x -= HalfWidth;
        ImVec2 P1 = this->Transformer(p1);
        ImVec2 P2 = this->Transformer(p2);
        float width_px = ImAbs(P1.x-P2.x);
        if (width_px < 1.0f) {
            P1.x += P1.x > P2.x ? (1-width_px) / 2 : (width_px-1) / 2;
            P2.x += P2.x > P1.x ? (1-width_px) / 2 : (width_px-1) / 2;
        }
        ImVec2 PMin = ImMin(P1, P2);
        ImVec2 PMax = ImMax(P1, P2);
        if (!cull_rect.Overlaps(ImRect(PMin, PMax)))
            return false;
        PrimRectLine(draw_list,PMin,PMax,Weight,Col,UV);
        return true;
    }
    const _Getter1& Getter1;
    const _Getter2& Getter2;
    const ImU32 Col;
    const double HalfWidth;
    const float Weight;
    mutable ImVec2 UV;
};

template <class _Getter1, class _Getter2>
struct RendererBarsLineH : RendererBase {
    RendererBarsLineH(const _Getter1& getter1, const _Getter2& getter2, ImU32 col, double height, float weight) :
        RendererBase(ImMin(getter1.Count, getter1.Count), 24, 8),
        Getter1(getter1),
        Getter2(getter2),
        Col(col),
        HalfHeight(height/2),
        Weight(weight)
    {}
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImPlotPoint p1 = Getter1(prim);
        ImPlotPoint p2 = Getter2(prim);
        p1.y += HalfHeight;
        p2.y -= HalfHeight;
        ImVec2 P1 = this->Transformer(p1);
        ImVec2 P2 = this->Transformer(p2);
        float height_px = ImAbs(P1.y-P2.y);
        if (height_px < 1.0f) {
            P1.y += P1.y > P2.y ? (1-height_px) / 2 : (height_px-1) / 2;
            P2.y += P2.y > P1.y ? (1-height_px) / 2 : (height_px-1) / 2;
        }
        ImVec2 PMin = ImMin(P1, P2);
        ImVec2 PMax = ImMax(P1, P2);
        if (!cull_rect.Overlaps(ImRect(PMin, PMax)))
            return false;
        PrimRectLine(draw_list,PMin,PMax,Weight,Col,UV);
        return true;
    }
    const _Getter1& Getter1;
    const _Getter2& Getter2;
    const ImU32 Col;
    const double HalfHeight;
    const float Weight;
    mutable ImVec2 UV;
};


template <class _Getter>
struct RendererStairsPre : RendererBase {
    RendererStairsPre(const _Getter& getter, ImU32 col, float weight) :
        RendererBase(getter.Count - 1, 12, 8),
        Getter(getter),
        Col(col),
        HalfWeight(ImMax(1.0f,weight)*0.5f)
    {
        P1 = this->Transformer(Getter(0));
    }
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 P2 = this->Transformer(Getter(prim + 1));
        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2)))) {
            P1 = P2;
            return false;
        }
        PrimRectFill(draw_list, ImVec2(P1.x - HalfWeight, P1.y), ImVec2(P1.x + HalfWeight, P2.y), Col, UV);
        PrimRectFill(draw_list, ImVec2(P1.x, P2.y + HalfWeight), ImVec2(P2.x, P2.y - HalfWeight), Col, UV);
        P1 = P2;
        return true;
    }
    const _Getter& Getter;
    const ImU32 Col;
    mutable float HalfWeight;
    mutable ImVec2 P1;
    mutable ImVec2 UV;
};

template <class _Getter>
struct RendererStairsPost : RendererBase {
    RendererStairsPost(const _Getter& getter, ImU32 col, float weight) :
        RendererBase(getter.Count - 1, 12, 8),
        Getter(getter),
        Col(col),
        HalfWeight(ImMax(1.0f,weight) * 0.5f)
    {
        P1 = this->Transformer(Getter(0));
    }
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 P2 = this->Transformer(Getter(prim + 1));
        if (!cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2)))) {
            P1 = P2;
            return false;
        }
        PrimRectFill(draw_list, ImVec2(P1.x, P1.y + HalfWeight), ImVec2(P2.x, P1.y - HalfWeight), Col, UV);
        PrimRectFill(draw_list, ImVec2(P2.x - HalfWeight, P2.y), ImVec2(P2.x + HalfWeight, P1.y), Col, UV);
        P1 = P2;
        return true;
    }
    const _Getter& Getter;
    const ImU32 Col;
    mutable float HalfWeight;
    mutable ImVec2 P1;
    mutable ImVec2 UV;
};

template <class _Getter>
struct RendererStairsPreShaded : RendererBase {
    RendererStairsPreShaded(const _Getter& getter, ImU32 col) :
        RendererBase(getter.Count - 1, 6, 4),
        Getter(getter),
        Col(col)
    {
        P1 = this->Transformer(Getter(0));
        Y0 = this->Transformer(ImPlotPoint(0,0)).y;
    }
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 P2 = this->Transformer(Getter(prim + 1));
        ImVec2 PMin(ImMin(P1.x, P2.x), ImMin(Y0, P2.y));
        ImVec2 PMax(ImMax(P1.x, P2.x), ImMax(Y0, P2.y));
        if (!cull_rect.Overlaps(ImRect(PMin, PMax))) {
            P1 = P2;
            return false;
        }
        PrimRectFill(draw_list, PMin, PMax, Col, UV);
        P1 = P2;
        return true;
    }
    const _Getter& Getter;
    const ImU32 Col;
    float Y0;
    mutable ImVec2 P1;
    mutable ImVec2 UV;
};

template <class _Getter>
struct RendererStairsPostShaded : RendererBase {
    RendererStairsPostShaded(const _Getter& getter, ImU32 col) :
        RendererBase(getter.Count - 1, 6, 4),
        Getter(getter),
        Col(col)
    {
        P1 = this->Transformer(Getter(0));
        Y0 = this->Transformer(ImPlotPoint(0,0)).y;
    }
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 P2 = this->Transformer(Getter(prim + 1));
        ImVec2 PMin(ImMin(P1.x, P2.x), ImMin(P1.y, Y0));
        ImVec2 PMax(ImMax(P1.x, P2.x), ImMax(P1.y, Y0));
        if (!cull_rect.Overlaps(ImRect(PMin, PMax))) {
            P1 = P2;
            return false;
        }
        PrimRectFill(draw_list, PMin, PMax, Col, UV);
        P1 = P2;
        return true;
    }
    const _Getter& Getter;
    const ImU32 Col;
    float Y0;
    mutable ImVec2 P1;
    mutable ImVec2 UV;
};



template <class _Getter1, class _Getter2>
struct RendererShaded : RendererBase {
    RendererShaded(const _Getter1& getter1, const _Getter2& getter2, ImU32 col) :
        RendererBase(ImMin(getter1.Count, getter2.Count) - 1, 6, 5),
        Getter1(getter1),
        Getter2(getter2),
        Col(col)
    {
        P11 = this->Transformer(Getter1(0));
        P12 = this->Transformer(Getter2(0));
    }
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 P21 = this->Transformer(Getter1(prim+1));
        ImVec2 P22 = this->Transformer(Getter2(prim+1));
        ImRect rect(ImMin(ImMin(ImMin(P11,P12),P21),P22), ImMax(ImMax(ImMax(P11,P12),P21),P22));
        if (!cull_rect.Overlaps(rect)) {
            P11 = P21;
            P12 = P22;
            return false;
        }
        const int intersect = (P11.y > P12.y && P22.y > P21.y) || (P12.y > P11.y && P21.y > P22.y);
        const ImVec2 intersection = intersect == 0 ? ImVec2(0,0) : Intersection(P11,P21,P12,P22);
        draw_list._VtxWritePtr[0].pos = P11;
        draw_list._VtxWritePtr[0].uv  = UV;
        draw_list._VtxWritePtr[0].col = Col;
        draw_list._VtxWritePtr[1].pos = P21;
        draw_list._VtxWritePtr[1].uv  = UV;
        draw_list._VtxWritePtr[1].col = Col;
        draw_list._VtxWritePtr[2].pos = intersection;
        draw_list._VtxWritePtr[2].uv  = UV;
        draw_list._VtxWritePtr[2].col = Col;
        draw_list._VtxWritePtr[3].pos = P12;
        draw_list._VtxWritePtr[3].uv  = UV;
        draw_list._VtxWritePtr[3].col = Col;
        draw_list._VtxWritePtr[4].pos = P22;
        draw_list._VtxWritePtr[4].uv  = UV;
        draw_list._VtxWritePtr[4].col = Col;
        draw_list._VtxWritePtr += 5;
        draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx);
        draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1 + intersect);
        draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3);
        draw_list._IdxWritePtr[3] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 1);
        draw_list._IdxWritePtr[4] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 4);
        draw_list._IdxWritePtr[5] = (ImDrawIdx)(draw_list._VtxCurrentIdx + 3 - intersect);
        draw_list._IdxWritePtr += 6;
        draw_list._VtxCurrentIdx += 5;
        P11 = P21;
        P12 = P22;
        return true;
    }
    const _Getter1& Getter1;
    const _Getter2& Getter2;
    const ImU32 Col;
    mutable ImVec2 P11;
    mutable ImVec2 P12;
    mutable ImVec2 UV;
};

struct RectC {
    ImPlotPoint Pos;
    ImPlotPoint HalfSize;
    ImU32 Color;
};

template <typename _Getter>
struct RendererRectC : RendererBase {
    RendererRectC(const _Getter& getter) :
        RendererBase(getter.Count, 6, 4),
        Getter(getter)
    {}
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        RectC rect = Getter(prim);
        ImVec2 P1 = this->Transformer(rect.Pos.x - rect.HalfSize.x , rect.Pos.y - rect.HalfSize.y);
        ImVec2 P2 = this->Transformer(rect.Pos.x + rect.HalfSize.x , rect.Pos.y + rect.HalfSize.y);
        if ((rect.Color & IM_COL32_A_MASK) == 0 || !cull_rect.Overlaps(ImRect(ImMin(P1, P2), ImMax(P1, P2))))
            return false;
        PrimRectFill(draw_list,P1,P2,rect.Color,UV);
        return true;
    }
    const _Getter& Getter;
    mutable ImVec2 UV;
};

//-----------------------------------------------------------------------------
// [SECTION] RenderPrimitives
//-----------------------------------------------------------------------------

/// Renders primitive shapes in bulk as efficiently as possible.
template <class _Renderer>
void RenderPrimitivesEx(const _Renderer& renderer, ImDrawList& draw_list, const ImRect& cull_rect) {
    unsigned int prims        = renderer.Prims;
    unsigned int prims_culled = 0;
    unsigned int idx          = 0;
    renderer.Init(draw_list);
    while (prims) {
        // find how many can be reserved up to end of current draw command's limit
        unsigned int cnt = ImMin(prims, (MaxIdx<ImDrawIdx>::Value - draw_list._VtxCurrentIdx) / renderer.VtxConsumed);
        // make sure at least this many elements can be rendered to avoid situations where at the end of buffer this slow path is not taken all the time
        if (cnt >= ImMin(64u, prims)) {
            if (prims_culled >= cnt)
                prims_culled -= cnt; // reuse previous reservation
            else {
                // add more elements to previous reservation
                draw_list.PrimReserve((cnt - prims_culled) * renderer.IdxConsumed, (cnt - prims_culled) * renderer.VtxConsumed);
                prims_culled = 0;
            }
        }
        else
        {
            if (prims_culled > 0) {
                draw_list.PrimUnreserve(prims_culled * renderer.IdxConsumed, prims_culled * renderer.VtxConsumed);
                prims_culled = 0;
            }
            cnt = ImMin(prims, (MaxIdx<ImDrawIdx>::Value - 0/*draw_list._VtxCurrentIdx*/) / renderer.VtxConsumed);
            // reserve new draw command
            draw_list.PrimReserve(cnt * renderer.IdxConsumed, cnt * renderer.VtxConsumed);
        }
        prims -= cnt;
        for (unsigned int ie = idx + cnt; idx != ie; ++idx) {
            if (!renderer.Render(draw_list, cull_rect, idx))
                prims_culled++;
        }
    }
    if (prims_culled > 0)
        draw_list.PrimUnreserve(prims_culled * renderer.IdxConsumed, prims_culled * renderer.VtxConsumed);
}

template <template <class> class _Renderer, class _Getter, typename ...Args>
void RenderPrimitives1(const _Getter& getter, Args... args) {
    ImDrawList& draw_list = *GetPlotDrawList();
    const ImRect& cull_rect = GetCurrentPlot()->PlotRect;
    RenderPrimitivesEx(_Renderer<_Getter>(getter,args...), draw_list, cull_rect);
}

template <template <class,class> class _Renderer, class _Getter1, class _Getter2, typename ...Args>
void RenderPrimitives2(const _Getter1& getter1, const _Getter2& getter2, Args... args) {
    ImDrawList& draw_list = *GetPlotDrawList();
    const ImRect& cull_rect = GetCurrentPlot()->PlotRect;
    RenderPrimitivesEx(_Renderer<_Getter1,_Getter2>(getter1,getter2,args...), draw_list, cull_rect);
}

//-----------------------------------------------------------------------------
// [SECTION] Markers
//-----------------------------------------------------------------------------

template <class _Getter>
struct RendererMarkersFill : RendererBase {
    RendererMarkersFill(const _Getter& getter, const ImVec2* marker, int count, float size, ImU32 col) :
        RendererBase(getter.Count, (count-2)*3, count),
        Getter(getter),
        Marker(marker),
        Count(count),
        Size(size),
        Col(col)
    { }
    void Init(ImDrawList& draw_list) const {
        UV = draw_list._Data->TexUvWhitePixel;
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 p = this->Transformer(Getter(prim));
        if (p.x >= cull_rect.Min.x && p.y >= cull_rect.Min.y && p.x <= cull_rect.Max.x && p.y <= cull_rect.Max.y) {
            for (int i = 0; i < Count; i++) {
                draw_list._VtxWritePtr[0].pos.x = p.x + Marker[i].x * Size;
                draw_list._VtxWritePtr[0].pos.y = p.y + Marker[i].y * Size;
                draw_list._VtxWritePtr[0].uv = UV;
                draw_list._VtxWritePtr[0].col = Col;
                draw_list._VtxWritePtr++;
            }
            for (int i = 2; i < Count; i++) {
                draw_list._IdxWritePtr[0] = (ImDrawIdx)(draw_list._VtxCurrentIdx);
                draw_list._IdxWritePtr[1] = (ImDrawIdx)(draw_list._VtxCurrentIdx + i - 1);
                draw_list._IdxWritePtr[2] = (ImDrawIdx)(draw_list._VtxCurrentIdx + i);
                draw_list._IdxWritePtr += 3;
            }
            draw_list._VtxCurrentIdx += (ImDrawIdx)Count;
            return true;
        }
        return false;
    }
    const _Getter& Getter;
    const ImVec2* Marker;
    const int Count;
    const float Size;
    const ImU32 Col;
    mutable ImVec2 UV;
};


template <class _Getter>
struct RendererMarkersLine : RendererBase {
    RendererMarkersLine(const _Getter& getter, const ImVec2* marker, int count, float size, float weight, ImU32 col) :
        RendererBase(getter.Count, count/2*6, count/2*4),
        Getter(getter),
        Marker(marker),
        Count(count),
        HalfWeight(ImMax(1.0f,weight)*0.5f),
        Size(size),
        Col(col)
    { }
    void Init(ImDrawList& draw_list) const {
        GetLineRenderProps(draw_list, HalfWeight, UV0, UV1);
    }
    IMPLOT_INLINE bool Render(ImDrawList& draw_list, const ImRect& cull_rect, int prim) const {
        ImVec2 p = this->Transformer(Getter(prim));
        if (p.x >= cull_rect.Min.x && p.y >= cull_rect.Min.y && p.x <= cull_rect.Max.x && p.y <= cull_rect.Max.y) {
            for (int i = 0; i < Count; i = i + 2) {
                ImVec2 p1(p.x + Marker[i].x * Size, p.y + Marker[i].y * Size);
                ImVec2 p2(p.x + Marker[i+1].x * Size, p.y + Marker[i+1].y * Size);
                PrimLine(draw_list, p1, p2, HalfWeight, Col, UV0, UV1);
            }
            return true;
        }
        return false;
    }
    const _Getter& Getter;
    const ImVec2* Marker;
    const int Count;
    mutable float HalfWeight;
    const float Size;
    const ImU32 Col;
    mutable ImVec2 UV0;
    mutable ImVec2 UV1;
};

static const ImVec2 MARKER_FILL_CIRCLE[10]  = {ImVec2(1.0f, 0.0f), ImVec2(0.809017f, 0.58778524f),ImVec2(0.30901697f, 0.95105654f),ImVec2(-0.30901703f, 0.9510565f),ImVec2(-0.80901706f, 0.5877852f),ImVec2(-1.0f, 0.0f),ImVec2(-0.80901694f, -0.58778536f),ImVec2(-0.3090171f, -0.9510565f),ImVec2(0.30901712f, -0.9510565f),ImVec2(0.80901694f, -0.5877853f)};
static const ImVec2 MARKER_FILL_SQUARE[4]   = {ImVec2(SQRT_1_2,SQRT_1_2), ImVec2(SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,SQRT_1_2)};
static const ImVec2 MARKER_FILL_DIAMOND[4]  = {ImVec2(1, 0), ImVec2(0, -1), ImVec2(-1, 0), ImVec2(0, 1)};
static const ImVec2 MARKER_FILL_UP[3]       = {ImVec2(SQRT_3_2,0.5f),ImVec2(0,-1),ImVec2(-SQRT_3_2,0.5f)};
static const ImVec2 MARKER_FILL_DOWN[3]     = {ImVec2(SQRT_3_2,-0.5f),ImVec2(0,1),ImVec2(-SQRT_3_2,-0.5f)};
static const ImVec2 MARKER_FILL_LEFT[3]     = {ImVec2(-1,0), ImVec2(0.5, SQRT_3_2), ImVec2(0.5, -SQRT_3_2)};
static const ImVec2 MARKER_FILL_RIGHT[3]    = {ImVec2(1,0), ImVec2(-0.5, SQRT_3_2), ImVec2(-0.5, -SQRT_3_2)};

static const ImVec2 MARKER_LINE_CIRCLE[20]  = {
    ImVec2(1.0f, 0.0f),
    ImVec2(0.809017f, 0.58778524f),
    ImVec2(0.809017f, 0.58778524f),
    ImVec2(0.30901697f, 0.95105654f),
    ImVec2(0.30901697f, 0.95105654f),
    ImVec2(-0.30901703f, 0.9510565f),
    ImVec2(-0.30901703f, 0.9510565f),
    ImVec2(-0.80901706f, 0.5877852f),
    ImVec2(-0.80901706f, 0.5877852f),
    ImVec2(-1.0f, 0.0f),
    ImVec2(-1.0f, 0.0f),
    ImVec2(-0.80901694f, -0.58778536f),
    ImVec2(-0.80901694f, -0.58778536f),
    ImVec2(-0.3090171f, -0.9510565f),
    ImVec2(-0.3090171f, -0.9510565f),
    ImVec2(0.30901712f, -0.9510565f),
    ImVec2(0.30901712f, -0.9510565f),
    ImVec2(0.80901694f, -0.5877853f),
    ImVec2(0.80901694f, -0.5877853f),
    ImVec2(1.0f, 0.0f)
};
static const ImVec2 MARKER_LINE_SQUARE[8]   = {ImVec2(SQRT_1_2,SQRT_1_2), ImVec2(SQRT_1_2,-SQRT_1_2), ImVec2(SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,-SQRT_1_2), ImVec2(-SQRT_1_2,SQRT_1_2), ImVec2(-SQRT_1_2,SQRT_1_2), ImVec2(SQRT_1_2,SQRT_1_2)};
static const ImVec2 MARKER_LINE_DIAMOND[8]  = {ImVec2(1, 0), ImVec2(0, -1), ImVec2(0, -1), ImVec2(-1, 0), ImVec2(-1, 0), ImVec2(0, 1), ImVec2(0, 1), ImVec2(1, 0)};
static const ImVec2 MARKER_LINE_UP[6]       = {ImVec2(SQRT_3_2,0.5f), ImVec2(0,-1),ImVec2(0,-1),ImVec2(-SQRT_3_2,0.5f),ImVec2(-SQRT_3_2,0.5f),ImVec2(SQRT_3_2,0.5f)};
static const ImVec2 MARKER_LINE_DOWN[6]     = {ImVec2(SQRT_3_2,-0.5f),ImVec2(0,1),ImVec2(0,1),ImVec2(-SQRT_3_2,-0.5f), ImVec2(-SQRT_3_2,-0.5f), ImVec2(SQRT_3_2,-0.5f)};
static const ImVec2 MARKER_LINE_LEFT[6]     = {ImVec2(-1,0), ImVec2(0.5, SQRT_3_2),  ImVec2(0.5, SQRT_3_2),  ImVec2(0.5, -SQRT_3_2) , ImVec2(0.5, -SQRT_3_2) , ImVec2(-1,0) };
static const ImVec2 MARKER_LINE_RIGHT[6]    = {ImVec2(1,0),  ImVec2(-0.5, SQRT_3_2), ImVec2(-0.5, SQRT_3_2), ImVec2(-0.5, -SQRT_3_2), ImVec2(-0.5, -SQRT_3_2), ImVec2(1,0) };
static const ImVec2 MARKER_LINE_ASTERISK[6] = {ImVec2(-SQRT_3_2, -0.5f), ImVec2(SQRT_3_2, 0.5f),  ImVec2(-SQRT_3_2, 0.5f), ImVec2(SQRT_3_2, -0.5f), ImVec2(0, -1), ImVec2(0, 1)};
static const ImVec2 MARKER_LINE_PLUS[4]     = {ImVec2(-1, 0), ImVec2(1, 0), ImVec2(0, -1), ImVec2(0, 1)};
static const ImVec2 MARKER_LINE_CROSS[4]    = {ImVec2(-SQRT_1_2,-SQRT_1_2),ImVec2(SQRT_1_2,SQRT_1_2),ImVec2(SQRT_1_2,-SQRT_1_2),ImVec2(-SQRT_1_2,SQRT_1_2)};

template <typename _Getter>
void RenderMarkers(const _Getter& getter, ImPlotMarker marker, float size, bool rend_fill, ImU32 col_fill, bool rend_line, ImU32 col_line, float weight) {
    if (rend_fill) {
        switch (marker) {
            case ImPlotMarker_Circle  : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_CIRCLE,10,size,col_fill); break;
            case ImPlotMarker_Square  : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_SQUARE, 4,size,col_fill); break;
            case ImPlotMarker_Diamond : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_DIAMOND,4,size,col_fill); break;
            case ImPlotMarker_Up      : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_UP,     3,size,col_fill); break;
            case ImPlotMarker_Down    : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_DOWN,   3,size,col_fill); break;
            case ImPlotMarker_Left    : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_LEFT,   3,size,col_fill); break;
            case ImPlotMarker_Right   : RenderPrimitives1<RendererMarkersFill>(getter,MARKER_FILL_RIGHT,  3,size,col_fill); break;
        }
    }
    if (rend_line) {
        switch (marker) {
            case ImPlotMarker_Circle    : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_CIRCLE, 20,size,weight,col_line); break;
            case ImPlotMarker_Square    : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_SQUARE,  8,size,weight,col_line); break;
            case ImPlotMarker_Diamond   : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_DIAMOND, 8,size,weight,col_line); break;
            case ImPlotMarker_Up        : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_UP,      6,size,weight,col_line); break;
            case ImPlotMarker_Down      : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_DOWN,    6,size,weight,col_line); break;
            case ImPlotMarker_Left      : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_LEFT,    6,size,weight,col_line); break;
            case ImPlotMarker_Right     : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_RIGHT,   6,size,weight,col_line); break;
            case ImPlotMarker_Asterisk  : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_ASTERISK,6,size,weight,col_line); break;
            case ImPlotMarker_Plus      : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_PLUS,    4,size,weight,col_line); break;
            case ImPlotMarker_Cross     : RenderPrimitives1<RendererMarkersLine>(getter,MARKER_LINE_CROSS,   4,size,weight,col_line); break;
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] PlotLine
//-----------------------------------------------------------------------------

template <typename _Getter>
void PlotLineEx(const char* label_id, const _Getter& getter, ImPlotLineFlags flags) {
    if (BeginItemEx(label_id, Fitter1<_Getter>(getter), flags, ImPlotCol_Line)) {
        if (getter.Count <= 0) {
            EndItem();
            return;
        }
        const ImPlotNextItemData& s = GetItemData();
        if (getter.Count > 1) {
            if (ImHasFlag(flags, ImPlotLineFlags_Shaded) && s.RenderFill) {
                const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);
                GetterOverrideY<_Getter> getter2(getter, 0);
                RenderPrimitives2<RendererShaded>(getter,getter2,col_fill);
            }
            if (s.RenderLine) {
                const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);
                if (ImHasFlag(flags,ImPlotLineFlags_Segments)) {
                    RenderPrimitives1<RendererLineSegments1>(getter,col_line,s.LineWeight);
                }
                else if (ImHasFlag(flags, ImPlotLineFlags_Loop)) {
                    if (ImHasFlag(flags, ImPlotLineFlags_SkipNaN))
                        RenderPrimitives1<RendererLineStripSkip>(GetterLoop<_Getter>(getter),col_line,s.LineWeight);
                    else
                        RenderPrimitives1<RendererLineStrip>(GetterLoop<_Getter>(getter),col_line,s.LineWeight);
                }
                else {
                    if (ImHasFlag(flags, ImPlotLineFlags_SkipNaN))
                        RenderPrimitives1<RendererLineStripSkip>(getter,col_line,s.LineWeight);
                    else
                        RenderPrimitives1<RendererLineStrip>(getter,col_line,s.LineWeight);
                }
            }
        }
        // render markers
        if (s.Marker != ImPlotMarker_None) {
            if (ImHasFlag(flags, ImPlotLineFlags_NoClip)) {
                PopPlotClipRect();
                PushPlotClipRect(s.MarkerSize);
            }
            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerOutline]);
            const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerFill]);
            RenderMarkers<_Getter>(getter, s.Marker, s.MarkerSize, s.RenderMarkerFill, col_fill, s.RenderMarkerLine, col_line, s.MarkerWeight);
        }
        EndItem();
    }
}

template <typename T>
void PlotLine(const char* label_id, const T* values, int count, double xscale, double x0, ImPlotLineFlags flags, int offset, int stride) {
    GetterXY<IndexerLin,IndexerIdx<T>> getter(IndexerLin(xscale,x0),IndexerIdx<T>(values,count,offset,stride),count);
    PlotLineEx(label_id, getter, flags);
}

template <typename T>
void PlotLine(const char* label_id, const T* xs, const T* ys, int count, ImPlotLineFlags flags, int offset, int stride) {
    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);
    PlotLineEx(label_id, getter, flags);
}

#define INSTANTIATE_MACRO(T) \
    template IMPLOT_API void PlotLine<T> (const char* label_id, const T* values, int count, double xscale, double x0, ImPlotLineFlags flags, int offset, int stride); \
    template IMPLOT_API void PlotLine<T>(const char* label_id, const T* xs, const T* ys, int count, ImPlotLineFlags flags, int offset, int stride);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

// custom
void PlotLineG(const char* label_id, ImPlotGetter getter_func, void* data, int count, ImPlotLineFlags flags) {
    GetterFuncPtr getter(getter_func,data, count);
    PlotLineEx(label_id, getter, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] PlotScatter
//-----------------------------------------------------------------------------

template <typename Getter>
void PlotScatterEx(const char* label_id, const Getter& getter, ImPlotScatterFlags flags) {
    if (BeginItemEx(label_id, Fitter1<Getter>(getter), flags, ImPlotCol_MarkerOutline)) {
        if (getter.Count <= 0) {
            EndItem();
            return;
        }
        const ImPlotNextItemData& s = GetItemData();
        ImPlotMarker marker = s.Marker == ImPlotMarker_None ? ImPlotMarker_Circle: s.Marker;
        if (marker != ImPlotMarker_None) {
            if (ImHasFlag(flags,ImPlotScatterFlags_NoClip)) {
                PopPlotClipRect();
                PushPlotClipRect(s.MarkerSize);
            }
            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerOutline]);
            const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerFill]);
            RenderMarkers<Getter>(getter, marker, s.MarkerSize, s.RenderMarkerFill, col_fill, s.RenderMarkerLine, col_line, s.MarkerWeight);
        }
        EndItem();
    }
}

template <typename T>
void PlotScatter(const char* label_id, const T* values, int count, double xscale, double x0, ImPlotScatterFlags flags, int offset, int stride) {
    GetterXY<IndexerLin,IndexerIdx<T>> getter(IndexerLin(xscale,x0),IndexerIdx<T>(values,count,offset,stride),count);
    PlotScatterEx(label_id, getter, flags);
}

template <typename T>
void PlotScatter(const char* label_id, const T* xs, const T* ys, int count, ImPlotScatterFlags flags, int offset, int stride) {
    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);
    return PlotScatterEx(label_id, getter, flags);
}

#define INSTANTIATE_MACRO(T) \
    template IMPLOT_API void PlotScatter<T>(const char* label_id, const T* values, int count, double xscale, double x0, ImPlotScatterFlags flags, int offset, int stride); \
    template IMPLOT_API void PlotScatter<T>(const char* label_id, const T* xs, const T* ys, int count, ImPlotScatterFlags flags, int offset, int stride);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

// custom
void PlotScatterG(const char* label_id, ImPlotGetter getter_func, void* data, int count, ImPlotScatterFlags flags) {
    GetterFuncPtr getter(getter_func,data, count);
    return PlotScatterEx(label_id, getter, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] PlotStairs
//-----------------------------------------------------------------------------

template <typename Getter>
void PlotStairsEx(const char* label_id, const Getter& getter, ImPlotStairsFlags flags) {
    if (BeginItemEx(label_id, Fitter1<Getter>(getter), flags, ImPlotCol_Line)) {
        if (getter.Count <= 0) {
            EndItem();
            return;
        }
        const ImPlotNextItemData& s = GetItemData();
        if (getter.Count > 1) {
            if (s.RenderFill && ImHasFlag(flags,ImPlotStairsFlags_Shaded)) {
                const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);
                if (ImHasFlag(flags, ImPlotStairsFlags_PreStep))
                    RenderPrimitives1<RendererStairsPreShaded>(getter,col_fill);
                else
                    RenderPrimitives1<RendererStairsPostShaded>(getter,col_fill);
            }
            if (s.RenderLine) {
                const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);
                if (ImHasFlag(flags, ImPlotStairsFlags_PreStep))
                    RenderPrimitives1<RendererStairsPre>(getter,col_line,s.LineWeight);
                else
                    RenderPrimitives1<RendererStairsPost>(getter,col_line,s.LineWeight);
            }
        }
        // render markers
        if (s.Marker != ImPlotMarker_None) {
            PopPlotClipRect();
            PushPlotClipRect(s.MarkerSize);
            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerOutline]);
            const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerFill]);
            RenderMarkers<Getter>(getter, s.Marker, s.MarkerSize, s.RenderMarkerFill, col_fill, s.RenderMarkerLine, col_line, s.MarkerWeight);
        }
        EndItem();
    }
}

template <typename T>
void PlotStairs(const char* label_id, const T* values, int count, double xscale, double x0, ImPlotStairsFlags flags, int offset, int stride) {
    GetterXY<IndexerLin,IndexerIdx<T>> getter(IndexerLin(xscale,x0),IndexerIdx<T>(values,count,offset,stride),count);
    PlotStairsEx(label_id, getter, flags);
}

template <typename T>
void PlotStairs(const char* label_id, const T* xs, const T* ys, int count, ImPlotStairsFlags flags, int offset, int stride) {
    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);
    return PlotStairsEx(label_id, getter, flags);
}

#define INSTANTIATE_MACRO(T) \
    template IMPLOT_API void PlotStairs<T> (const char* label_id, const T* values, int count, double xscale, double x0, ImPlotStairsFlags flags, int offset, int stride); \
    template IMPLOT_API void PlotStairs<T>(const char* label_id, const T* xs, const T* ys, int count, ImPlotStairsFlags flags, int offset, int stride);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

// custom
void PlotStairsG(const char* label_id, ImPlotGetter getter_func, void* data, int count, ImPlotStairsFlags flags) {
    GetterFuncPtr getter(getter_func,data, count);
    return PlotStairsEx(label_id, getter, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] PlotShaded
//-----------------------------------------------------------------------------

template <typename Getter1, typename Getter2>
void PlotShadedEx(const char* label_id, const Getter1& getter1, const Getter2& getter2, ImPlotShadedFlags flags) {
    if (BeginItemEx(label_id, Fitter2<Getter1,Getter2>(getter1,getter2), flags, ImPlotCol_Fill)) {
        if (getter1.Count <= 0 || getter2.Count <= 0) {
            EndItem();
            return;
        }
        const ImPlotNextItemData& s = GetItemData();
        if (s.RenderFill) {
            const ImU32 col = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);
            RenderPrimitives2<RendererShaded>(getter1,getter2,col);
        }
        EndItem();
    }
}

template <typename T>
void PlotShaded(const char* label_id, const T* values, int count, double y_ref, double xscale, double x0, ImPlotShadedFlags flags, int offset, int stride) {
    if (!(y_ref > -DBL_MAX))
        y_ref = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO).Y.Min;
    if (!(y_ref < DBL_MAX))
        y_ref = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO).Y.Max;
    GetterXY<IndexerLin,IndexerIdx<T>> getter1(IndexerLin(xscale,x0),IndexerIdx<T>(values,count,offset,stride),count);
    GetterXY<IndexerLin,IndexerConst>  getter2(IndexerLin(xscale,x0),IndexerConst(y_ref),count);
    PlotShadedEx(label_id, getter1, getter2, flags);
}

template <typename T>
void PlotShaded(const char* label_id, const T* xs, const T* ys, int count, double y_ref, ImPlotShadedFlags flags, int offset, int stride) {
    if (y_ref == -HUGE_VAL)
        y_ref = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO).Y.Min;
    if (y_ref == HUGE_VAL)
        y_ref = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO).Y.Max;
    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter1(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);
    GetterXY<IndexerIdx<T>,IndexerConst>  getter2(IndexerIdx<T>(xs,count,offset,stride),IndexerConst(y_ref),count);
    PlotShadedEx(label_id, getter1, getter2, flags);
}


template <typename T>
void PlotShaded(const char* label_id, const T* xs, const T* ys1, const T* ys2, int count, ImPlotShadedFlags flags, int offset, int stride) {
    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter1(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys1,count,offset,stride),count);
    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter2(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys2,count,offset,stride),count);
    PlotShadedEx(label_id, getter1, getter2, flags);
}

#define INSTANTIATE_MACRO(T) \
    template IMPLOT_API void PlotShaded<T>(const char* label_id, const T* values, int count, double y_ref, double xscale, double x0, ImPlotShadedFlags flags, int offset, int stride); \
    template IMPLOT_API void PlotShaded<T>(const char* label_id, const T* xs, const T* ys, int count, double y_ref, ImPlotShadedFlags flags, int offset, int stride); \
    template IMPLOT_API void PlotShaded<T>(const char* label_id, const T* xs, const T* ys1, const T* ys2, int count, ImPlotShadedFlags flags, int offset, int stride);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

// custom
void PlotShadedG(const char* label_id, ImPlotGetter getter_func1, void* data1, ImPlotGetter getter_func2, void* data2, int count, ImPlotShadedFlags flags) {
    GetterFuncPtr getter1(getter_func1, data1, count);
    GetterFuncPtr getter2(getter_func2, data2, count);
    PlotShadedEx(label_id, getter1, getter2, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] PlotBars
//-----------------------------------------------------------------------------

template <typename Getter1, typename Getter2>
void PlotBarsVEx(const char* label_id, const Getter1& getter1, const Getter2 getter2, double width, ImPlotBarsFlags flags) {
    if (BeginItemEx(label_id, FitterBarV<Getter1,Getter2>(getter1,getter2,width), flags, ImPlotCol_Fill)) {
        if (getter1.Count <= 0 || getter2.Count <= 0) {
            EndItem();
            return;
        }
        const ImPlotNextItemData& s = GetItemData();
        const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);
        const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);
        bool rend_fill = s.RenderFill;
        bool rend_line = s.RenderLine;
        if (rend_fill) {
            RenderPrimitives2<RendererBarsFillV>(getter1,getter2,col_fill,width);
            if (rend_line && col_fill == col_line)
                rend_line = false;
        }
        if (rend_line) {
            RenderPrimitives2<RendererBarsLineV>(getter1,getter2,col_line,width,s.LineWeight);
        }
        EndItem();
    }
}

template <typename Getter1, typename Getter2>
void PlotBarsHEx(const char* label_id, const Getter1& getter1, const Getter2& getter2, double height, ImPlotBarsFlags flags) {
    if (BeginItemEx(label_id, FitterBarH<Getter1,Getter2>(getter1,getter2,height), flags, ImPlotCol_Fill)) {
        if (getter1.Count <= 0 || getter2.Count <= 0) {
            EndItem();
            return;
        }
        const ImPlotNextItemData& s = GetItemData();
        const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]);
        const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);
        bool rend_fill = s.RenderFill;
        bool rend_line = s.RenderLine;
        if (rend_fill) {
            RenderPrimitives2<RendererBarsFillH>(getter1,getter2,col_fill,height);
            if (rend_line && col_fill == col_line)
                rend_line = false;
        }
        if (rend_line) {
            RenderPrimitives2<RendererBarsLineH>(getter1,getter2,col_line,height,s.LineWeight);
        }
        EndItem();
    }
}

template <typename T>
void PlotBars(const char* label_id, const T* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride) {
    if (ImHasFlag(flags, ImPlotBarsFlags_Horizontal)) {
        GetterXY<IndexerIdx<T>,IndexerLin> getter1(IndexerIdx<T>(values,count,offset,stride),IndexerLin(1.0,shift),count);
        GetterXY<IndexerConst,IndexerLin>  getter2(IndexerConst(0),IndexerLin(1.0,shift),count);
        PlotBarsHEx(label_id, getter1, getter2, bar_size, flags);
    }
    else {
        GetterXY<IndexerLin,IndexerIdx<T>> getter1(IndexerLin(1.0,shift),IndexerIdx<T>(values,count,offset,stride),count);
        GetterXY<IndexerLin,IndexerConst>  getter2(IndexerLin(1.0,shift),IndexerConst(0),count);
        PlotBarsVEx(label_id, getter1, getter2, bar_size, flags);
    }
}

template <typename T>
void PlotBars(const char* label_id, const T* xs, const T* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride) {
    if (ImHasFlag(flags, ImPlotBarsFlags_Horizontal)) {
        GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter1(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);
        GetterXY<IndexerConst, IndexerIdx<T>> getter2(IndexerConst(0),IndexerIdx<T>(ys,count,offset,stride),count);
        PlotBarsHEx(label_id, getter1, getter2, bar_size, flags);
    }
    else {
        GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter1(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);
        GetterXY<IndexerIdx<T>,IndexerConst>  getter2(IndexerIdx<T>(xs,count,offset,stride),IndexerConst(0),count);
        PlotBarsVEx(label_id, getter1, getter2, bar_size, flags);
    }
}

#define INSTANTIATE_MACRO(T) \
    template IMPLOT_API void PlotBars<T>(const char* label_id, const T* values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride); \
    template IMPLOT_API void PlotBars<T>(const char* label_id, const T* xs, const T* ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

void PlotBarsG(const char* label_id, ImPlotGetter getter_func, void* data, int count, double bar_size, ImPlotBarsFlags flags) {
    if (ImHasFlag(flags, ImPlotBarsFlags_Horizontal)) {
        GetterFuncPtr getter1(getter_func, data, count);
        GetterOverrideX<GetterFuncPtr> getter2(getter1,0);
        PlotBarsHEx(label_id, getter1, getter2, bar_size, flags);
    }
    else {
        GetterFuncPtr getter1(getter_func, data, count);
        GetterOverrideY<GetterFuncPtr> getter2(getter1,0);
        PlotBarsVEx(label_id, getter1, getter2, bar_size, flags);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] PlotBarGroups
//-----------------------------------------------------------------------------

template <typename T>
void PlotBarGroups(const char* const label_ids[], const T* values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags) {
    const bool horz = ImHasFlag(flags, ImPlotBarGroupsFlags_Horizontal);
    const bool stack = ImHasFlag(flags, ImPlotBarGroupsFlags_Stacked);
    if (stack) {
        SetupLock();
        ImPlotContext& gp = *GImPlot;
        gp.TempDouble1.resize(4*group_count);
        double* temp = gp.TempDouble1.Data;
        double* neg =      &temp[0];
        double* pos =      &temp[group_count];
        double* curr_min = &temp[group_count*2];
        double* curr_max = &temp[group_count*3];
        for (int g = 0; g < group_count*2; ++g)
            temp[g] = 0;
        if (horz) {
            for (int i = 0; i < item_count; ++i) {
                if (!IsItemHidden(label_ids[i])) {
                    for (int g = 0; g < group_count; ++g) {
                        double v = (double)values[i*group_count+g];
                        if (v > 0) {
                            curr_min[g] = pos[g];
                            curr_max[g] = curr_min[g] + v;
                            pos[g]      += v;
                        }
                        else {
                            curr_max[g] = neg[g];
                            curr_min[g] = curr_max[g] + v;
                            neg[g]      += v;
                        }
                    }
                }
                GetterXY<IndexerIdx<double>,IndexerLin> getter1(IndexerIdx<double>(curr_min,group_count),IndexerLin(1.0,shift),group_count);
                GetterXY<IndexerIdx<double>,IndexerLin> getter2(IndexerIdx<double>(curr_max,group_count),IndexerLin(1.0,shift),group_count);
                PlotBarsHEx(label_ids[i],getter1,getter2,group_size,0);
            }
        }
        else {
            for (int i = 0; i < item_count; ++i) {
                if (!IsItemHidden(label_ids[i])) {
                    for (int g = 0; g < group_count; ++g) {
                        double v = (double)values[i*group_count+g];
                        if (v > 0) {
                            curr_min[g] = pos[g];
                            curr_max[g] = curr_min[g] + v;
                            pos[g]      += v;
                        }
                        else {
                            curr_max[g] = neg[g];
                            curr_min[g] = curr_max[g] + v;
                            neg[g]      += v;
                        }
                    }
                }
                GetterXY<IndexerLin,IndexerIdx<double>> getter1(IndexerLin(1.0,shift),IndexerIdx<double>(curr_min,group_count),group_count);
                GetterXY<IndexerLin,IndexerIdx<double>> getter2(IndexerLin(1.0,shift),IndexerIdx<double>(curr_max,group_count),group_count);
                PlotBarsVEx(label_ids[i],getter1,getter2,group_size,0);
            }
        }
    }
    else {
        const double subsize = group_size / item_count;
        if (horz) {
            for (int i = 0; i < item_count; ++i) {
                const double subshift = (i+0.5)*subsize - group_size/2;
                PlotBars(label_ids[i],&values[i*group_count],group_count,subsize,subshift+shift,ImPlotBarsFlags_Horizontal);
            }
        }
        else {
            for (int i = 0; i < item_count; ++i) {
                const double subshift = (i+0.5)*subsize - group_size/2;
                PlotBars(label_ids[i],&values[i*group_count],group_count,subsize,subshift+shift);
            }
        }
    }
}

#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotBarGroups<T>(const char* const label_ids[], const T* values, int items, int groups, double width, double shift, ImPlotBarGroupsFlags flags);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

//-----------------------------------------------------------------------------
// [SECTION] PlotErrorBars
//-----------------------------------------------------------------------------

template <typename _GetterPos, typename _GetterNeg>
void PlotErrorBarsVEx(const char* label_id, const _GetterPos& getter_pos, const _GetterNeg& getter_neg, ImPlotErrorBarsFlags flags) {
    if (BeginItemEx(label_id, Fitter2<_GetterPos,_GetterNeg>(getter_pos, getter_neg), flags, IMPLOT_AUTO)) {
        if (getter_pos.Count <= 0 || getter_neg.Count <= 0) {
            EndItem();
            return;
        }
        const ImPlotNextItemData& s = GetItemData();
        ImDrawList& draw_list = *GetPlotDrawList();
        const ImU32 col = ImGui::GetColorU32(s.Colors[ImPlotCol_ErrorBar]);
        const bool rend_whisker  = s.ErrorBarSize > 0;
        const float half_whisker = s.ErrorBarSize * 0.5f;
        for (int i = 0; i < getter_pos.Count; ++i) {
            ImVec2 p1 = PlotToPixels(getter_neg(i),IMPLOT_AUTO,IMPLOT_AUTO);
            ImVec2 p2 = PlotToPixels(getter_pos(i),IMPLOT_AUTO,IMPLOT_AUTO);
            draw_list.AddLine(p1,p2,col, s.ErrorBarWeight);
            if (rend_whisker) {
                draw_list.AddLine(p1 - ImVec2(half_whisker, 0), p1 + ImVec2(half_whisker, 0), col, s.ErrorBarWeight);
                draw_list.AddLine(p2 - ImVec2(half_whisker, 0), p2 + ImVec2(half_whisker, 0), col, s.ErrorBarWeight);
            }
        }
        EndItem();
    }
}

template <typename _GetterPos, typename _GetterNeg>
void PlotErrorBarsHEx(const char* label_id, const _GetterPos& getter_pos, const _GetterNeg& getter_neg, ImPlotErrorBarsFlags flags) {
    if (BeginItemEx(label_id, Fitter2<_GetterPos,_GetterNeg>(getter_pos, getter_neg), flags, IMPLOT_AUTO)) {
        if (getter_pos.Count <= 0 || getter_neg.Count <= 0) {
            EndItem();
            return;
        }
        const ImPlotNextItemData& s = GetItemData();
        ImDrawList& draw_list = *GetPlotDrawList();
        const ImU32 col = ImGui::GetColorU32(s.Colors[ImPlotCol_ErrorBar]);
        const bool rend_whisker  = s.ErrorBarSize > 0;
        const float half_whisker = s.ErrorBarSize * 0.5f;
        for (int i = 0; i < getter_pos.Count; ++i) {
            ImVec2 p1 = PlotToPixels(getter_neg(i),IMPLOT_AUTO,IMPLOT_AUTO);
            ImVec2 p2 = PlotToPixels(getter_pos(i),IMPLOT_AUTO,IMPLOT_AUTO);
            draw_list.AddLine(p1, p2, col, s.ErrorBarWeight);
            if (rend_whisker) {
                draw_list.AddLine(p1 - ImVec2(0, half_whisker), p1 + ImVec2(0, half_whisker), col, s.ErrorBarWeight);
                draw_list.AddLine(p2 - ImVec2(0, half_whisker), p2 + ImVec2(0, half_whisker), col, s.ErrorBarWeight);
            }
        }
        EndItem();
    }
}

template <typename T>
void PlotErrorBars(const char* label_id, const T* xs, const T* ys, const T* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride) {
    PlotErrorBars(label_id, xs, ys, err, err, count, flags, offset, stride);
}

template <typename T>
void PlotErrorBars(const char* label_id, const T* xs, const T* ys, const T* neg, const T* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride) {
    IndexerIdx<T> indexer_x(xs, count,offset,stride);
    IndexerIdx<T> indexer_y(ys, count,offset,stride);
    IndexerIdx<T> indexer_n(neg,count,offset,stride);
    IndexerIdx<T> indexer_p(pos,count,offset,stride);
    GetterError<T> getter(xs, ys, neg, pos, count, offset, stride);
    if (ImHasFlag(flags, ImPlotErrorBarsFlags_Horizontal)) {
        IndexerAdd<IndexerIdx<T>,IndexerIdx<T>> indexer_xp(indexer_x, indexer_p, 1,  1);
        IndexerAdd<IndexerIdx<T>,IndexerIdx<T>> indexer_xn(indexer_x, indexer_n, 1, -1);
        GetterXY<IndexerAdd<IndexerIdx<T>,IndexerIdx<T>>,IndexerIdx<T>> getter_p(indexer_xp, indexer_y, count);
        GetterXY<IndexerAdd<IndexerIdx<T>,IndexerIdx<T>>,IndexerIdx<T>> getter_n(indexer_xn, indexer_y, count);
        PlotErrorBarsHEx(label_id, getter_p, getter_n, flags);
    }
    else {
        IndexerAdd<IndexerIdx<T>,IndexerIdx<T>> indexer_yp(indexer_y, indexer_p, 1,  1);
        IndexerAdd<IndexerIdx<T>,IndexerIdx<T>> indexer_yn(indexer_y, indexer_n, 1, -1);
        GetterXY<IndexerIdx<T>,IndexerAdd<IndexerIdx<T>,IndexerIdx<T>>> getter_p(indexer_x, indexer_yp, count);
        GetterXY<IndexerIdx<T>,IndexerAdd<IndexerIdx<T>,IndexerIdx<T>>> getter_n(indexer_x, indexer_yn, count);
        PlotErrorBarsVEx(label_id, getter_p, getter_n, flags);
    }
}

#define INSTANTIATE_MACRO(T) \
    template IMPLOT_API void PlotErrorBars<T>(const char* label_id, const T* xs, const T* ys, const T* err, int count, ImPlotErrorBarsFlags flags, int offset, int stride); \
    template IMPLOT_API void PlotErrorBars<T>(const char* label_id, const T* xs, const T* ys, const T* neg, const T* pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

//-----------------------------------------------------------------------------
// [SECTION] PlotStems
//-----------------------------------------------------------------------------

template <typename _GetterM, typename _GetterB>
void PlotStemsEx(const char* label_id, const _GetterM& getter_mark, const _GetterB& getter_base, ImPlotStemsFlags flags) {
    if (BeginItemEx(label_id, Fitter2<_GetterM,_GetterB>(getter_mark,getter_base), flags, ImPlotCol_Line)) {
        if (getter_mark.Count <= 0 || getter_base.Count <= 0) {
            EndItem();
            return;
        }
        const ImPlotNextItemData& s = GetItemData();
        // render stems
        if (s.RenderLine) {
            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);
            RenderPrimitives2<RendererLineSegments2>(getter_mark, getter_base, col_line, s.LineWeight);
        }
        // render markers
        if (s.Marker != ImPlotMarker_None) {
            PopPlotClipRect();
            PushPlotClipRect(s.MarkerSize);
            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerOutline]);
            const ImU32 col_fill = ImGui::GetColorU32(s.Colors[ImPlotCol_MarkerFill]);
            RenderMarkers<_GetterM>(getter_mark, s.Marker, s.MarkerSize, s.RenderMarkerFill, col_fill, s.RenderMarkerLine, col_line, s.MarkerWeight);
        }
        EndItem();
    }
}

template <typename T>
void PlotStems(const char* label_id, const T* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride) {
    if (ImHasFlag(flags, ImPlotStemsFlags_Horizontal)) {
        GetterXY<IndexerIdx<T>,IndexerLin> get_mark(IndexerIdx<T>(values,count,offset,stride),IndexerLin(scale,start),count);
        GetterXY<IndexerConst,IndexerLin>  get_base(IndexerConst(ref),IndexerLin(scale,start),count);
        PlotStemsEx(label_id, get_mark, get_base, flags);
    }
    else {
        GetterXY<IndexerLin,IndexerIdx<T>> get_mark(IndexerLin(scale,start),IndexerIdx<T>(values,count,offset,stride),count);
        GetterXY<IndexerLin,IndexerConst>  get_base(IndexerLin(scale,start),IndexerConst(ref),count);
        PlotStemsEx(label_id, get_mark, get_base, flags);
    }
}

template <typename T>
void PlotStems(const char* label_id, const T* xs, const T* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride) {
    if (ImHasFlag(flags, ImPlotStemsFlags_Horizontal)) {
        GetterXY<IndexerIdx<T>,IndexerIdx<T>> get_mark(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);
        GetterXY<IndexerConst,IndexerIdx<T>>  get_base(IndexerConst(ref),IndexerIdx<T>(ys,count,offset,stride),count);
        PlotStemsEx(label_id, get_mark, get_base, flags);
    }
    else {
        GetterXY<IndexerIdx<T>,IndexerIdx<T>> get_mark(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);
        GetterXY<IndexerIdx<T>,IndexerConst>  get_base(IndexerIdx<T>(xs,count,offset,stride),IndexerConst(ref),count);
        PlotStemsEx(label_id, get_mark, get_base, flags);
    }
}

#define INSTANTIATE_MACRO(T) \
    template IMPLOT_API void PlotStems<T>(const char* label_id, const T* values, int count, double ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride); \
    template IMPLOT_API void PlotStems<T>(const char* label_id, const T* xs, const T* ys, int count, double ref, ImPlotStemsFlags flags, int offset, int stride);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO


//-----------------------------------------------------------------------------
// [SECTION] PlotInfLines
//-----------------------------------------------------------------------------

template <typename T>
void PlotInfLines(const char* label_id, const T* values, int count, ImPlotInfLinesFlags flags, int offset, int stride) {
    const ImPlotRect lims = GetPlotLimits(IMPLOT_AUTO,IMPLOT_AUTO);
    if (ImHasFlag(flags, ImPlotInfLinesFlags_Horizontal)) {
        GetterXY<IndexerConst,IndexerIdx<T>> getter_min(IndexerConst(lims.X.Min),IndexerIdx<T>(values,count,offset,stride),count);
        GetterXY<IndexerConst,IndexerIdx<T>> getter_max(IndexerConst(lims.X.Max),IndexerIdx<T>(values,count,offset,stride),count);
        if (BeginItemEx(label_id, FitterY<GetterXY<IndexerConst,IndexerIdx<T>>>(getter_min), flags, ImPlotCol_Line)) {
            if (count <= 0) {
                EndItem();
                return;
            }
            const ImPlotNextItemData& s = GetItemData();
            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);
            if (s.RenderLine)
                RenderPrimitives2<RendererLineSegments2>(getter_min, getter_max, col_line, s.LineWeight);
            EndItem();
        }
    }
    else {
        GetterXY<IndexerIdx<T>,IndexerConst> get_min(IndexerIdx<T>(values,count,offset,stride),IndexerConst(lims.Y.Min),count);
        GetterXY<IndexerIdx<T>,IndexerConst> get_max(IndexerIdx<T>(values,count,offset,stride),IndexerConst(lims.Y.Max),count);
        if (BeginItemEx(label_id, FitterX<GetterXY<IndexerIdx<T>,IndexerConst>>(get_min), flags, ImPlotCol_Line)) {
            if (count <= 0) {
                EndItem();
                return;
            }
            const ImPlotNextItemData& s = GetItemData();
            const ImU32 col_line = ImGui::GetColorU32(s.Colors[ImPlotCol_Line]);
            if (s.RenderLine)
                RenderPrimitives2<RendererLineSegments2>(get_min, get_max, col_line, s.LineWeight);
            EndItem();
        }
    }
}
#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotInfLines<T>(const char* label_id, const T* xs, int count, ImPlotInfLinesFlags flags, int offset, int stride);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

//-----------------------------------------------------------------------------
// [SECTION] PlotPieChart
//-----------------------------------------------------------------------------

IMPLOT_INLINE void RenderPieSlice(ImDrawList& draw_list, const ImPlotPoint& center, double radius, double a0, double a1, ImU32 col, bool detached = false) {
    const float resolution = 50 / (2 * IM_PI);
    ImVec2 buffer[52];
    
    int n = ImMax(3, (int)((a1 - a0) * resolution));
    double da = (a1 - a0) / (n - 1);
    int i = 0;

    if (detached) {
        const double offset = 0.08; // Offset of the detached slice
        const double width_scale = 0.95; // Scale factor for the width of the detached slice
        
        double a_mid = (a0 + a1) / 2;
        double new_a0 = a_mid - (a1 - a0) * width_scale / 2;
        double new_a1 = a_mid + (a1 - a0) * width_scale / 2;
        double new_da = (new_a1 - new_a0) / (n - 1);
        
        ImPlotPoint offsetCenter(center.x + offset * cos(a_mid), center.y + offset * sin(a_mid));
        
        // Start point (center of the offset)
        buffer[0] = PlotToPixels(offsetCenter, IMPLOT_AUTO, IMPLOT_AUTO);

        for (; i < n; ++i) {
            double a = new_a0 + i * new_da;
            buffer[i + 1] = PlotToPixels(
                offsetCenter.x + (radius + offset/2) * cos(a),
                offsetCenter.y + (radius + offset/2) * sin(a),
                IMPLOT_AUTO, IMPLOT_AUTO
            );
        }

    } else {
        buffer[0] = PlotToPixels(center, IMPLOT_AUTO, IMPLOT_AUTO);
        for (; i < n; ++i) {
            double a = a0 + i * da;
            buffer[i + 1] = PlotToPixels(
                center.x + radius * cos(a), 
                center.y + radius * sin(a), 
                IMPLOT_AUTO, IMPLOT_AUTO);
        }
    }
    // Close the shape
    buffer[i + 1] = buffer[0];
    
    // fill
    draw_list.AddConvexPolyFilled(buffer, n + 2, col);
    
    // border (for AA)
    draw_list.AddPolyline(buffer, n + 2, col, 0, 2.0f);
}

template <typename T>
double PieChartSum(const T* values, int count, bool ignore_hidden) {
    double sum = 0;
    if (ignore_hidden) {
        ImPlotContext& gp = *GImPlot;
        ImPlotItemGroup& Items = *gp.CurrentItems;
        for (int i = 0; i < count; ++i) {
            if (i >= Items.GetItemCount())
                break;

            ImPlotItem* item = Items.GetItemByIndex(i);
            IM_ASSERT(item != nullptr);
            if (item->Show) {
                sum += (double)values[i];
            }
        }
    }
    else {
        for (int i = 0; i < count; ++i) {
            sum += (double)values[i];
        }
    }
    return sum;
}

template <typename T>
void PlotPieChartEx(const char* const label_ids[], const T* values, int count, ImPlotPoint center, double radius, double angle0, ImPlotPieChartFlags flags) {
    ImDrawList& draw_list  = *GetPlotDrawList();

    const bool ignore_hidden = ImHasFlag(flags, ImPlotPieChartFlags_IgnoreHidden);
    const double sum         = PieChartSum(values, count, ignore_hidden);
    const bool normalize     = ImHasFlag(flags, ImPlotPieChartFlags_Normalize) || sum > 1.0;

    double a0 = angle0 * 2 * IM_PI / 360.0;
    double a1 = angle0 * 2 * IM_PI / 360.0;
    ImPlotPoint Pmin = ImPlotPoint(center.x - radius, center.y - radius);
    ImPlotPoint Pmax = ImPlotPoint(center.x + radius, center.y + radius);
    for (int i = 0; i < count; ++i) {
        ImPlotItem* item = GetItem(label_ids[i]);
        const double percent = normalize ? (double)values[i] / sum : (double)values[i];
        const bool skip      = sum <= 0.0 || (ignore_hidden && item != nullptr && !item->Show);
        if (!skip)
            a1 = a0 + 2 * IM_PI * percent;

        if (BeginItemEx(label_ids[i], FitterRect(Pmin, Pmax))) {
            const bool hovered = ImPlot::IsLegendEntryHovered(label_ids[i]) && ImHasFlag(flags, ImPlotPieChartFlags_Exploding);
            if (sum > 0.0) {
                ImU32 col = GetCurrentItem()->Color;
                if (percent < 0.5) {
                    RenderPieSlice(draw_list, center, radius, a0, a1, col, hovered);
                }
                else {
                    RenderPieSlice(draw_list, center, radius, a0, a0 + (a1 - a0) * 0.5, col, hovered);
                    RenderPieSlice(draw_list, center, radius, a0 + (a1 - a0) * 0.5, a1, col, hovered);
                }
            }
            EndItem();
        }
        if (!skip)
            a0 = a1;
    }
}

int PieChartFormatter(double value, char* buff, int size, void* data) {
    const char* fmt = (const char*)data;
    return snprintf(buff, size, fmt, value);
};

template <typename T>
void PlotPieChart(const char* const label_ids[], const T* values, int count, double x, double y, double radius, const char* fmt, double angle0, ImPlotPieChartFlags flags) {
    PlotPieChart<T>(label_ids, values, count, x, y, radius, PieChartFormatter, (void*)fmt, angle0, flags);
}
#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotPieChart<T>(const char* const label_ids[], const T* values, int count, double x, double y, double radius, const char* fmt, double angle0, ImPlotPieChartFlags flags);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

template <typename T>
void PlotPieChart(const char* const label_ids[], const T* values, int count, double x, double y, double radius, ImPlotFormatter fmt, void* fmt_data, double angle0, ImPlotPieChartFlags flags) {
    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, "PlotPieChart() needs to be called between BeginPlot() and EndPlot()!");
    ImDrawList& draw_list = *GetPlotDrawList();

    const bool ignore_hidden = ImHasFlag(flags, ImPlotPieChartFlags_IgnoreHidden);
    const double sum = PieChartSum(values, count, ignore_hidden);
    const bool normalize = ImHasFlag(flags, ImPlotPieChartFlags_Normalize) || sum > 1.0;
    ImPlotPoint center(x, y);

    PushPlotClipRect();
    PlotPieChartEx(label_ids, values, count, center, radius, angle0, flags);
    if (fmt != nullptr) {
        double a0 = angle0 * 2 * IM_PI / 360.0;
        double a1 = angle0 * 2 * IM_PI / 360.0;
        char buffer[32];
        for (int i = 0; i < count; ++i) {
            ImPlotItem* item = GetItem(label_ids[i]);
            IM_ASSERT(item != nullptr);

            const double percent = normalize ? (double)values[i] / sum : (double)values[i];
            const bool skip = ignore_hidden && item != nullptr && !item->Show;

            if (!skip) {
                a1 = a0 + 2 * IM_PI * percent;
                if (item->Show) {
                    fmt((double)values[i], buffer, 32, fmt_data);
                    ImVec2 size = ImGui::CalcTextSize(buffer);
                    double angle = a0 + (a1 - a0) * 0.5;
                    const bool hovered = ImPlot::IsLegendEntryHovered(label_ids[i]) && ImHasFlag(flags, ImPlotPieChartFlags_Exploding);
                    const double offset = (hovered ? 0.6 : 0.5) * radius; 
                    ImVec2 pos = PlotToPixels(center.x + offset * cos(angle), center.y + offset * sin(angle), IMPLOT_AUTO, IMPLOT_AUTO);
                    ImU32 col = CalcTextColor(ImGui::ColorConvertU32ToFloat4(item->Color));
                    draw_list.AddText(pos - size * 0.5f, col, buffer);
                }
                a0 = a1;
            }
        }
    }
    PopPlotClipRect();
}
#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotPieChart(const char* const label_ids[], const T* values, int count, double x, double y, double radius, ImPlotFormatter fmt, void* fmt_data, double angle0, ImPlotPieChartFlags flags);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

//-----------------------------------------------------------------------------
// [SECTION] PlotHeatmap
//-----------------------------------------------------------------------------

template <typename T>
struct GetterHeatmapRowMaj {
    GetterHeatmapRowMaj(const T* values, int rows, int cols, double scale_min, double scale_max, double width, double height, double xref, double yref, double ydir) :
        Values(values),
        Count(rows*cols),
        Rows(rows),
        Cols(cols),
        ScaleMin(scale_min),
        ScaleMax(scale_max),
        Width(width),
        Height(height),
        XRef(xref),
        YRef(yref),
        YDir(ydir),
        HalfSize(Width*0.5, Height*0.5)
    { }
    template <typename I> IMPLOT_INLINE RectC operator()(I idx) const {
        double val = (double)Values[idx];
        const int r = idx / Cols;
        const int c = idx % Cols;
        const ImPlotPoint p(XRef + HalfSize.x + c*Width, YRef + YDir * (HalfSize.y + r*Height));
        RectC rect;
        rect.Pos = p;
        rect.HalfSize = HalfSize;
        const float t = ImClamp((float)ImRemap01(val, ScaleMin, ScaleMax),0.0f,1.0f);
        ImPlotContext& gp = *GImPlot;
        rect.Color = gp.ColormapData.LerpTable(gp.Style.Colormap, t);
        return rect;
    }
    const T* const Values;
    const int Count, Rows, Cols;
    const double ScaleMin, ScaleMax, Width, Height, XRef, YRef, YDir;
    const ImPlotPoint HalfSize;
};

template <typename T>
struct GetterHeatmapColMaj {
    GetterHeatmapColMaj(const T* values, int rows, int cols, double scale_min, double scale_max, double width, double height, double xref, double yref, double ydir) :
        Values(values),
        Count(rows*cols),
        Rows(rows),
        Cols(cols),
        ScaleMin(scale_min),
        ScaleMax(scale_max),
        Width(width),
        Height(height),
        XRef(xref),
        YRef(yref),
        YDir(ydir),
        HalfSize(Width*0.5, Height*0.5)
    { }
    template <typename I> IMPLOT_INLINE RectC operator()(I idx) const {
        double val = (double)Values[idx];
        const int r = idx % Rows;
        const int c = idx / Rows;
        const ImPlotPoint p(XRef + HalfSize.x + c*Width, YRef + YDir * (HalfSize.y + r*Height));
        RectC rect;
        rect.Pos = p;
        rect.HalfSize = HalfSize;
        const float t = ImClamp((float)ImRemap01(val, ScaleMin, ScaleMax),0.0f,1.0f);
        ImPlotContext& gp = *GImPlot;
        rect.Color = gp.ColormapData.LerpTable(gp.Style.Colormap, t);
        return rect;
    }
    const T* const Values;
    const int Count, Rows, Cols;
    const double ScaleMin, ScaleMax, Width, Height, XRef, YRef, YDir;
    const ImPlotPoint HalfSize;
};

template <typename T>
void RenderHeatmap(ImDrawList& draw_list, const T* values, int rows, int cols, double scale_min, double scale_max, const char* fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, bool reverse_y, bool col_maj) {
    ImPlotContext& gp = *GImPlot;
    Transformer2 transformer;
    if (scale_min == 0 && scale_max == 0) {
        T temp_min, temp_max;
        ImMinMaxArray(values,rows*cols,&temp_min,&temp_max);
        scale_min = (double)temp_min;
        scale_max = (double)temp_max;
    }
    if (scale_min == scale_max) {
        ImVec2 a = transformer(bounds_min);
        ImVec2 b = transformer(bounds_max);
        ImU32  col = GetColormapColorU32(0,gp.Style.Colormap);
        draw_list.AddRectFilled(a, b, col);
        return;
    }
    const double yref = reverse_y ? bounds_max.y : bounds_min.y;
    const double ydir = reverse_y ? -1 : 1;
    if (col_maj) {
        GetterHeatmapColMaj<T> getter(values, rows, cols, scale_min, scale_max, (bounds_max.x - bounds_min.x) / cols, (bounds_max.y - bounds_min.y) / rows, bounds_min.x, yref, ydir);
        RenderPrimitives1<RendererRectC>(getter);
    }
    else {
        GetterHeatmapRowMaj<T> getter(values, rows, cols, scale_min, scale_max, (bounds_max.x - bounds_min.x) / cols, (bounds_max.y - bounds_min.y) / rows, bounds_min.x, yref, ydir);
        RenderPrimitives1<RendererRectC>(getter);
    }
    // labels
    if (fmt != nullptr) {
        const double w = (bounds_max.x - bounds_min.x) / cols;
        const double h = (bounds_max.y - bounds_min.y) / rows;
        const ImPlotPoint half_size(w*0.5,h*0.5);
        int i = 0;
        if (col_maj) {
            for (int c = 0; c < cols; ++c) {
                for (int r = 0; r < rows; ++r) {
                    ImPlotPoint p;
                    p.x = bounds_min.x + 0.5*w + c*w;
                    p.y = yref + ydir * (0.5*h + r*h);
                    ImVec2 px = transformer(p);
                    char buff[32];
                    ImFormatString(buff, 32, fmt, values[i]);
                    ImVec2 size = ImGui::CalcTextSize(buff);
                    double t = ImClamp(ImRemap01((double)values[i], scale_min, scale_max),0.0,1.0);
                    ImVec4 color = SampleColormap((float)t);
                    ImU32 col = CalcTextColor(color);
                    draw_list.AddText(px - size * 0.5f, col, buff);
                    i++;
                }
            }
        }
        else {
            for (int r = 0; r < rows; ++r) {
                for (int c = 0; c < cols; ++c) {
                    ImPlotPoint p;
                    p.x = bounds_min.x + 0.5*w + c*w;
                    p.y = yref + ydir * (0.5*h + r*h);
                    ImVec2 px = transformer(p);
                    char buff[32];
                    ImFormatString(buff, 32, fmt, values[i]);
                    ImVec2 size = ImGui::CalcTextSize(buff);
                    double t = ImClamp(ImRemap01((double)values[i], scale_min, scale_max),0.0,1.0);
                    ImVec4 color = SampleColormap((float)t);
                    ImU32 col = CalcTextColor(color);
                    draw_list.AddText(px - size * 0.5f, col, buff);
                    i++;
                }
            }
        }
    }
}

template <typename T>
void PlotHeatmap(const char* label_id, const T* values, int rows, int cols, double scale_min, double scale_max, const char* fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags) {
    if (BeginItemEx(label_id, FitterRect(bounds_min, bounds_max))) {
        if (rows <= 0 || cols <= 0) {
            EndItem();
            return;
        }
        ImDrawList& draw_list = *GetPlotDrawList();
        const bool col_maj = ImHasFlag(flags, ImPlotHeatmapFlags_ColMajor);
        RenderHeatmap(draw_list, values, rows, cols, scale_min, scale_max, fmt, bounds_min, bounds_max, true, col_maj);
        EndItem();
    }
}
#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotHeatmap<T>(const char* label_id, const T* values, int rows, int cols, double scale_min, double scale_max, const char* fmt, const ImPlotPoint& bounds_min, const ImPlotPoint& bounds_max, ImPlotHeatmapFlags flags);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

//-----------------------------------------------------------------------------
// [SECTION] PlotHistogram
//-----------------------------------------------------------------------------

template <typename T>
double PlotHistogram(const char* label_id, const T* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags) {

    const bool cumulative = ImHasFlag(flags, ImPlotHistogramFlags_Cumulative);
    const bool density    = ImHasFlag(flags, ImPlotHistogramFlags_Density);
    const bool outliers   = !ImHasFlag(flags, ImPlotHistogramFlags_NoOutliers);

    if (count <= 0 || bins == 0)
        return 0;

    if (range.Min == 0 && range.Max == 0) {
        T Min, Max;
        ImMinMaxArray(values, count, &Min, &Max);
        range.Min = (double)Min;
        range.Max = (double)Max;
    }

    double width;
    if (bins < 0)
        CalculateBins(values, count, bins, range, bins, width);
    else
        width = range.Size() / bins;

    ImPlotContext& gp = *GImPlot;
    ImVector<double>& bin_centers = gp.TempDouble1;
    ImVector<double>& bin_counts  = gp.TempDouble2;
    bin_centers.resize(bins);
    bin_counts.resize(bins);
    int below = 0;

    for (int b = 0; b < bins; ++b) {
        bin_centers[b] = range.Min + b * width + width * 0.5;
        bin_counts[b] = 0;
    }
    int counted = 0;
    double max_count = 0;
    for (int i = 0; i < count; ++i) {
        double val = (double)values[i];
        if (range.Contains(val)) {
            const int b = ImClamp((int)((val - range.Min) / width), 0, bins - 1);
            bin_counts[b] += 1.0;
            if (bin_counts[b] > max_count)
                max_count = bin_counts[b];
            counted++;
        }
        else if (val < range.Min) {
            below++;
        }
    }
    if (cumulative && density) {
        if (outliers)
            bin_counts[0] += below;
        for (int b = 1; b < bins; ++b)
            bin_counts[b] += bin_counts[b-1];
        double scale = 1.0 / (outliers ? count : counted);
        for (int b = 0; b < bins; ++b)
            bin_counts[b] *= scale;
        max_count = bin_counts[bins-1];
    }
    else if (cumulative) {
        if (outliers)
            bin_counts[0] += below;
        for (int b = 1; b < bins; ++b)
            bin_counts[b] += bin_counts[b-1];
        max_count = bin_counts[bins-1];
    }
    else if (density) {
        double scale = 1.0 / ((outliers ? count : counted) * width);
        for (int b = 0; b < bins; ++b)
            bin_counts[b] *= scale;
        max_count *= scale;
    }
    if (ImHasFlag(flags, ImPlotHistogramFlags_Horizontal))
        PlotBars(label_id, &bin_counts.Data[0], &bin_centers.Data[0], bins, bar_scale*width, ImPlotBarsFlags_Horizontal);
    else
        PlotBars(label_id, &bin_centers.Data[0], &bin_counts.Data[0], bins, bar_scale*width);
    return max_count;
}
#define INSTANTIATE_MACRO(T) template IMPLOT_API double PlotHistogram<T>(const char* label_id, const T* values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

//-----------------------------------------------------------------------------
// [SECTION] PlotHistogram2D
//-----------------------------------------------------------------------------

template <typename T>
double PlotHistogram2D(const char* label_id, const T* xs, const T* ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags) {

    // const bool cumulative = ImHasFlag(flags, ImPlotHistogramFlags_Cumulative); NOT SUPPORTED
    const bool density  = ImHasFlag(flags, ImPlotHistogramFlags_Density);
    const bool outliers = !ImHasFlag(flags, ImPlotHistogramFlags_NoOutliers);
    const bool col_maj  = ImHasFlag(flags, ImPlotHistogramFlags_ColMajor);

    if (count <= 0 || x_bins == 0 || y_bins == 0)
        return 0;

    if (range.X.Min == 0 && range.X.Max == 0) {
        T Min, Max;
        ImMinMaxArray(xs, count, &Min, &Max);
        range.X.Min = (double)Min;
        range.X.Max = (double)Max;
    }
    if (range.Y.Min == 0 && range.Y.Max == 0) {
        T Min, Max;
        ImMinMaxArray(ys, count, &Min, &Max);
        range.Y.Min = (double)Min;
        range.Y.Max = (double)Max;
    }

    double width, height;
    if (x_bins < 0)
        CalculateBins(xs, count, x_bins, range.X, x_bins, width);
    else
        width = range.X.Size() / x_bins;
    if (y_bins < 0)
        CalculateBins(ys, count, y_bins, range.Y, y_bins, height);
    else
        height = range.Y.Size() / y_bins;

    const int bins = x_bins * y_bins;

    ImPlotContext& gp = *GImPlot;
    ImVector<double>& bin_counts = gp.TempDouble1;
    bin_counts.resize(bins);

    for (int b = 0; b < bins; ++b)
        bin_counts[b] = 0;

    int counted = 0;
    double max_count = 0;
    for (int i = 0; i < count; ++i) {
        if (range.Contains((double)xs[i], (double)ys[i])) {
            const int xb = ImClamp( (int)((double)(xs[i] - range.X.Min) / width)  , 0, x_bins - 1);
            const int yb = ImClamp( (int)((double)(ys[i] - range.Y.Min) / height) , 0, y_bins - 1);
            const int b  = yb * x_bins + xb;
            bin_counts[b] += 1.0;
            if (bin_counts[b] > max_count)
                max_count = bin_counts[b];
            counted++;
        }
    }
    if (density) {
        double scale = 1.0 / ((outliers ? count : counted) * width * height);
        for (int b = 0; b < bins; ++b)
            bin_counts[b] *= scale;
        max_count *= scale;
    }

    if (BeginItemEx(label_id, FitterRect(range))) {
        if (y_bins <= 0 || x_bins <= 0) {
            EndItem();
            return max_count;
        }
        ImDrawList& draw_list = *GetPlotDrawList();
        RenderHeatmap(draw_list, &bin_counts.Data[0], y_bins, x_bins, 0, max_count, nullptr, range.Min(), range.Max(), false, col_maj);
        EndItem();
    }
    return max_count;
}
#define INSTANTIATE_MACRO(T) template IMPLOT_API double PlotHistogram2D<T>(const char* label_id,   const T*   xs, const T*   ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

//-----------------------------------------------------------------------------
// [SECTION] PlotDigital
//-----------------------------------------------------------------------------

// TODO: Make this behave like all the other plot types (.e. not fixed in y axis)

template <typename Getter>
void PlotDigitalEx(const char* label_id, Getter getter, ImPlotDigitalFlags flags) {
    if (BeginItem(label_id, flags, ImPlotCol_Fill)) {
        ImPlotContext& gp = *GImPlot;
        ImDrawList& draw_list = *GetPlotDrawList();
        const ImPlotNextItemData& s = GetItemData();
        if (getter.Count > 1 && s.RenderFill) {
            ImPlotPlot& plot   = *gp.CurrentPlot;
            ImPlotAxis& x_axis = plot.Axes[plot.CurrentX];
            ImPlotAxis& y_axis = plot.Axes[plot.CurrentY];

            int pixYMax = 0;
            ImPlotPoint itemData1 = getter(0);
            for (int i = 0; i < getter.Count; ++i) {
                ImPlotPoint itemData2 = getter(i);
                if (ImNanOrInf(itemData1.y)) {
                    itemData1 = itemData2;
                    continue;
                }
                if (ImNanOrInf(itemData2.y)) itemData2.y = ImConstrainNan(ImConstrainInf(itemData2.y));
                int pixY_0 = (int)(s.LineWeight);
                itemData1.y = ImMax(0.0, itemData1.y);
                float pixY_1_float = s.DigitalBitHeight * (float)itemData1.y;
                int pixY_1 = (int)(pixY_1_float); //allow only positive values
                int pixY_chPosOffset = (int)(ImMax(s.DigitalBitHeight, pixY_1_float) + s.DigitalBitGap);
                pixYMax = ImMax(pixYMax, pixY_chPosOffset);
                ImVec2 pMin = PlotToPixels(itemData1,IMPLOT_AUTO,IMPLOT_AUTO);
                ImVec2 pMax = PlotToPixels(itemData2,IMPLOT_AUTO,IMPLOT_AUTO);
                int pixY_Offset = 0; //20 pixel from bottom due to mouse cursor label
                pMin.y = (y_axis.PixelMin) + ((-gp.DigitalPlotOffset)                   - pixY_Offset);
                pMax.y = (y_axis.PixelMin) + ((-gp.DigitalPlotOffset) - pixY_0 - pixY_1 - pixY_Offset);
                //plot only one rectangle for same digital state
                while (((i+2) < getter.Count) && (itemData1.y == itemData2.y)) {
                    const int in = (i + 1);
                    itemData2 = getter(in);
                    if (ImNanOrInf(itemData2.y)) break;
                    pMax.x = PlotToPixels(itemData2,IMPLOT_AUTO,IMPLOT_AUTO).x;
                    i++;
                }
                //do not extend plot outside plot range
                if (pMin.x < x_axis.PixelMin) pMin.x = x_axis.PixelMin;
                if (pMax.x < x_axis.PixelMin) pMax.x = x_axis.PixelMin;
                if (pMin.x > x_axis.PixelMax) pMin.x = x_axis.PixelMax - 1; //fix issue related to https://github.com/ocornut/imgui/issues/3976
                if (pMax.x > x_axis.PixelMax) pMax.x = x_axis.PixelMax - 1; //fix issue related to https://github.com/ocornut/imgui/issues/3976
                //plot a rectangle that extends up to x2 with y1 height
                if ((pMax.x > pMin.x) && (gp.CurrentPlot->PlotRect.Contains(pMin) || gp.CurrentPlot->PlotRect.Contains(pMax))) {
                    // ImVec4 colAlpha = item->Color;
                    // colAlpha.w = item->Highlight ? 1.0f : 0.9f;
                    draw_list.AddRectFilled(pMin, pMax, ImGui::GetColorU32(s.Colors[ImPlotCol_Fill]));
                }
                itemData1 = itemData2;
            }
            gp.DigitalPlotItemCnt++;
            gp.DigitalPlotOffset += pixYMax;
        }
        EndItem();
    }
}


template <typename T>
void PlotDigital(const char* label_id, const T* xs, const T* ys, int count, ImPlotDigitalFlags flags, int offset, int stride) {
    GetterXY<IndexerIdx<T>,IndexerIdx<T>> getter(IndexerIdx<T>(xs,count,offset,stride),IndexerIdx<T>(ys,count,offset,stride),count);
    return PlotDigitalEx(label_id, getter, flags);
}
#define INSTANTIATE_MACRO(T) template IMPLOT_API void PlotDigital<T>(const char* label_id, const T* xs, const T* ys, int count, ImPlotDigitalFlags flags, int offset, int stride);
CALL_INSTANTIATE_FOR_NUMERIC_TYPES()
#undef INSTANTIATE_MACRO

// custom
void PlotDigitalG(const char* label_id, ImPlotGetter getter_func, void* data, int count, ImPlotDigitalFlags flags) {
    GetterFuncPtr getter(getter_func,data,count);
    return PlotDigitalEx(label_id, getter, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] PlotImage
//-----------------------------------------------------------------------------

#ifdef IMGUI_HAS_TEXTURES
void PlotImage(const char* label_id, ImTextureRef tex_ref, const ImPlotPoint& bmin, const ImPlotPoint& bmax, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, ImPlotImageFlags) {
#else
void PlotImage(const char* label_id, ImTextureID tex_ref, const ImPlotPoint& bmin, const ImPlotPoint& bmax, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, ImPlotImageFlags) {
#endif
    if (BeginItemEx(label_id, FitterRect(bmin,bmax))) {
        ImU32 tint_col32 = ImGui::ColorConvertFloat4ToU32(tint_col);
        GetCurrentItem()->Color = tint_col32;
        ImDrawList& draw_list = *GetPlotDrawList();
        ImVec2 p1 = PlotToPixels(bmin.x, bmax.y,IMPLOT_AUTO,IMPLOT_AUTO);
        ImVec2 p2 = PlotToPixels(bmax.x, bmin.y,IMPLOT_AUTO,IMPLOT_AUTO);
        PushPlotClipRect();
        draw_list.AddImage(tex_ref, p1, p2, uv0, uv1, tint_col32);
        PopPlotClipRect();
        EndItem();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] PlotText
//-----------------------------------------------------------------------------

void PlotText(const char* text, double x, double y, const ImVec2& pixel_offset, ImPlotTextFlags flags) {
    IM_ASSERT_USER_ERROR(GImPlot->CurrentPlot != nullptr, "PlotText() needs to be called between BeginPlot() and EndPlot()!");
    SetupLock();
    ImDrawList & draw_list = *GetPlotDrawList();
    PushPlotClipRect();
    ImU32 colTxt = GetStyleColorU32(ImPlotCol_InlayText);
    if (ImHasFlag(flags,ImPlotTextFlags_Vertical)) {
        ImVec2 siz = CalcTextSizeVertical(text) * 0.5f;
        ImVec2 ctr = siz * 0.5f;
        ImVec2 pos = PlotToPixels(ImPlotPoint(x,y),IMPLOT_AUTO,IMPLOT_AUTO) + ImVec2(-ctr.x, ctr.y) + pixel_offset;
        if (FitThisFrame() && !ImHasFlag(flags, ImPlotItemFlags_NoFit)) {
            FitPoint(PixelsToPlot(pos));
            FitPoint(PixelsToPlot(pos.x + siz.x, pos.y - siz.y));
        }
        AddTextVertical(&draw_list, pos, colTxt, text);
    }
    else {
        ImVec2 siz = ImGui::CalcTextSize(text);
        ImVec2 pos = PlotToPixels(ImPlotPoint(x,y),IMPLOT_AUTO,IMPLOT_AUTO) - siz * 0.5f + pixel_offset;
        if (FitThisFrame() && !ImHasFlag(flags, ImPlotItemFlags_NoFit)) {
            FitPoint(PixelsToPlot(pos));
            FitPoint(PixelsToPlot(pos+siz));
        }
        draw_list.AddText(pos, colTxt, text);
    }
    PopPlotClipRect();
}

//-----------------------------------------------------------------------------
// [SECTION] PlotDummy
//-----------------------------------------------------------------------------

void PlotDummy(const char* label_id, ImPlotDummyFlags flags) {
    if (BeginItem(label_id, flags, ImPlotCol_Line))
        EndItem();
}

} // namespace ImPlot

#endif // #ifndef IMGUI_DISABLE
#include "InputRouter.h"
#include "Clock.h"
#include "TrackerSequencer.h"
#include "TrackerSequencerGUI.h"
#include "gui/ViewManager.h"
#include "MediaPool.h"
#include "MediaPoolGUI.h"
#include "ofxImGui.h"
#include "ofLog.h"

InputRouter::InputRouter() {
}

void InputRouter::setup(
    Clock* clock_,
    TrackerSequencer* tracker_,
    TrackerSequencerGUI* trackerGUI_,
    ViewManager* viewManager_,
    MediaPool* mediaPool_,
    MediaPoolGUI* mediaPoolGUI_
) {
    clock = clock_;
    tracker = tracker_;
    trackerGUI = trackerGUI_;
    viewManager = viewManager_;
    mediaPool = mediaPool_;
    mediaPoolGUI = mediaPoolGUI_;

    ofLogNotice("InputRouter") << "Setup complete";
}

void InputRouter::setPlayState(bool* isPlaying_) {
    isPlaying = isPlaying_;
}

void InputRouter::setCurrentStep(int* currentStep_) {
    currentStep = currentStep_;
}

void InputRouter::setLastTriggeredStep(int* lastTriggeredStep_) {
    lastTriggeredStep = lastTriggeredStep_;
}

void InputRouter::setShowGUI(bool* showGUI_) {
    showGUI = showGUI_;
}

bool InputRouter::handleKeyPress(ofKeyEventArgs& keyEvent) {
    int key = keyEvent.key;
    
    // LOG: Entry point for all key presses
    ofLogNotice("InputRouter") << "=== KEY PRESS: key=" << key 
        << " ('" << (char)key << "')";
    
    // Priority 1: Panel navigation (Ctrl+Tab / Ctrl+Shift+Tab) - check BEFORE ImGui processes
    // IMPORTANT: Use OF_KEY_CONTROL (not COMMAND) for Ctrl key
    // On Mac: OF_KEY_CONTROL = Control key, OF_KEY_COMMAND = Command key (âŒ˜)
    if (key == OF_KEY_TAB) {
        bool ctrlPressed = keyEvent.hasModifier(OF_KEY_CONTROL);
        if (ctrlPressed) {
            if (handlePanelNavigation(keyEvent)) {
                return true;
            }
        }
        // Regular Tab (without Ctrl) - let ImGui handle it for native navigation
        // Don't return false here, let it fall through to ImGui processing
    }
    
    updateImGuiCaptureState();
    
    // Priority 2: Spacebar - ALWAYS works (global transport control)
    // Handle spacebar BEFORE other checks to ensure it always works
    if (key == ' ') {
        // Alt+Spacebar: Trigger current edit step
        if (keyEvent.hasModifier(OF_KEY_ALT)) {
            if (tracker) {
                int editStep = tracker->getEditStep();
                if (editStep >= 0) {
                    tracker->triggerStep(editStep);
                    logKeyPress(key, "Alt+Spacebar: Trigger step");
                    return true;
                }
            }
        }
        // Regular Spacebar: Play/Stop (always works, even when ImGui has focus)
        if (handleGlobalShortcuts(key)) {
            return true;
        }
    }
    
    // Priority 3: Other global shortcuts - only when ImGui isn't busy
    if (!ImGui::IsAnyItemActive() && !ImGui::GetIO().WantCaptureMouse) {
        if (handleGlobalShortcuts(key)) {
            return true;
        }
    }
    
    // Priority 4: Tracker input - only when in tracker panel
    // CRITICAL: Route tracker input BEFORE ImGui can consume it, even if ImGui wants keyboard
    // This ensures Enter and numeric keys work when cells are focused
    // 
    // IMPORTANT: We check multiple conditions to determine if we're in the tracker panel:
    // 1. Panel index == 2 (official tracker panel)
    // 2. OR a tracker cell is focused (editStep/editColumn are valid)
    // This handles both docked windows and regular panel navigation
    int currentPanelIndex = viewManager ? viewManager->getCurrentPanelIndex() : -1;
    bool trackerCellFocused = false;
    bool onHeaderRow = false;
    bool isParentWidgetFocused = false;
    
    // Check if we're actually in tracker panel first
    bool inTrackerPanelByIndex = (tracker && viewManager && currentPanelIndex == 2);
    
    if (tracker && inTrackerPanelByIndex) {
        int editStep = tracker->getEditStep();
        int editColumn = tracker->getEditColumn();
        // Check if a valid cell is focused (indicates user is interacting with tracker)
        trackerCellFocused = (editStep >= 0 && editStep < tracker->getNumSteps() && editColumn >= 0);
        // Check if on header row (editStep == -1 means focus is on header row, not a data cell)
        // But only if we're actually in tracker panel
        onHeaderRow = (editStep == -1 && !tracker->getIsEditingCell());
        
        // Check if parent widget is focused (from GUI)
        if (trackerGUI) {
            isParentWidgetFocused = trackerGUI->getIsParentWidgetFocused();
        }
    }
    
    ofLogNotice("InputRouter") << "  Panel check: tracker=" << (tracker ? "YES" : "NO")
        << ", viewManager=" << (viewManager ? "YES" : "NO")
        << ", currentPanelIndex=" << currentPanelIndex
        << ", trackerCellFocused=" << (trackerCellFocused ? "YES" : "NO")
        << ", onHeaderRow=" << (onHeaderRow ? "YES" : "NO")
        << ", isParentWidgetFocused=" << (isParentWidgetFocused ? "YES" : "NO");
    
    // Use either panel index check OR tracker cell focused check
    // Only include onHeaderRow if we're actually in tracker panel
    bool inTrackerPanel = inTrackerPanelByIndex || trackerCellFocused;
    
    if (tracker && inTrackerPanel) {
        // Check for modifier keys properly
        bool ctrlPressed = keyEvent.hasModifier(OF_KEY_CONTROL);
        bool shiftPressed = keyEvent.hasModifier(OF_KEY_SHIFT);
        bool cmdPressed = keyEvent.hasModifier(OF_KEY_COMMAND);
        
        // CRITICAL: In edit mode, block arrow keys from ImGui navigation
        // This prevents ImGui from moving focus when arrow keys adjust values
        bool inEditMode = tracker->getIsEditingCell();
        
        // CRITICAL: Route Enter and numeric keys even when ImGui wants keyboard
        // This ensures these keys work when cells are focused
        // CRITICAL: In edit mode, ALWAYS route arrow keys to tracker BEFORE ImGui can process them
        // This prevents ImGui from using arrow keys for navigation and changing focus
        if (inEditMode && (key == OF_KEY_UP || key == OF_KEY_DOWN || 
                           key == OF_KEY_LEFT || key == OF_KEY_RIGHT)) {
            // Arrow keys in edit mode: always route to tracker (adjust values)
            // Don't let ImGui use them for navigation - this locks focus to the editing cell
            // Sync state first to ensure tracker knows current cell
            syncEditStateFromImGuiFocus();
            if (tracker->handleKeyPress(key, ctrlPressed, shiftPressed)) {
                ofLogNotice("InputRouter") << "  Arrow key in edit mode: HANDLED by tracker (blocked from ImGui)";
                logKeyPress(key, "Tracker: Arrow key in edit mode (blocked from ImGui)");
                return true; // Consume the key to prevent ImGui from processing
            }
        }
        
        // Don't route UP key when on parent widget - let ImGui handle normal navigation
        if (isParentWidgetFocused && key == OF_KEY_UP && !inEditMode) {
            ofLogNotice("InputRouter") << "  UP key on parent widget: letting ImGui handle (not routing to tracker)";
            return false; // Let ImGui process the key normally
        }
        
        // When on header row, set flag to move focus to parent widget using ImGui's navigation API
        // We don't consume the key - let it fall through to ImGui, but also explicitly move focus
        if (onHeaderRow && key == OF_KEY_UP && !inEditMode) {
            ofLogNotice("InputRouter") << "  UP key on header row: requesting focus move to parent widget";
            // Set flag for GUI to move focus to parent widget in next frame
            tracker->requestFocusMoveToParentWidget();
            // Clear cell focus so ImGui sees correct state
            tracker->clearCellFocus();
            // Don't consume the key - let ImGui handle it, but we've set the flag for explicit focus move
            return false; // Let ImGui process the key
        }
        
        // Enter key: Check for Ctrl+Enter (go up a level) vs Shift+Enter (exit grid)
        if (key == OF_KEY_RETURN) {
            // Ctrl+Enter: Go up a level (focus parent container)
            if (ctrlPressed && !shiftPressed) {
                // Check if we're inside a container (cell focused or on header row)
                if (trackerCellFocused || onHeaderRow) {
                    ofLogNotice("InputRouter") << "  Ctrl+Enter: requesting focus move to parent container";
                    tracker->requestFocusMoveToParentWidget();
                    tracker->clearCellFocus();
                    return true; // Consume the key
                }
            }
            
            // When on header row, don't route Enter to tracker - let ImGui handle it
            if (onHeaderRow && !ctrlPressed && !shiftPressed) {
                ofLogNotice("InputRouter") << "  Enter key on header row: letting ImGui handle (not routing to tracker)";
                return false; // Let ImGui process the key
            }
            
            ofLogNotice("InputRouter") << "  Enter key detected in tracker panel";
            // Ctrl+Enter is already handled above, so this is for other Enter cases
            if (ctrlPressed) {
                // This shouldn't happen (already handled above), but keep for safety
                ofLogNotice("InputRouter") << "  Ctrl+Enter: Going up a level (fallback)";
                if (tracker->handleKeyPress(key, true, false)) {
                    logKeyPress(key, "Tracker: Ctrl+Enter (go up level)");
                    return true;
                }
            } else if (shiftPressed) {
                // Shift+Enter: Exit grid navigation (clear cell selection)
                ofLogNotice("InputRouter") << "  Shift+Enter: Exiting grid";
                if (tracker->handleKeyPress(key, false, true)) {
                    logKeyPress(key, "Tracker: Shift+Enter (exit grid)");
                    return true;
                }
            } else {
                // Regular Enter: Always try to handle it if we're in tracker panel
                // CRITICAL: Sync editStep/editColumn from ImGui focus BEFORE calling handleKeyPress
                // This ensures the tracker knows which cell is focused even if GUI sync hasn't happened yet
                ofLogNotice("InputRouter") << "  Regular Enter: Syncing edit state from ImGui focus";
                syncEditStateFromImGuiFocus();
                
                // DEBUG: Log frame count and state before handling
                int currentFrame = ImGui::GetFrameCount();
                int editStep = tracker->getEditStep();
                int editColumn = tracker->getEditColumn();
                bool isEditing = tracker->getIsEditingCell();
                ofLogNotice("InputRouter") << "  Enter key at frame=" << currentFrame
                    << ", editStep=" << editStep << ", editColumn=" << editColumn
                    << ", isEditingCell=" << (isEditing ? "YES" : "NO");
                
                bool handled = tracker->handleKeyPress(key, false, false);
                if (handled) {
                    if (currentStep) {
                        *currentStep = tracker->getCurrentStep();
                    }
                    ofLogNotice("InputRouter") << "  Enter key HANDLED by tracker";
                    logKeyPress(key, "Tracker: Enter (handled)");
                    return true;
                } else {
                    // Enter was pressed but tracker didn't handle it
                    // This might mean editStep/editColumn aren't set yet
                    ofLogWarning("InputRouter") << "  Enter key NOT handled by tracker. editStep=" << editStep 
                        << ", editColumn=" << editColumn << ", isEditingCell=" << (isEditing ? "YES" : "NO");
                    
                    // Still consume it to prevent ImGui from activating buttons
                    // The tracker should handle it next frame once GUI sync happens
                    return true; // Consume to prevent ImGui from processing
                }
            }
        }
        
        // Route numeric keys and edit mode keys to tracker
        // This allows typing numbers to auto-enter edit mode, and handles edit mode input
        ofLogNotice("InputRouter") << "  Checking numeric keys: inEditMode=" << (inEditMode ? "YES" : "NO");
        if (inEditMode) {
            // In edit mode: Arrow keys already handled above, now handle numeric input
            // Numeric keys (including numpad - openFrameworks converts numpad to regular '0'-'9')
            // Also handle decimal point, minus, backspace, delete for numeric input
            if ((key >= '0' && key <= '9') ||
                key == '.' || key == '-' || key == OF_KEY_BACKSPACE || key == OF_KEY_DEL) {
                ofLogNotice("InputRouter") << "  Numeric key '" << (char)key << "' in edit mode - routing to tracker";
                if (tracker->handleKeyPress(key, ctrlPressed, shiftPressed)) {
                    ofLogNotice("InputRouter") << "  Numeric key HANDLED by tracker (in edit mode)";
                    logKeyPress(key, "Tracker: Numeric key in edit mode");
                    return true;
                } else {
                    ofLogWarning("InputRouter") << "  Numeric key NOT handled by tracker (in edit mode)";
                }
            }
        } else {
            // Not in edit mode: Route numeric keys to tracker for direct typing
            // This allows typing numbers to auto-enter edit mode
            // CRITICAL: Route these even if ImGui wants keyboard, because we need to enter edit mode
            if ((key >= '0' && key <= '9') || key == '.' || key == '-') {
                ofLogNotice("InputRouter") << "  Numeric key '" << (char)key << "' detected (not in edit mode)";
                // CRITICAL: Sync editStep/editColumn from ImGui focus BEFORE calling handleKeyPress
                // This ensures the tracker knows which cell is focused even if GUI sync hasn't happened yet
                ofLogNotice("InputRouter") << "  Syncing edit state from ImGui focus";
                syncEditStateFromImGuiFocus();
                
                // DEBUG: Log frame count and state before handling
                int currentFrame = ImGui::GetFrameCount();
                int editStep = tracker->getEditStep();
                int editColumn = tracker->getEditColumn();
                ofLogNotice("InputRouter") << "  Numeric key '" << (char)key << "' at frame=" 
                    << currentFrame << ", editStep=" << editStep << ", editColumn=" << editColumn;
                
                bool handled = tracker->handleKeyPress(key, ctrlPressed, shiftPressed);
                
                if (handled) {
                    ofLogNotice("InputRouter") << "  Numeric key HANDLED by tracker (entered edit mode)";
                    logKeyPress(key, "Tracker: Numeric key (auto-enter edit mode)");
                    return true;
                } else {
                    // Numeric key not handled - might be because no cell is focused
                    // The tracker should have defaulted to first cell if editStep/editColumn weren't set
                    ofLogWarning("InputRouter") << "  Numeric key '" << (char)key << "' NOT handled by tracker. "
                        << "editStep=" << editStep << ", editColumn=" << editColumn;
                    
                    // Still consume it to prevent ImGui from processing
                    // The tracker should handle it next frame once GUI sync happens
                    return true; // Consume to prevent ImGui from processing
                }
            }
        }
        
        ofLogNotice("InputRouter") << "  Key not matched for tracker input, checking other handlers...";
        
        // Handle other tracker input with proper modifiers
        if (handleTrackerInput(keyEvent)) {
            ofLogNotice("InputRouter") << "  Key handled by handleTrackerInput";
            return true;
        }
        
        ofLogNotice("InputRouter") << "  Key not handled in tracker panel section";
    }
    
    // Handle MediaPool container navigation (Ctrl+Enter to go up a level)
    // Check if we're in MediaPool panel
    bool inMediaPoolPanel = (mediaPool && viewManager && currentPanelIndex == 3);
    if (inMediaPoolPanel && key == OF_KEY_RETURN) {
        bool ctrlPressed = keyEvent.hasModifier(OF_KEY_CONTROL);
        bool shiftPressed = keyEvent.hasModifier(OF_KEY_SHIFT);
        
        // Ctrl+Enter: Go up a level (focus parent container)
        if (ctrlPressed && !shiftPressed) {
            // Check if we're inside the media list (a Selectable is focused)
            // We can detect this by checking if parent widget is NOT focused
            // (if parent widget is focused, we're already at parent level)
            if (mediaPoolGUI && !mediaPoolGUI->getIsParentWidgetFocused()) {
                ofLogNotice("InputRouter") << "  Ctrl+Enter in MediaPool: requesting focus move to parent container";
                mediaPoolGUI->requestFocusMoveToParent();
                return true; // Consume the key
            }
        }
    }
    
    if (!inTrackerPanel) {
        ofLogNotice("InputRouter") << "  NOT in tracker panel (currentPanelIndex=" << currentPanelIndex 
            << ", trackerCellFocused=" << (trackerCellFocused ? "YES" : "NO") << ")";
    }
    
    return false;
}

bool InputRouter::handleGlobalShortcuts(int key) {
    // Global shortcuts work even when ImGui has focus

    switch (key) {
        case ' ':  // SPACE - Play/Stop (always works, even when ImGui has focus)
            if (clock) {
                bool currentlyPlaying = (isPlaying && *isPlaying);
                if (currentlyPlaying) {
                    clock->stop();
                    if (isPlaying) *isPlaying = false;
                    logKeyPress(key, "Global: Stop");
                } else {
                    clock->start();
                    if (isPlaying) *isPlaying = true;
                    logKeyPress(key, "Global: Start");
                }
                return true;  // Always return true to prevent ImGui from processing spacebar
            }
            break;

        case 'r':
        case 'R':  // R - Reset
            if (clock) {
                clock->reset();
                if (tracker) tracker->reset();
                if (currentStep) *currentStep = 0;
                if (lastTriggeredStep) *lastTriggeredStep = 0;
                logKeyPress(key, "Global: Reset");
                return true;
            }
            break;

        case 'g':
        case 'G':  // G - Toggle GUI
            if (showGUI) {
                *showGUI = !*showGUI;
                logKeyPress(key, "Global: Toggle GUI");
                return true;
            }
            break;

        case 'n':
        case 'N':  // N - Next media
            if (mediaPool) {
                mediaPool->nextPlayer();
                logKeyPress(key, "Global: Next media");
                return true;
            }
            break;

        case 'm':
        case 'M':  // M - Previous media
            if (mediaPool) {
                mediaPool->previousPlayer();
                logKeyPress(key, "Global: Previous media");
                return true;
            }
            break;

        case 'S':  // S - Save pattern (capital S to distinguish from speed)
            if (tracker) {
                tracker->saveState("pattern.json");
                logKeyPress(key, "Global: Save pattern");
                return true;
            }
            break;
    }

    return false;
}

bool InputRouter::handlePanelNavigation(ofKeyEventArgs& keyEvent) {
    if (!viewManager) return false;
    
    int key = keyEvent.key;
    if (key == OF_KEY_TAB) {
        bool shiftPressed = keyEvent.hasModifier(OF_KEY_SHIFT);
        if (shiftPressed) {
            viewManager->previousPanel();
        } else {
            viewManager->nextPanel();
        }
        logKeyPress(key, "Navigation: Ctrl+Tab");
        return true;
    }
    return false;
}

bool InputRouter::handleTrackerInput(ofKeyEventArgs& keyEvent) {
    if (!tracker) return false;
    
    int key = keyEvent.key;
    bool ctrlPressed = keyEvent.hasModifier(OF_KEY_CONTROL);
    bool shiftPressed = keyEvent.hasModifier(OF_KEY_SHIFT);
    
    // Delegate to TrackerSequencer with proper modifier flags
    if (tracker->handleKeyPress(key, ctrlPressed, shiftPressed)) {
        if (currentStep) {
            *currentStep = tracker->getCurrentStep();
        }
        logKeyPress(key, "Tracker input");
        return true;
    }
    return false;
}

void InputRouter::updateImGuiCaptureState() {
    ImGuiIO& io = ImGui::GetIO();
    imGuiCapturingKeyboard = io.WantCaptureKeyboard;
}

bool InputRouter::isImGuiCapturingKeyboard() const {
    return imGuiCapturingKeyboard;
}

bool InputRouter::isSequencerInEditMode() const {
    return tracker ? tracker->getIsEditingCell() : false;
}

void InputRouter::syncEditStateFromImGuiFocus() {
    // Sync edit state from ImGui focus before processing keys
    // This ensures editStep/editColumn are set even if GUI draw sync hasn't happened yet
    if (tracker) {
        TrackerSequencerGUI::syncEditStateFromImGuiFocus(*tracker);
    }
}

void InputRouter::logKeyPress(int key, const char* context) {
    ofLogVerbose("InputRouter") << context << " - Key: " << key;
}

#pragma once
#include "ofMain.h"

class Clock;
class TrackerSequencer;
class TrackerSequencerGUI;
class ViewManager;
class MediaPool;
class MediaPoolGUI;

class InputRouter {
public:
    InputRouter();
    ~InputRouter() = default;

    // Setup with references to controllable systems
    void setup(
        Clock* clock,
        TrackerSequencer* tracker,
        TrackerSequencerGUI* trackerGUI,
        ViewManager* viewManager,
        MediaPool* mediaPool,
        MediaPoolGUI* mediaPoolGUI
    );

    // Callbacks for state that needs to be updated
    void setPlayState(bool* isPlaying);
    void setCurrentStep(int* currentStep);
    void setLastTriggeredStep(int* lastTriggeredStep);
    void setShowGUI(bool* showGUI);

    // Main keyboard handler - called from ofApp::keyPressed()
    // Returns true if the input was consumed (don't pass to others)
    bool handleKeyPress(ofKeyEventArgs& keyEvent);

    // System state flags
    bool isImGuiCapturingKeyboard() const;
    bool isSequencerInEditMode() const;

private:
    // System references
    Clock* clock = nullptr;
    TrackerSequencer* tracker = nullptr;
    TrackerSequencerGUI* trackerGUI = nullptr;
    ViewManager* viewManager = nullptr;
    MediaPool* mediaPool = nullptr;
    MediaPoolGUI* mediaPoolGUI = nullptr;

    // State references (optional - can be nullptr)
    bool* isPlaying = nullptr;
    int* currentStep = nullptr;
    int* lastTriggeredStep = nullptr;
    bool* showGUI = nullptr;

    // Keyboard capture state
    bool imGuiCapturingKeyboard = false;

    // Handler methods for different input categories
    bool handleGlobalShortcuts(int key);
    bool handlePanelNavigation(ofKeyEventArgs& keyEvent);
    bool handleTrackerInput(ofKeyEventArgs& keyEvent);

    // Helper to check ImGui capture state
    void updateImGuiCaptureState();
    
    // Helper to sync edit state from ImGui focus (if a cell is focused)
    void syncEditStateFromImGuiFocus();

    // Logging helper
    void logKeyPress(int key, const char* context);
};

//
//  main.cpp
//
//  Audiovisual Sequencer Example
//

#include "ofMain.h"
#include "ofApp.h"

int main() {
    ofSetupOpenGL(1280, 720, OF_WINDOW);
    ofRunApp(new ofApp());
}
//
//  ofApp.cpp
//
//  Audiovisual Sequencer Example - Time + Sound + Video coordination
//

#include "ofApp.h"
#include <filesystem>
#include <future>

//--------------------------------------------------------------
ofApp::~ofApp() noexcept {
    // No auto-save - use menu buttons instead
}

//--------------------------------------------------------------
void ofApp::setup() {
    ofSetFrameRate(60);
    ofSetVerticalSync(true);
    ofSetLogLevel(OF_LOG_NOTICE);
    
    // Setup media library with correct path for app bundle
    std::string absolutePath;
    
    // Try multiple possible paths
    // Try to load saved media directory first
    std::string savedMediaDir = loadMediaDirectory();
    bool foundDataDir = false;
    
    if (!savedMediaDir.empty() && ofDirectory(savedMediaDir).exists()) {
        mediaPool.setDataDirectory(savedMediaDir);
        foundDataDir = true;
    } else {
        // Fallback to default paths
        std::vector<std::string> possiblePaths;
        try {
            std::string cwd = ofFilePath::getCurrentWorkingDirectory();
            possiblePaths.push_back(cwd + "/bin/data");
            possiblePaths.push_back(cwd + "/data");
        } catch (const std::filesystem::filesystem_error& e) {
            ofLogWarning("ofApp") << "Filesystem error getting current directory: " << e.what();
        } catch (const std::exception& e) {
            ofLogWarning("ofApp") << "Exception getting current directory: " << e.what();
        } catch (...) {
            ofLogWarning("ofApp") << "Unknown exception getting current directory";
        }
        possiblePaths.push_back("/Users/jaufre/works/of_v0.12.1_osx_release/addons/ofxMediaObjects/example-audiovisualSequencer/bin/data");
        
        for (const auto& path : possiblePaths) {
            if (ofDirectory(path).exists()) {
                mediaPool.setDataDirectory(path);
                saveMediaDirectory(path); // Save for next launch
                foundDataDir = true;
                break;
            }
        }
        
        if (!foundDataDir) {
            ofLogError("ofApp") << "âŒ No data directory found in any of the tried paths";
        }
    }
    
    
    // Setup TrackerSequencer with clock reference
    trackerSequencer.setup(&clock, numSteps);
    
    // Auto-load saved state if it exists
    trackerSequencer.loadState("tracker_sequencer_state.json");
    
    // Setup MediaPool directory change callback
    mediaPool.setDirectoryChangeCallback([this](const std::string& path) {
        saveMediaDirectory(path);
    });
    
    
    // Register step event listener
    // Modular connection: MediaPool subscribes to TrackerSequencer trigger events
    // This replaces the old routing logic in ofApp::onTrackerStepEvent()
    mediaPool.subscribeToTrackerSequencer(&trackerSequencer);
    
    // Legacy: Keep old event listener for backward compatibility (can be removed later)
    trackerSequencer.addStepEventListener([this](int step, float duration, const PatternCell& cell) {
        onTrackerStepEvent(step, duration, cell);
    });
    
    // Setup time objects using Clock wrapper
    clock.setup();
    
    // Setup MediaPool with clock reference
    mediaPool.setup(&clock);
    
    // Initialize MediaPoolGUI with reference to mediaPool
    mediaPoolGUI.setMediaPool(mediaPool);
    
    // Setup TrackerSequencer callbacks for UI queries
    trackerSequencer.setIndexRangeCallback([this]() {
        return mediaPool.getNumPlayers();
    });
    
    // Setup parameter synchronization between TrackerSequencer and MediaPool
    // Connect TrackerSequencer currentStepPosition to MediaPool position (bidirectional)
    // Sync only when clock is paused (for editing)
    parameterSync.connect(
        &trackerSequencer,
        "currentStepPosition",
        &mediaPool,
        "position",
        [this]() {
            // Only sync when paused (for editing)
            return !clock.isPlaying();
        }
    );
    
    // Reverse connection (MediaPool -> TrackerSequencer)
    parameterSync.connect(
        &mediaPool,
        "position",
        &trackerSequencer,
        "currentStepPosition",
        [this]() {
            // Only sync when paused AND when MediaPool is not in manual preview
            // This allows manual preview to work independently
            return !clock.isPlaying() && !mediaPool.isManualPreview();
        }
    );
    
    // Set up parameter change callbacks for both modules
    trackerSequencer.setParameterChangeCallback([this](const std::string& paramName, float value) {
        if (paramName == "currentStepPosition") {
            parameterSync.notifyParameterChange(&trackerSequencer, paramName, value);
        }
    });
    
    mediaPool.setParameterChangeCallback([this](const std::string& paramName, float value) {
        if (paramName == "position") {
            parameterSync.notifyParameterChange(&mediaPool, paramName, value);
        }
    });
    
    // TrackerSequencer now uses Clock's beat events for sample-accurate timing
    // Add step event listener for visual feedback (legacy - can be removed later)
    trackerSequencer.addStepEventListener([this](int step, float duration, const PatternCell& cell) {
        lastTriggeredStep = step;
    });
    
    
    // Setup visual objects
    setupVisualObjects();
    
    // Note: Audio setup is now handled by ViewManager
    
    // Connect Clock transport events to MediaPool for proper state management
    clock.addTransportListener([this](bool isPlaying) {
        // Forward transport events to MediaPool
        mediaPool.onTransportChanged(isPlaying);
    });
    
    
    // Setup GUI
    setupGUI();
    
    // Setup MenuBar with callbacks
    menuBar.setup(
        [this]() { trackerSequencer.saveState("tracker_sequencer_state.json"); },
        [this]() { trackerSequencer.loadState("tracker_sequencer_state.json"); },
        [this]() { saveLayout(); },
        [this]() { loadLayout(); }
    );
    
    // Setup ViewManager with panel objects and sound stream
    viewManager.setup(
        &clock,
        &clockGUI,
        &soundOutput,
        &trackerSequencer,
        &trackerSequencerGUI,
        &mediaPool,
        &mediaPoolGUI,
        &soundStream
    );
    
    // Set audio listener and setup initial audio stream
    viewManager.setAudioListener(this);
    viewManager.setupAudioStream(this);
    
    // Setup InputRouter with system references
    inputRouter.setup(
        &clock,
        &trackerSequencer,
        &trackerSequencerGUI,
        &viewManager,
        &mediaPool,
        &mediaPoolGUI
    );
    
    // Setup InputRouter state callbacks
    // Note: Play state now comes directly from Clock (single source of truth)
    // InputRouter has Clock reference from setup() call above
    inputRouter.setCurrentStep(&currentStep);
    inputRouter.setLastTriggeredStep(&lastTriggeredStep);
    inputRouter.setShowGUI(&showGUI);
    
    // Try to load saved state, otherwise use default pattern
    if (!trackerSequencer.loadState("tracker_sequencer_state.json")) {
        // Initialize pattern with some default steps if no saved state
        if (mediaPool.getNumPlayers() > 0) {
            PatternCell cell0(0, 0.0f, 1.0f, 1.0f, 1.0f);
            trackerSequencer.setCell(0, cell0);
            
            if (mediaPool.getNumPlayers() > 1) {
                PatternCell cell4(1, 0.0f, 1.2f, 1.0f, 1.0f);
                trackerSequencer.setCell(4, cell4);
                
                PatternCell cell8(0, 0.5f, 1.0f, 1.0f, 1.0f);
                trackerSequencer.setCell(8, cell8);
            }
            
            // Save the default pattern
            trackerSequencer.saveState("tracker_sequencer_state.json");
        } else {
            ofLogWarning("ofApp") << "No media items available for pattern initialization";
        }
    }
    
    // Clock listener is set up in setupTimeObjects()
    
    // Initialize first active player after everything is set up
    mediaPool.initializeFirstActivePlayer();
    
    // Load default layout on startup
    loadLayout();
}

//--------------------------------------------------------------
void ofApp::update() {
    // PERFORMANCE: Only update the active player, not all 117 players
    auto currentPlayer = mediaPool.getActivePlayer();
    if (currentPlayer) {
        // CRITICAL FIX: Always call update() to check for gate ending
        // The gate ending check in MediaPlayer::update() must run every frame
        // to detect when scheduledStopActive expires, even if player appears stopped
        currentPlayer->update();
        
        // Process visual pipeline - only when actually playing (performance optimization)
        if (currentPlayer->isPlaying() && currentPlayer->videoEnabled.get() && currentPlayer->isVideoLoaded()) {
            auto& videoPlayer = currentPlayer->getVideoPlayer();
            videoPlayer.update();  // Just update, no FBO processing needed
        }
    }
    
    // Update MediaPool for end-of-media detection
    mediaPool.update();
    
    // Update step active state (clears manually triggered steps when duration expires)
    trackerSequencer.updateStepActiveState();
    
    // Connect active player (internal flag check prevents redundant connections)
    // PERFORMANCE: Only call connectActivePlayer when player is actually playing or just started
    // The playerConnected flag prevents redundant connections, but we avoid calling it every frame
    // when nothing is playing to reduce overhead
    if (currentPlayer && (currentPlayer->isPlaying() || !mediaPool.isPlayerConnected())) {
        mediaPool.connectActivePlayer(soundOutput, visualOutput);
    }


    // PERFORMANCE: Rate-limit parameter synchronization to 15Hz instead of 60Hz
    // Most parameters don't change every frame, so we can reduce CPU overhead by checking less frequently
    static int syncFrameCounter = 0;
    if (++syncFrameCounter >= 4) {  // Sync every 4 frames (15Hz instead of 60Hz)
        parameterSync.update();
        syncFrameCounter = 0;
    }
    
    // PERFORMANCE: Periodic auto-save every 30 seconds (async to avoid frame drops)
    // File I/O in update loop can cause 10-50ms stuttering every 30 seconds
    static float lastAutoSave = 0.0f;
    static bool saveInProgress = false;
    float elapsed = ofGetElapsedTimef();
    
    if (elapsed - lastAutoSave > 30.0f && !saveInProgress) {
        saveInProgress = true;
        lastAutoSave = elapsed;  // Update immediately to prevent multiple triggers
        // Async save in background thread to avoid blocking main thread
        auto future = std::async(std::launch::async, [this]() {
            trackerSequencer.saveState("tracker_sequencer_state.json");
            saveInProgress = false;  // Reset flag after save completes
            ofLogVerbose("ofApp") << "Periodic auto-save completed";
        });
        (void)future;  // Explicitly ignore return value to silence warning
    }
}

//--------------------------------------------------------------
void ofApp::draw() {
    try {
        ofBackground(0, 0, 0);
        
        // Draw video if available and currently playing
        auto currentPlayer = mediaPool.getActivePlayer();
        if (currentPlayer && currentPlayer->isVideoLoaded() && 
            currentPlayer->videoEnabled.get() && currentPlayer->isPlaying()) {
            try {
                auto& videoPlayer = currentPlayer->getVideoPlayer();
                auto& videoFile = videoPlayer.getVideoFile();
                if (videoFile.isLoaded() && videoFile.getTexture().isAllocated()) {
                    ofSetColor(255, 255, 255);
                    videoFile.getTexture().draw(0, 0, ofGetWidth(), ofGetHeight());
                }
            } catch (const std::exception& e) {
                ofLogError("ofApp") << "Exception drawing video: " << e.what();
            } catch (...) {
                ofLogError("ofApp") << "Unknown exception drawing video";
            }
        }
        
        // Draw GUI
        if (showGUI) {
            drawGUI();
        }
    } catch (const std::exception& e) {
        ofLogError("ofApp") << "Exception in draw(): " << e.what();
    } catch (...) {
        ofLogError("ofApp") << "Unknown exception in draw()";
    }
}

//--------------------------------------------------------------
void ofApp::exit() {
    // Auto-save TrackerSequencer state before exiting
    if (trackerSequencer.saveState("tracker_sequencer_state.json")) {
        ofLogNotice("ofApp") << "TrackerSequencer state saved to file";
    }
    
    clock.stop();
    soundStream.close();
}

//--------------------------------------------------------------
void ofApp::audioOut(ofSoundBuffer& buffer) {
    // Process audio-rate clock first (sample-accurate timing)
    clock.audioOut(buffer);
    
    // Audio processing happens in sound objects
    soundOutput.audioOut(buffer);
    
    // Apply global volume AFTER sound processing (from ViewManager)
    buffer *= viewManager.getGlobalVolume();
    
    // Simple audio level calculation for visualization
    float maxLevel = 0.0f;
    for (size_t i = 0; i < buffer.getNumFrames() * buffer.getNumChannels(); i++) {
        maxLevel = std::max(maxLevel, std::abs(buffer[i]));
    }
    viewManager.setCurrentAudioLevel(maxLevel);
}

//--------------------------------------------------------------
void ofApp::keyPressed(ofKeyEventArgs& keyEvent) {
    // Route all keyboard input through InputRouter
    // If InputRouter handled the key, return early to prevent ImGui from processing it
    if (inputRouter.handleKeyPress(keyEvent)) {
        return;
    }
    
    // If InputRouter didn't handle it, let ImGui process it
    // This allows normal text input and other ImGui interactions
}

//--------------------------------------------------------------
void ofApp::mousePressed(int x, int y, int button) {
    // Handle mouse clicks through TrackerSequencer
    if (showGUI) {
        trackerSequencer.handleMouseClick(x, y, button);
    }
}

//--------------------------------------------------------------
void ofApp::windowResized(int w, int h) {
    // Window resize handled by ImGui docking automatically
    
    // Update visual output dimensions
    visualOutput.width.set(w);
    visualOutput.height.set(h);
    
    ofLogNotice("ofApp") << "Window resized to " << w << "x" << h;
}


//--------------------------------------------------------------
void ofApp::onTrackerStepEvent(int step, float duration, const PatternCell& cell) {
    // LEGACY: This function is kept for backward compatibility but is no longer needed
    // MediaPool now subscribes directly to TrackerSequencer trigger events via subscribeToTrackerSequencer()
    // This removes the tight coupling between ofApp, TrackerSequencer, and MediaPool
    
    // Changed to verbose logging to avoid performance issues during playback
    ofLogVerbose("ofApp") << "TrackerSequencer step event: step=" << step << ", duration=" << duration << "s, length=" << cell.length;
    
    // Synchronize ofApp::currentStep with TrackerSequencer::currentStep (for UI display)
    currentStep = step;
    
    // NOTE: MediaPool is now triggered via the modular event system
    // The old routing logic below has been moved to MediaPool::onTrigger()
    // This function can be removed once we're confident the new system works
}

//--------------------------------------------------------------
void ofApp::setupSoundObjects() {
    // Setup sound output
    soundOutput.setName("Sound Output");
    
    // Note: Audio device management is now handled by ViewManager
    // Global volume is applied in audioOut callback using viewManager.getGlobalVolume()
}

//--------------------------------------------------------------
void ofApp::setupVisualObjects() {
    // Setup visual output
    visualOutput.setName("Visual Output");
    
    // Initialize visual output with proper dimensions
    visualOutput.width.set(ofGetWidth());
    visualOutput.height.set(ofGetHeight());
    visualOutput.enabled.set(true);
    
    // Note: Visual output will allocate its own buffer when needed
    
    // Video connection handled by mediaSequencer
}

// No bridge setup needed - direct connections only

//--------------------------------------------------------------
void ofApp::setupGUI() {
    // Setup ImGui with docking enabled and proper ini file handling
    gui.setup(nullptr, true, ImGuiConfigFlags_DockingEnable);
    
    // Initialize ImPlot
    ImPlot::CreateContext();
    
    // Set ini filename for auto-loading on startup
    ImGuiIO& io = ImGui::GetIO();
    io.IniFilename = "imgui.ini";
    
    // Set up ImGui with keyboard navigation
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

    ImGuiStyle& style = ImGui::GetStyle();
 
    style.Colors[ImGuiCol_DockingEmptyBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);

    style.Colors[ImGuiCol_WindowBg] = ImVec4(0.1f, 0.1f, 0.1f, 0.7f);        // Dark neutral grey panels
    style.Colors[ImGuiCol_ChildBg] = ImVec4(0.15f, 0.15f, 0.15f, 0.6f);  
    style.Colors[ImGuiCol_PopupBg] = ImVec4(0.1f, 0.1f, 0.1f, 0.95f);
    style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.5f); // Modal dimming

    style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.8f);     

    style.Colors[ImGuiCol_TitleBg] = ImVec4(0.01f, 0.01f, 0.01f, 0.65f);          // Window title background
    style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.15f, 0.15f, 0.8f, 0.75f); // Active title background
    // style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.05f, 0.05f, 0.05f, 0.7f); // Collapsed title background
    
    style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.1f, 0.1f, 0.1f, 0.8f);      // Scrollbar background
    style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.3f, 0.3f, 0.3f, 0.8f);    // Scrollbar grab
    style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.4f, 0.4f, 0.4f, 0.9f); // Scrollbar hover
    style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.5f, 0.5f, 0.5f, 1.0f); // Scrollbar active
    
    style.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.2f, 0.2f, 0.2f, 0.8f);       // Resize grip
    // style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.3f, 0.3f, 0.3f, 0.9f); // Resize grip hover
    //style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.4f, 0.4f, 0.4f, 1.0f); // Resize grip active
    
    style.Colors[ImGuiCol_Tab] = ImVec4(0.1f, 0.1f, 0.1f, 0.8f);              // Tab background
    style.Colors[ImGuiCol_TabHovered] = ImVec4(0.2f, 0.2f, 0.45f, 0.75f);      // Tab hover
    style.Colors[ImGuiCol_TabActive] = ImVec4(0.05f, 0.05f, 0.2f, 0.8f);        // Tab active
    style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.05f, 0.05f, 0.05f, 0.7f);  // Tab unfocused
    style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.15f, 0.15f, 0.15f, 0.8f); // Tab unfocused active
    
    style.Colors[ImGuiCol_Separator] = ImVec4(0.2f, 0.2f, 0.2f, 0.8f);         // Dark separator
    style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.3f, 0.3f, 0.3f, 0.9f);   // Dark hover
    style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.4f, 0.4f, 0.4f, 1.0f);    // Dark active
    
    // Table / Grid colors
    style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.01f, 0.01f, 0.01f, 0.8f);   // Dark table headers
    style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.1f, 0.1f, 0.1f, 0.8f); // Dark borders
    style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.4f, 0.4f, 0.4f, 0.6f);  // Lighter borders
    style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);       // Transparent row backgrounds
    style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(0.05f, 0.05f, 0.05f, 0.5f); // Subtle alternating rows

    style.Colors[ImGuiCol_Header] = ImVec4(0.1f, 0.1f, 0.1f, 0.8f);          // Dark headers
    // style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.2f, 0.2f, 0.2f, 0.8f);   // Dark hover
    // style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.3f, 0.3f, 0.3f, 0.9f);    // Dark active
    
    style.Colors[ImGuiCol_Button] = ImVec4(0.3f, 0.3f, 0.3f, 0.8f);          // Dark buttons
    style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.1f, 0.1f, 0.9f, 0.9f);   // Dark hover
    style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.04f, 0.04f, 0.04f, 1.0f);    // Dark active
   
    style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.5f, 0.5f, 0.5f, 0.8f);      // Gray sliders
    style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.6f, 0.6f, 0.6f, 1.0f); // Gray active
    
    style.Colors[ImGuiCol_FrameBg] = ImVec4(0.03f, 0.03f, 0.03f, 0.75f);     // Dark frames
    style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.2f, 0.2f, 0.8f, 0.8f);  // Dark hover
    style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.15f, 0.15f, 0.15f, 0.9f); // Dark active
    
    style.Colors[ImGuiCol_Text] = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);            // Light text
    style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.5f, 0.5f, 0.5f, 1.0f);    // Disabled text
    
    style.Colors[ImGuiCol_Border] = ImVec4(0.2f, 0.2f, 0.2f, 0.8f);         // Dark borders
    style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);    // No shadow
    
}

//--------------------------------------------------------------
void ofApp::drawGUI() {
    try {
        gui.begin();
        
        // Ensure ImGui keyboard navigation is enabled (for arrow key navigation)
        ImGuiIO& io = ImGui::GetIO();
        
        // CRITICAL: Track window focus state using ImGui's AppFocusLost flag
        // This is set by the GLFW backend when the window loses/regains focus
        // This is more reliable than checking window focus states manually
        static bool lastAppFocusLost = false;
        bool appFocusLost = io.AppFocusLost;
        
        // Detect focus regain (transition from lost to regained)
        if (lastAppFocusLost && !appFocusLost) {
            // Window regained focus - clear stale focus states and reset navigation
            ofLogNotice("ofApp") << "[FOCUS_DEBUG] Window regained focus - resetting ImGui state";
            
            // Clear any active ImGui items that might be stuck
            // This prevents input fields or other widgets from staying in an active state
            if (ImGui::IsAnyItemActive()) {
                ImGui::ClearActiveID();
                ofLogNotice("ofApp") << "[FOCUS_DEBUG] Cleared active ImGui item";
            }
            
            // Reset ImGui navigation state to prevent stale navigation
            // Access internal context to reset navigation ID (prevents stuck navigation)
            ImGuiContext* g = ImGui::GetCurrentContext();
            if (g) {
                // Reset navigation ID to clear any stale navigation state
                // This ensures keyboard navigation works properly after regaining focus
                if (g->NavId != 0) {
                    g->NavId = 0;
                    g->NavIdIsAlive = false;
                    ofLogNotice("ofApp") << "[FOCUS_DEBUG] Reset ImGui navigation ID";
                }
                
                // Clear any focused item that might be stale
                if (g->ActiveId != 0) {
                    g->ActiveId = 0;
                    g->ActiveIdWindow = nullptr;
                    ofLogNotice("ofApp") << "[FOCUS_DEBUG] Cleared stale ActiveId";
                }
            }
            
            // Clear TrackerSequencer cell focus if it's stale
            if (trackerSequencerGUI.getEditStep() >= 0) {
                ofLogNotice("ofApp") << "[FOCUS_DEBUG] Clearing TrackerSequencer cell focus (step: " 
                                     << trackerSequencerGUI.getEditStep() 
                                     << ", column: " << trackerSequencerGUI.getEditColumn() << ")";
                trackerSequencerGUI.clearCellFocus();
            }
            
            // Clear MediaPoolGUI cell focus if it's stale
            if (mediaPoolGUI.isKeyboardFocused()) {
                ofLogNotice("ofApp") << "[FOCUS_DEBUG] Clearing MediaPoolGUI cell focus";
                mediaPoolGUI.clearCellFocus();
            }
            
            // Force reset ImGui navigation state - ensure keyboard navigation is enabled
            io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
            
            // Reset key and mouse states to prevent stuck keys from before focus was lost
            // This ensures keys/buttons pressed before losing focus don't remain "down" after regaining focus
            // ClearInputKeys() clears keyboard/gamepad state + text input buffer (equivalent to releasing all keys)
            io.ClearInputKeys();
            // ClearInputMouse() clears mouse button states
            io.ClearInputMouse();
            
            // Note: Don't manually set WantCaptureKeyboard/WantCaptureMouse - these are computed by ImGui
            // based on active widgets. They will be recalculated automatically in the next frame.
            
            ofLogNotice("ofApp") << "[FOCUS_DEBUG] Reset ImGui keyboard navigation and input states";
        } else if (!lastAppFocusLost && appFocusLost) {
            // Window lost focus
            ofLogNotice("ofApp") << "[FOCUS_DEBUG] Window lost focus";
        }
        
        lastAppFocusLost = appFocusLost;
        
        // Disable ImGui's Tab key handling - we handle Tab ourselves for panel navigation
        // This prevents ImGui from capturing Tab before our keyPressed handler
        io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableGamepad;
        
        // PERFORMANCE: Cache navigation state - only update ConfigFlags when state actually changes
        // Changing ConfigFlags every frame forces ImGui to rebuild navigation tables (2-5ms overhead)
        // Only update when the state transitions, not every frame
        static bool lastNavState = true;
        bool shouldEnableNav = !(viewManager.getCurrentPanelIndex() == 2 && trackerSequencerGUI.getIsEditingCell());
        
        if (shouldEnableNav != lastNavState) {
            // State changed - update ConfigFlags only now
            if (shouldEnableNav) {
                io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
                ofLogNotice("ofApp") << "[NAV_DEBUG] Enabled keyboard navigation";
            } else {
                io.ConfigFlags &= ~ImGuiConfigFlags_NavEnableKeyboard;
                ofLogNotice("ofApp") << "[NAV_DEBUG] Disabled keyboard navigation (cell editing)";
            }
            lastNavState = shouldEnableNav;
        }
        
        // Layout loading will be handled manually via menu buttons
        
        // Menu bar at top of main window
        menuBar.draw();

        ImGuiViewport* viewport = ImGui::GetMainViewport();
        ImGui::SetNextWindowPos(viewport->WorkPos);
        ImGui::SetNextWindowSize(viewport->WorkSize);
        ImGui::SetNextWindowViewport(viewport->ID);
        ImGui::SetNextWindowBgAlpha(0.0f);
        
        ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | 
                                       ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
                                       ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
        
                if (ImGui::Begin("DockSpace", nullptr, window_flags)) {
                    ImGui::DockSpace(ImGui::GetID("MyDockSpace"), ImVec2(0.0f, 0.0f), ImGuiDockNodeFlags_None);

                    // Draw all panels using ViewManager
                    viewManager.draw();
                }
                ImGui::End();

        // Navigation is already enabled (or will be re-enabled next frame if in edit mode)
        gui.end();
    } catch (const std::exception& e) {
        ofLogError("ofApp") << "Exception in drawGUI(): " << e.what();
    } catch (...) {
        ofLogError("ofApp") << "Unknown exception in drawGUI()";
    }
}

//--------------------------------------------------------------
void ofApp::saveLayout() {
    try {
        // Set the ini filename for saving
        ImGuiIO& io = ImGui::GetIO();
        io.IniFilename = "imgui.ini";
        
        std::string iniPath = ofToDataPath("imgui.ini", true);
        ImGui::SaveIniSettingsToDisk(iniPath.c_str());
        ofLogNotice("ofApp") << "Layout saved to " << iniPath;
    } catch (const std::exception& e) {
        ofLogError("ofApp") << "Exception in saveLayout(): " << e.what();
    } catch (...) {
        ofLogError("ofApp") << "Unknown exception in saveLayout()";
    }
}

//--------------------------------------------------------------
void ofApp::loadLayout() {
    try {
        // Set the ini filename for loading
        ImGuiIO& io = ImGui::GetIO();
        io.IniFilename = "imgui.ini";
        
        std::string iniPath = ofToDataPath("imgui.ini", true);
        
        if (ofFile::doesFileExist(iniPath)) {
            ImGui::LoadIniSettingsFromDisk(iniPath.c_str());
            ofLogNotice("ofApp") << "Layout loaded from " << iniPath;
        } else {
            ofLogNotice("ofApp") << "No saved layout found at " << iniPath;
        }
    } catch (const std::exception& e) {
        ofLogError("ofApp") << "Exception in loadLayout(): " << e.what();
    } catch (...) {
        ofLogError("ofApp") << "Unknown exception in loadLayout()";
    }
}


//--------------------------------------------------------------
std::string ofApp::loadMediaDirectory() {
    ofFile settingsFile("media_settings.json");
    if (settingsFile.exists()) {
        ofJson settings = ofJson::parse(settingsFile.readToBuffer().getText());
        if (settings.contains("mediaDirectory")) {
            return settings["mediaDirectory"].get<std::string>();
        }
    }
    return "";
}

//--------------------------------------------------------------
void ofApp::saveMediaDirectory(const std::string& path) {
    ofJson settings;
    settings["mediaDirectory"] = path;
    
    ofFile settingsFile("media_settings.json", ofFile::WriteOnly);
    settingsFile << settings.dump(4);
    ofLogNotice("ofApp") << "Saved media directory: " << path;
}


//
//  ofApp.h
//
//  Audiovisual Sequencer Example - Time + Sound + Video coordination
//

#pragma once

#include "ofMain.h"
#include "ofxSoundObjects.h"
#include "ofxVisualObjects.h"
#include "MediaPlayer.h"
#include "MediaPool.h"
#include "MediaPoolGUI.h"
#include "TrackerSequencer.h"
#include "TrackerSequencerGUI.h"
#include "Pattern.h"
#include "Clock.h"
#include "ClockGUI.h"
#include "ofxImGui.h"
#include "imgui_internal.h" // For DockBuilder API
#include "implot.h"
#include "gui/MenuBar.h"
#include "gui/ViewManager.h"
#include "input/InputRouter.h"
#include "ParameterSync.h"

class ofApp : public ofBaseApp {
public:
    ~ofApp() noexcept;
    void setup();
    void update();
    void draw();
    void exit();
    
    void keyPressed(ofKeyEventArgs& keyEvent);
    void mousePressed(int x, int y, int button);
    void windowResized(int w, int h);
    
    // Audio callbacks
    void audioOut(ofSoundBuffer& buffer);
    
    // Step event handler for TrackerSequencer
    void onTrackerStepEvent(int step, float duration, const PatternCell& cell);
    
private:
    // Time objects
    Clock clock;
    ClockGUI clockGUI;
    
    // Media pool system
    MediaPool mediaPool;
    MediaPoolGUI mediaPoolGUI;
    
    // TrackerSequencer for pattern management
    TrackerSequencer trackerSequencer;
    TrackerSequencerGUI trackerSequencerGUI;
    
    // Sound objects
    ofxSoundOutput soundOutput;
    
    // Visual objects
    ofxVisualOutput visualOutput;
    
    // No bridge system needed - direct connections only
    
    // Audio system
    ofSoundStream soundStream;
    ofSoundBuffer soundBuffer;
    
    // GUI system
    ofxImGui::Gui gui;
    
    // GUI managers
    MenuBar menuBar;
    ViewManager viewManager;
    InputRouter inputRouter;
    
    // Parameter synchronization system
    ParameterSync parameterSync;
    
    // GUI state
    bool showGUI = true;
    // Note: isPlaying removed - use clock.isPlaying() directly (Clock is single source of truth for transport)
    int numSteps = 16;
    
    // Note: Audio state (devices, volume, level) is now managed by ViewManager
    
    // Current step for GUI display (last triggered step)
    int currentStep = 0;
    int lastTriggeredStep = 0;  // Track the last step that was actually triggered
    
    // Media directory persistence
    std::string loadMediaDirectory();
    void saveMediaDirectory(const std::string& path);
    
    // Methods
    void setupSoundObjects();  // Minimal setup - audio device management is in ViewManager
    void setupVisualObjects();
    void setupGUI();
    
    void drawGUI();
    void setupDefaultLayout(bool forceReset = false);
    
    // Layout management
    void saveLayout();
    void loadLayout();
};
